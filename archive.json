{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2022-01-16T00:01:01.220373+00:00",
  "repo": "NTAP/rfc8312bis",
  "labels": [
    {
      "name": "design",
      "description": "Normative change relative to RFC8312 or earlier bis versions",
      "color": "d73a4a"
    },
    {
      "name": "editorial",
      "description": "Editorial change relative to RFC8312 or earlier bis versions",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "help wanted",
      "description": "Looking for someone resolve this issue",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "WG LC",
      "description": "",
      "color": "fef2c0"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "MDU6SXNzdWU3NDI4NTEzNzA=",
      "title": "Update K definition (Eq. 2) to account for Fast Convergence",
      "url": "https://github.com/NTAP/rfc8312bis/issues/1",
      "state": "CLOSED",
      "author": "WesleyRosenblum",
      "authorAssociation": "NONE",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [
        "design"
      ],
      "body": "As discussed in [this tcpm thread](https://mailarchive.ietf.org/arch/msg/tcpm/O7Q55oXcoI1XNBZ_wAQOMdhRQNY/), after fast convergence (section 4.6), the candidate target value of the congestion window may be less than the current congestion window. For example, say cwnd = 100, beta_cubic = .7 and a congestion event occurs:\r\n\r\n```\r\nW_max = cwnd = 100;\r\nW_max = W_max*(1.0+beta_cubic)/2.0 = 85   // further reduce W_max for fast convergence\r\n\r\ncwnd = cwnd * beta_cubic = 70\t          // window reduction\r\nW_cubic(0) = W_max * beta_cubic = 59.5\r\n```\r\n\r\nIf we were to enter congestion avoidance at this point, with a small enough RTT, the candidate target congestion window as calculated by W_cubic(t+RTT) may be less than the current congestion window (~59.5 < 70). \r\n\r\nThe suggestion in the thread from Lisong Xu and Vidhi Goel is to change Equation 2 to:\r\n```\r\nK = cubic_root((W_max - cwnd)/C) (Eq. 2)\r\n```\r\nwhere cwnd is the congestion window size at the beginning of the current congestion avoidance. This will ensure the target is greater than the current congestion window, and in my opinion is a more clear representation of what K represents.",
      "createdAt": "2020-11-13T23:36:02Z",
      "updatedAt": "2020-11-24T09:04:13Z",
      "closedAt": "2020-11-24T09:04:13Z",
      "comments": [
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, we can change Equation 2 in the RFC to the following equation where cwnd is the cwnd at the beginning of the current congestion avoidance stage. \r\n\r\n`\r\nK = cubic_root((W_max - cwnd)/C)  (Eq. 2)\r\n`\r\n\r\nTo be exactly consistent with the Linux Cubic implementation, we can change Equation 2 to the following statement, where cwnd is still the cwnd at the beginning of the current congestion avoidance stage. \r\n\r\n`\r\nif (cwnd < W_max)\r\n  K = cubic_root((W_max - cwnd)/C)  \r\nelse{\r\n  K = 0  \r\n  W_max = cwnd\r\n}\r\n\r\n`\r\n\r\nThank you!\r\n",
          "createdAt": "2020-11-14T22:14:57Z",
          "updatedAt": "2020-11-14T22:14:57Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@lisongxu thanks for confirming that Linux is doing something very similar! We should poll other implementors to see if they are already doing this, or would start to if we were to make this change.\n\n@goelvidhi could you update the PR accordingly?",
          "createdAt": "2020-11-15T08:24:09Z",
          "updatedAt": "2020-11-15T08:24:09Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@lisongxu, in the below equation, setting W_max = cwnd seems superfluous. Also, next time we want to compute K, it will enter the first condition and end up with K = 0.\r\n```\r\nif (cwnd < W_max)\r\nK = cubic_root((W_max - cwnd)/C)\r\nelse{\r\nK = 0\r\nW_max = cwnd\r\n}",
          "createdAt": "2020-11-16T07:12:36Z",
          "updatedAt": "2020-11-16T07:12:52Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "@lisongxu We may remove W_max = cwnd under the else {} since this is about how we compute K? Sections on convex and concave regions already explained what happens when cwnd is greater than equal to Wmax.",
          "createdAt": "2020-11-17T04:23:18Z",
          "updatedAt": "2020-11-17T04:23:18Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "We calculate K only once at the beginning of a congestion avoidance stage.  \r\n\r\nStatement \"W_max = cwnd\" corresponds to line 249 of [https://github.com/torvalds/linux/blob/master/net/ipv4/tcp_cubic.c#L249](url).  Without this statement, the new cwnd calculated at t=0 using Equation (1) would be even lower than the current cwnd.\r\n`\r\nW_cubic(t) = C*(t-K)^3 + W_max (Eq. 1)\r\n`\r\n\r\nBut I agree that we should not change W_max, as W_max is also used by fast convergence. \r\n\r\nMaybe we should introduce a new variable origin_point as Linux does. \r\n\r\nAt the beginning of a congestion avoidance stage, we set the value of K and origin_point as follows\r\n\r\n```\r\nif (cwnd < W_max)\r\n{\r\n    K = cubic_root((W_max - cwnd)/C)\r\n    origin_point = W_max\r\n}\r\nelse\r\n{\r\n    K = 0\r\n    origin_point = cwnd\r\n}\r\n```\r\n\r\nDuring the congestion avoidance stage, we calculate cwnd as follows\r\n\r\n`\r\nW_cubic(t) = C*(t-K)^3 + origin_point (Eq. 1)\r\n`\r\n\r\n\r\n \r\n",
          "createdAt": "2020-11-17T05:09:24Z",
          "updatedAt": "2020-11-17T05:09:24Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree. Yes, without a new variable, it is hard. Now, it is closer to Linux implementation.",
          "createdAt": "2020-11-17T05:17:31Z",
          "updatedAt": "2020-11-17T05:17:31Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@lisongxu this is exactly what we do for Apple's CUBIC as well.\r\n\r\nI am open to adding `origin_point` if there is no objection about additional complexity.",
          "createdAt": "2020-11-17T06:27:57Z",
          "updatedAt": "2020-11-17T06:27:57Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "I'd say let's add it. @pravb is Windows is doing something similar?",
          "createdAt": "2020-11-17T06:29:42Z",
          "updatedAt": "2020-11-17T06:30:30Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "I want to add a clarification point to my previous comment about the below code. We do this only when we enter CA without any loss i.e. when cwnd > ssthresh.\r\n\r\n```\r\nif (cwnd < W_max)\r\n{\r\n    K = cubic_root((W_max - cwnd)/C)\r\n    origin_point = W_max\r\n}\r\nelse\r\n{\r\n    K = 0\r\n    origin_point = cwnd\r\n}\r\n```\r\n\r\nNote that at the beginning of CA, we should only do the below, as we want to start with W_max and not current value of cwnd. Also, as W_max will be greater than cwnd at the start of CA, the else condition doesn't apply.\r\n```\r\nK = cubic_root((W_max - cwnd)/C)\r\norigin_point = W_max\r\n```\r\n\r\nSo, I think we can leave Eq. 1 as is.",
          "createdAt": "2020-11-17T07:26:13Z",
          "updatedAt": "2020-11-17T07:26:13Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "There is another important difference between this RFC and Linux TCP in fast recovery. RFC assumes that cwnd is set to W_max * beta_cubic in fast recovery and remains as W_max * beta_cubic at the beginning of a congestion avoidance stage. However, the behavior of Linux TCP in/around fast recovery is complicated, such as adjusting cwnd based on the number of packets in flight, and adjusting cwnd in case of undo. As a result, at the beginning of a congestion avoidance stage, cwnd may or may not be W_max * beta_cubic, and sometimes may be even higher than W_max. \r\n\r\nI guess this RFC does not need to follow the fast recovery of Linux TCP, but it is safer to add that else condition. \r\n\r\nThanks",
          "createdAt": "2020-11-17T14:19:14Z",
          "updatedAt": "2020-11-17T14:19:14Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes,  @goelvidhi   you are right that we do this only when cwnd > ssthresh",
          "createdAt": "2020-11-17T14:20:07Z",
          "updatedAt": "2020-11-17T14:20:07Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "> @lisongxu this is exactly what we do for Apple's CUBIC as well.\r\n> \r\n> I am open to adding `origin_point` if there is no objection about additional complexity.\r\n\r\nThanks, @goelvidhi for confirming Apple's implementation!",
          "createdAt": "2020-11-17T15:19:21Z",
          "updatedAt": "2020-11-17T15:19:21Z"
        },
        {
          "author": "maolson-msft",
          "authorAssociation": "NONE",
          "body": "Rather than patching the K computation, why not set (after applying the fast convergence logic to W_max)\r\nCWnd = BETA * W_max\r\n\r\nrather than\r\nCWnd = BETA * CWnd\r\n\r\nwhen we reduce the window? I.e., wrap the fast-convergence reduction into both W_max and the CWnd. That seems more harmonious with the fast convergence algorithm, and at least for me, it's easier to reason about its effect.",
          "createdAt": "2020-11-17T19:49:38Z",
          "updatedAt": "2020-11-17T19:49:38Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@maolson-msft Yes, that is another possible design choice. The main reason to update the K equation is to revise the RFC to be consistent with the Linux cubic implementation and the original paper.  Thanks",
          "createdAt": "2020-11-18T02:13:37Z",
          "updatedAt": "2020-11-18T02:13:37Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@maolson-msft that would also require updating `ssthresh`, otherwise we will end up in slow start. I think the current approach is fine.",
          "createdAt": "2020-11-18T05:42:20Z",
          "updatedAt": "2020-11-18T05:42:20Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@lisongxu I updated the Eq. 2 with an else condition. Also, added some text for how cwnd can be set. Could you please review https://github.com/NTAP/rfc8312bis/pull/3?",
          "createdAt": "2020-11-18T06:17:47Z",
          "updatedAt": "2020-11-18T06:17:47Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "If we do not use variable origin_point, then it is possible that W_cubic(t) may be lower than the current cwnd.  In this case, I would suggest changing Equation (1) as follows, which also contains the bug fix. \r\n```\r\n    W_cubic(t) = C*(t-K)^3 + W_max\r\n    if (W_cubic(t) < cwnd)                      // lower bound\r\n        W_cubic(t)  =  cwnd\r\n    else if (W_cubic(t) > 2* cwnd)              // upper bound\r\n        W_cubic(t)  =  2 * cwnd\r\nwhere cwnd is the current congestion window size.\r\n```\r\n\r\nBelow is a slightly revised Equation (2)\r\n```\r\n   if (cwnd_0 < W_max) {\r\n        K = cubic_root(W_max - cwnd_0) / C             \r\n    } else {\r\n        K = 0\r\n    }\r\nwhere cwnd_0 is the congestion window at the beginning of a congestion avoidance stage, is calculated using beta_cubic in {{mult-dec}}, although implementations can further adjust the congestion window size based on other fast recovery mechanisms. We discuss how we set beta_cubic in {{mult-dec}} and how we set C in {{discussion}}.\r\n```\r\n",
          "createdAt": "2020-11-18T14:24:57Z",
          "updatedAt": "2020-11-18T14:24:57Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Why aren't we using origin_point?",
          "createdAt": "2020-11-18T14:36:28Z",
          "updatedAt": "2020-11-18T14:36:28Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "As we initially thought that the origin_point was needed only when cwnd > ssthresh without loss.\r\n\r\nBut @lisongxu mentioned, cwnd could become greater than W_max at the start of CA (after a congestion event). I want to understand in what case would it become greater. \r\n1. Using bytes in flight shouldn't set cwnd greater than W_max\r\n2. For any undo, W_max should also be undo'ed.\r\n\r\nAnything else?",
          "createdAt": "2020-11-18T23:32:39Z",
          "updatedAt": "2020-11-18T23:39:46Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> If we do not use variable origin_point, then it is possible that W_cubic(t) may be lower than the current cwnd. In this case, I would suggest changing Equation (1) as follows, which also contains the bug fix.\r\n> \r\n> ```\r\n>     W_cubic(t) = C*(t-K)^3 + W_max\r\n>     if (W_cubic(t) < cwnd)                      // lower bound\r\n>         W_cubic(t)  =  cwnd\r\n>     else if (W_cubic(t) > 2* cwnd)              // upper bound\r\n>         W_cubic(t)  =  2 * cwnd\r\n> where cwnd is the current congestion window size.\r\n> ```\r\n> \r\n> Below is a slightly revised Equation (2)\r\n> \r\n> ```\r\n>    if (cwnd_0 < W_max) {\r\n>         K = cubic_root(W_max - cwnd_0) / C             \r\n>     } else {\r\n>         K = 0\r\n>     }\r\n> where cwnd_0 is the congestion window at the beginning of a congestion avoidance stage, is calculated using beta_cubic in {{mult-dec}}, although implementations can further adjust the congestion window size based on other fast recovery mechanisms. We discuss how we set beta_cubic in {{mult-dec}} and how we set C in {{discussion}}.\r\n> ```\r\n\r\nIf I use cwnd_0 (which is beta_cubic * W_max) , then I don't need the else condition, right?",
          "createdAt": "2020-11-18T23:38:40Z",
          "updatedAt": "2020-11-18T23:39:07Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "How about revising Section 4.1 as follows?\r\n\r\nCUBIC uses the following window increase function:\r\n```\r\n       W_cubic(t) = C*(t-K)^3 + W_max (Eq. 1)\r\n```\r\n   where C is a constant fixed to determine the aggressiveness of window increase in high BDP networks and is discussed in Section 5, t is the elapsed time from the beginning of the current congestion avoidance stage, and K is the time period that the above function takes to increase the current window size to W_max if there are no further congestion events and is calculated using the following equation:\r\n```\r\n       K = cubic_root( (W_max-cwnd_0) /C)  (Eq. 2)\r\n```\r\n   where cwnd_0 is the congestion window at the beginning of the current congestion avoidance stage. In special cases, if cwnd_0 is greater than W_max, K is set to 0.\r\n\r\n   Upon receiving an ACK during congestion avoidance, CUBIC computes the target congestion window size after the next RTT as follows, where RTT is the weighted average RTT calculated by Standard TCP.\r\n```\r\n        target = W_Cubic(t + RTT)      // cwnd after a RTT\r\n        if (target < cwnd)             // lower bound\r\n            target = cwnd\r\n        else if (target > 2*cwnd)      // upper bound\r\n            target = 2 * cwnd\r\n```",
          "createdAt": "2020-11-19T01:55:59Z",
          "updatedAt": "2020-11-19T01:55:59Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "this looks good to me. I will update the PR with some minor text edits. ",
          "createdAt": "2020-11-19T02:24:47Z",
          "updatedAt": "2020-11-19T02:24:47Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thinking a bit more about it, I think cwnd_0 looks a bit confusing. Also, as we are adding text for special case (if cwnd > W_max),  and later to ensure target is within bounds, I think we should just call it `cwnd` and describe it as you did `where cwnd is the congestion window at the beginning of the current congestion avoidance stage`",
          "createdAt": "2020-11-19T02:35:26Z",
          "updatedAt": "2020-11-19T02:35:26Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@goelvidhi fine with me. Thanks.",
          "createdAt": "2020-11-19T02:42:45Z",
          "updatedAt": "2020-11-19T02:42:45Z"
        },
        {
          "author": "rscheff",
          "authorAssociation": "NONE",
          "body": "> We calculate K only once at the beginning of a congestion avoidance stage.\r\n\r\nWhile this is a correct statement, there are many more events that signify the beginning of the CA stage than just coming out from slow-start. In the cubic implementaiton in FreeBSD, the recalculation of K was missed in most of these instances (after idle, RTO rewind, loss recovery*, ecn recovery*). \r\n\r\nAs a note from an implementer, mentioning these other cases that signify the beginning of the congestion avoidance stage may avoid issues where someone only thinks of the textbook example when cwnd > ssthresh as the start of CA...\r\n\r\n\r\n(*) strictly speaking, K should be recalculated once the loss/ecn recovery has finished; FreeBSD takes a shortcut here and calculates K when entering recovery rather after leaving recovery.\r\n",
          "createdAt": "2020-11-19T11:02:53Z",
          "updatedAt": "2020-11-19T11:02:53Z"
        },
        {
          "author": "rscheff",
          "authorAssociation": "NONE",
          "body": "> Thinking a bit more about it, I think cwnd_0 looks a bit confusing. Also, as we are adding text for special case (if cwnd > W_max), and later to ensure target is within bounds, I think we should just call it `cwnd` and describe it as you did `where cwnd is the congestion window at the beginning of the current congestion avoidance stage`\r\n\r\nActually, reading \"cwnd\" in the formula by itself is more confusing to me, than referecing this by any other name; cwnd is the \"current\" cwnd on a casual glance; if it is NOT the current cwnd, but some state which has to be kept, use a differnt variable name in the formulas to make this clear (cwnd_0 or cwnd_base would be fine by me).",
          "createdAt": "2020-11-19T11:05:20Z",
          "updatedAt": "2020-11-19T11:05:20Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> (*) strictly speaking, K should be recalculated once the loss/ecn recovery has finished; FreeBSD takes a shortcut here and calculates K when entering recovery rather after leaving recovery.\r\n\r\nI don't think there is any mention of K being calculated only when cwnd > ssthresh. K is always recalculated whenever there is a congestion event.\r\n\r\n\r\n\r\n> Actually, reading \"cwnd\" in the formula by itself is more confusing to me, than referecing this by any other name; cwnd is the \"current\" cwnd on a casual glance; if it is NOT the current cwnd, but some state which has to be kept, use a differnt variable name in the formulas to make this clear (cwnd_0 or cwnd_base would be fine by me).\r\n\r\n'cwnd' is current congestion window in that formula. As @lisongxu noted, `In special cases, if cwnd is greater than W_max, K is set to 0.`, this additional statement will clarify what one needs to do if it is greater than W_max.",
          "createdAt": "2020-11-20T02:34:11Z",
          "updatedAt": "2020-11-20T02:34:11Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "@goelvidhi @rscheff  Using 'cwnd' looks okay to me, and an implementer can use any variable of her choice to reference or store this value, e.g., 'origin_point' or 'cwnd_0.' Thanks!",
          "createdAt": "2020-11-20T08:48:40Z",
          "updatedAt": "2020-11-20T08:48:40Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @sangtaeha. Could you please review https://github.com/NTAP/rfc8312bis/pull/3? Thanks.",
          "createdAt": "2020-11-20T08:59:35Z",
          "updatedAt": "2020-11-20T08:59:35Z"
        },
        {
          "author": "rscheff",
          "authorAssociation": "NONE",
          "body": "Sorry, I probably have missed something - K is recalculated at the beginning of a congestion avoidance phase, with the then-current cwnd. What would be the reason to store that value for later use (or why was it referred to as 'cwnd_0' or 'origin_point'? What uses are for that cwnd in the past in some implementations. (Still suffering from virtual jetlag, sorry).",
          "createdAt": "2020-11-20T11:18:00Z",
          "updatedAt": "2020-11-20T11:18:00Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@rscheff Thank you. In normal cases, we do not need to store that value (cwnd_0, or origin_point) for later use. ",
          "createdAt": "2020-11-20T14:55:01Z",
          "updatedAt": "2020-11-20T14:55:01Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "MDU6SXNzdWU3NDI5MzYxODU=",
      "title": "Congestion window TCP friendly region after W_max",
      "url": "https://github.com/NTAP/rfc8312bis/issues/2",
      "state": "CLOSED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [
        "design"
      ],
      "body": "The idea of using alpha_aimd as defined below is to ensure that the congestion window growth for Cubic is similar to standard TCP as Cubic's reduction factor (0.3) is smaller than that of standard TCP (0.5)\r\n\r\nCurrently, alpha_aimd = 3*(1-beta_cubic)/(1+beta_cubic) // for the entire TCP friendly region\r\n\r\nBut we think that once the cwnd in TF region reaches W_max, we should set the alpha_aimd to 1 to have similar behavior as standard TCP congestion algorithm (eg. NewReno)\r\n\r\nif (W_est < W_max)\r\n\talpha_aimd = 3*(1-beta_cubic)/(1+beta_cubic)\r\nelse\r\n\talpha_aimd = 1\r\n\r\nI'd be happy to work on a PR for this if folks think that this would be a good addition.",
      "createdAt": "2020-11-14T06:01:03Z",
      "updatedAt": "2020-12-01T07:17:58Z",
      "closedAt": "2020-12-01T07:17:58Z",
      "comments": [
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you, you are right that once cwnd reaches W_max, we should set alpha_aimd (or the delta variable in Linux) to 1 to make sure that CUBIC has at least the same throughput as the standard TCP. \r\n\r\nBut if the purpose of this RFC is to document the current Linux CUBIC implementation, then we do not need to change it. ",
          "createdAt": "2020-11-14T22:29:47Z",
          "updatedAt": "2020-11-16T07:24:18Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@lisongxu Is this a change that should be committed to Linux?\n\nWe should also poll other implementations if they are doing something similar to what is proposed already, or would start doing so if we made the change.",
          "createdAt": "2020-11-15T08:25:37Z",
          "updatedAt": "2020-11-15T08:25:37Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Correct me if I am wrong, but I think the purpose of an RFC should be to document what would be the right behavior for the algorithm instead of what a particular implementation is doing. Having said that, as Linux is widely used OS, I think it would be good to commit this to Linux if we agree that this is a required change.\r\n\r\n@larseggert what is the best way to start a poll for other implementations? A slack channel?\r\n\r\n",
          "createdAt": "2020-11-16T07:17:44Z",
          "updatedAt": "2020-11-16T07:17:54Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@goelvidhi RFC8312 was specifically written because there was no accurate CUBIC specification at the time other than the Linux source code (the paper algorithm was outdated.) I think we should try and stick to this for the revision, i.e., document the CUBIC variant that is used in production now, in Linux and other stacks.\r\n\r\nThat said, *if* there are modifications that we want to propose that would further improve CUBIC beyond what current implementations are doing, that is possible. But I'd like to then see if Linux and other stacks would be open to implementing these improvements -- I wouldn't want to end up with a CUBIC spec that is (again) divergent from what the main stacks do (in some aspects).\r\n\r\nAs for how to ask, I think an email to the TCPM WG mailing list with a pointer to the respective GitHub issue/PR works best.",
          "createdAt": "2020-11-16T07:24:03Z",
          "updatedAt": "2020-11-16T07:24:03Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "I am not sure, but I guess this change has little impact on the cubic performance, especially in highspeed networks.  Thanks",
          "createdAt": "2020-11-17T02:28:51Z",
          "updatedAt": "2020-11-17T02:28:51Z"
        },
        {
          "author": "maolson-msft",
          "authorAssociation": "NONE",
          "body": "I can speak for Windows TCP and MsQuic, and this proposal isn't done in either today.\r\n\r\nIf you just change the slope but not the base of the linear function, then I think you'll see a jump discontinuity in the window. That's a problem for Windows TCP because we don't pace by default. To avoid the jump discontinuity, you could rebase the linear function:\r\n\r\ninstead of the proposed\r\nW_est(t) = W_max*BETA + t/RTT\r\n[where t = time in congestion avoidance],\r\n\r\nyou could do\r\nW_est(t) = W_max + t/RTT\r\n[where t = time since W_est hit W_max].\r\n\r\nSomething like that. But of course, if this isn't going to substantially affect perf in real scenarios, I'd rather not risk the bugs from making this change.",
          "createdAt": "2020-11-17T19:28:23Z",
          "updatedAt": "2020-11-17T21:06:05Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@maolson-msft \r\nThe W_est equation is\r\nW_est(t)= W_max*beta_cubic +\r\n                   [3*(1-beta_cubic)/(1+beta_cubic)] * (t/RTT)\r\n\r\nwhere alpha_aimd = 3*(1-beta_cubic)/(1+beta_cubic)\r\n\r\nAnd the suggestion is to set alpha_aimd to 1 after W_est hit W_max for parity with New Reno.\r\n\r\n",
          "createdAt": "2020-11-18T09:37:51Z",
          "updatedAt": "2020-11-18T09:37:51Z"
        },
        {
          "author": "maolson-msft",
          "authorAssociation": "NONE",
          "body": "@goelvidhi , setting alpha to 1 reduces the RFC's current equation to W_est(t) = W_max*BETA + t/RTT, which is the equation I wrote. Sorry if that was unclear.",
          "createdAt": "2020-11-18T21:32:26Z",
          "updatedAt": "2020-11-18T21:32:26Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm, I see your point.\r\nI use bytes_acked/cwnd instead of time t/RTT, so don't have the problem as you described. I need to think more about this issue.",
          "createdAt": "2020-11-19T00:11:23Z",
          "updatedAt": "2020-11-19T00:11:23Z"
        },
        {
          "author": "maolson-msft",
          "authorAssociation": "NONE",
          "body": "@goelvidhi , I agree that issue #20 (replacing the equation-based window to an ACK-clocked one), if accepted, will resolve this jump discontinuity problem.",
          "createdAt": "2020-11-19T21:17:01Z",
          "updatedAt": "2020-11-19T21:17:01Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "NONE",
          "body": "Yuchung Cheng ( @yuchungcheng ) and I chatted about this proposed fix above ( https://github.com/NTAP/rfc8312bis/issues/2#issue-742936185 ) and we agreed this looks like a nice and worthwhile fix, which we should be able to integrate\r\ninto the Linux TCP CUBIC implementation.\r\n\r\nThis should address the concern mentioned above from Lars about potential drift between Linux TCP CUBIC and the RFC ( https://github.com/NTAP/rfc8312bis/issues/2#issuecomment-727789321 ).\r\n",
          "createdAt": "2020-11-20T16:29:09Z",
          "updatedAt": "2020-11-20T16:31:33Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Would someone volunteer to craft a PR for this?",
          "createdAt": "2020-11-25T09:44:46Z",
          "updatedAt": "2020-11-25T09:44:46Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "I can work on this one",
          "createdAt": "2020-11-25T10:20:14Z",
          "updatedAt": "2020-11-25T10:20:14Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWU3NDM2NzEyMjU=",
      "title": "Code to re-generate tables",
      "url": "https://github.com/NTAP/rfc8312bis/issues/4",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "larseggert"
      ],
      "labels": [
        "editorial"
      ],
      "body": "Does anyone have code to (re-)generate Tables 1, 2 and 3 for when we make changes to the math?",
      "createdAt": "2020-11-16T09:26:30Z",
      "updatedAt": "2020-11-18T08:08:36Z",
      "closedAt": "2020-11-18T08:08:36Z",
      "comments": [
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "I do have the code.  But we do not need to change these tables for the changes that we have discussed so far.  Thanks",
          "createdAt": "2020-11-17T02:36:27Z",
          "updatedAt": "2020-11-17T02:36:27Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Do you think it might be a good idea to add that code to the repo anyway, so we have it handy in the future?",
          "createdAt": "2020-11-17T05:02:03Z",
          "updatedAt": "2020-11-17T05:02:03Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure, here is the code to generate the cubic columns in tables 1 and 2. \r\n\r\n```\r\n#include<stdio.h>\r\n#include<math.h>\r\n\r\ndouble ww(double C, double RTT, double p){\r\n\tdouble w, tcp;\r\n\tw = pow(RTT, 0.75);\r\n\tw = w / pow(p, 0.75);\r\n\tw = w * pow(C*3.7/1.2, 0.25);\r\n\r\n\ttcp = 1.2*pow(1.0/p, 0.5);\r\n\r\n\tif (tcp>w)\r\n\t\treturn (int)(tcp+0.5);\r\n\telse\r\n\t\treturn (int)(w+0.5);\r\n}\r\n\r\nint main(){\r\n\tdouble p;\r\n\tint i;\r\n\r\n\tfor(i=2;i<=8;i++){\r\n\t\tp = pow(10, -i);\r\n\t\tprintf(\"%g\\t\", p);\r\n\t\tprintf(\"||%g\\t%g\\t%g\\t||\", ww(0.04, 0.1, p), ww(0.4, 0.1, p), ww(4, 0.1, p));\r\n\t\tprintf(\"%g\\t%g\\t%g\\t\\n\", ww(0.04, 0.01, p), ww(0.4, 0.01, p), ww(4, 0.01, p));\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n```",
          "createdAt": "2020-11-17T05:12:14Z",
          "updatedAt": "2020-11-17T05:12:14Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2020-11-17T05:14:33Z",
          "updatedAt": "2020-11-17T05:14:33Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@lisongxu the code seems to not compute the TCP and HSTCP columns?",
          "createdAt": "2020-11-17T14:31:23Z",
          "updatedAt": "2020-11-17T14:31:23Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "I made some changes to the code to print out all the columns of Tables 1 and 2.\r\n\r\n```\r\n#include<stdio.h>\r\n#include<math.h>\r\n\r\nlong reno(double p){\r\n    return round(1.2/pow(p, 0.5));\r\n}\r\n\r\n\r\nlong hstcp(double p){\r\n    long cwnd, tcp_friend;\r\n\r\n    cwnd = round(0.12/pow(p, 0.835));\r\n    \r\n    tcp_friend = reno(p);\r\n\r\n    if (tcp_friend > cwnd)\r\n        return tcp_friend;\r\n    else\r\n        return cwnd;\r\n}\r\n\r\nlong cubic(double C, double RTT, double p){\r\n    double w;\r\n    long cwnd, tcp_friend;\r\n    \r\n    w = pow(RTT, 0.75);\r\n    w = w / pow(p, 0.75);\r\n    w = w * pow(C*3.7/1.2, 0.25);\r\n    cwnd = round(w);\r\n\r\n    tcp_friend = reno(p);\r\n\r\n    if (tcp_friend > cwnd)\r\n        return tcp_friend;\r\n    else\r\n        return cwnd;\r\n}\r\n\r\nint main(){\r\n    double p;\r\n    int i;\r\n\r\n\r\n    printf(\"Table 1\\n\");\r\n    printf(\"%s\\t%s\\t%s\\t%s\\t%s\\t%s\\n\", \"P\", \"TCP\", \"HSTCP\", \"C=0.04\", \"C=0.4\", \"C=4\");\r\n    for(i=2;i<=8;i++){\r\n    p = pow(10, -i);\r\n        printf(\"%.1e\\t\", p);\r\n        printf(\"%ld\\t%ld\\t%ld\\t%ld\\t%ld\\n\", reno(p), hstcp(p), cubic(0.04, 0.1, p), cubic(0.4, 0.1, p), cubic(4, 0.1, p));\r\n    }\r\n\r\n\r\n    printf(\"Table 2\\n\");\r\n    printf(\"%s\\t%s\\t%s\\t%s\\t%s\\t%s\\n\", \"P\", \"TCP\", \"HSTCP\", \"C=0.04\", \"C=0.4\", \"C=4\");\r\n    for(i=2;i<=8;i++){\r\n        p = pow(10, -i);\r\n        printf(\"%.1e\\t\", p);\r\n        printf(\"%ld\\t%ld\\t%ld\\t%ld\\t%ld\\n\", reno(p), hstcp(p), cubic(0.04, 0.01, p), cubic(0.4, 0.01, p), cubic(4, 0.01, p));\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n```",
          "createdAt": "2020-11-17T15:14:50Z",
          "updatedAt": "2020-11-17T15:14:50Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Thanks! I will update the PR tomorrow.",
          "createdAt": "2020-11-17T15:29:37Z",
          "updatedAt": "2020-11-17T15:29:37Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU3NDM3MzU3ODc=",
      "title": "List of variables and constants",
      "url": "https://github.com/NTAP/rfc8312bis/issues/5",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [
        "editorial"
      ],
      "body": "It would be useful to add a consolidated list of all constants and variables with their units and a brief description.",
      "createdAt": "2020-11-16T10:54:14Z",
      "updatedAt": "2020-11-19T17:02:45Z",
      "closedAt": "2020-11-19T17:02:45Z",
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "I can help with this",
          "createdAt": "2020-11-17T02:16:42Z",
          "updatedAt": "2020-11-17T02:16:42Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you, Vidhi!\r\n",
          "createdAt": "2020-11-17T02:37:54Z",
          "updatedAt": "2020-11-17T02:37:54Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@lisongxu  @sangtaeha could you please review https://github.com/NTAP/rfc8312bis/pull/12?",
          "createdAt": "2020-11-19T02:25:58Z",
          "updatedAt": "2020-11-19T02:25:58Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": " the unit of C should be MSS / S^3 ? Thanks",
          "createdAt": "2020-11-19T02:41:20Z",
          "updatedAt": "2020-11-19T02:41:20Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Is Segment / S^3 ok? (as I am calling the units of cwnd, W_max as segments)",
          "createdAt": "2020-11-19T02:57:05Z",
          "updatedAt": "2020-11-19T02:57:05Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, thanks. ",
          "createdAt": "2020-11-19T03:05:03Z",
          "updatedAt": "2020-11-19T03:05:03Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "done. please review.",
          "createdAt": "2020-11-19T03:07:22Z",
          "updatedAt": "2020-11-19T03:07:22Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWU3NDM3NDA5ODE=",
      "title": "Units are missing or unclear",
      "url": "https://github.com/NTAP/rfc8312bis/issues/6",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [
        "editorial"
      ],
      "body": "@martinthomson raised this on the QUIC slack:\r\n> What are the units of C?  What are the units of t? (edited) \r\nI'm assuming that the units of W_cubic(t) and W_max are bytes (or multiples of MSS, I guess).  But what about W_est(t)?\r\nW_est(t) = W_max*0.7 + 1.1 * t / RTT\r\n(Numbers approximated.)  That's a component in bytes, and a unit-less component. ",
      "createdAt": "2020-11-16T11:01:44Z",
      "updatedAt": "2020-11-19T17:02:45Z",
      "closedAt": "2020-11-19T17:02:45Z",
      "comments": [
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Copied from the beginning of Section 4: \"The unit of all window sizes in this document is segments of the  maximum segment size (MSS), and the unit of all times is seconds.\"  ",
          "createdAt": "2020-11-17T02:40:37Z",
          "updatedAt": "2020-11-17T02:40:37Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "So all variables either window sizes or times?",
          "createdAt": "2020-11-17T04:52:22Z",
          "updatedAt": "2020-11-17T04:52:52Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "If I did my math correctly ... \r\n\r\nUnit of C : MSS / (Second^3)\r\nUnit of K : Second\r\n\r\n",
          "createdAt": "2020-11-17T05:20:13Z",
          "updatedAt": "2020-11-17T05:20:13Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think,\r\nC is 1/ S^3 \r\nt is time in sec\r\nK is time in sec\r\nAll Ws are in packets. (W_est is also in packets and packets don't have any units)",
          "createdAt": "2020-11-17T05:29:46Z",
          "updatedAt": "2020-11-17T05:29:46Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "What would be the best place to add these units? Next to the equation or the section where all variables would be described? (ref. https://github.com/NTAP/rfc8312bis/issues/5)",
          "createdAt": "2020-11-17T05:31:48Z",
          "updatedAt": "2020-11-17T05:31:48Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "@goelvidhi Where we explain C, t, K, Wmax, etc.? ",
          "createdAt": "2020-11-17T06:06:20Z",
          "updatedAt": "2020-11-17T06:06:20Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "that should be fine too. But there was an issue #5 to define the variables with units. I was thinking to put it all at one place and then remove redundant explanations.",
          "createdAt": "2020-11-17T06:30:11Z",
          "updatedAt": "2020-11-17T06:30:36Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@goelvidhi I think consolidating it as you suggest (e.g., into a table) is probably best.",
          "createdAt": "2020-11-17T06:31:21Z",
          "updatedAt": "2020-11-17T06:31:21Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@goelvidhi The unit of all windows should be MSS (or segment), and then the unit of C should be MSS / S^3 ? Thanks",
          "createdAt": "2020-11-17T14:04:17Z",
          "updatedAt": "2020-11-17T14:04:17Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWU3NDM3NDIyNDU=",
      "title": "cwnd can now be less than 2",
      "url": "https://github.com/NTAP/rfc8312bis/issues/7",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [
        "design"
      ],
      "body": "@martinthomson raised this on the QUIC slack:\r\n```\r\n      W_max = cwnd;                 // save window size before reduction\r\n      ssthresh = cwnd * beta_cubic; // new slow-start threshold\r\n      ssthresh = max(ssthresh, 2);  // threshold is at least 2 MSS\r\n      cwnd = cwnd * beta_cubic;     // window reduction\r\n```\r\n>cwnd can now be less than 2.",
      "createdAt": "2020-11-16T11:03:25Z",
      "updatedAt": "2020-11-17T15:28:19Z",
      "closedAt": "2020-11-17T15:28:19Z",
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah.. for this code, a simple fix would be:\r\n```\r\nW_max = cwnd;                 // save window size before reduction\r\n      ssthresh = cwnd * beta_cubic; // new slow-start threshold\r\n      ssthresh = max(ssthresh, 2);  // threshold is at least 2 MSS\r\n      cwnd = ssthresh;                    // window reduction\r\n```\r\nI can work on this one, if no one else is.",
          "createdAt": "2020-11-17T02:18:36Z",
          "updatedAt": "2020-11-17T02:18:36Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, Linux also implements it this way. ",
          "createdAt": "2020-11-17T02:38:50Z",
          "updatedAt": "2020-11-17T02:38:50Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "MDU6SXNzdWU3NDQ0MTgyNTY=",
      "title": "Highlight difference to paper",
      "url": "https://github.com/NTAP/rfc8312bis/issues/10",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "NONE",
      "assignees": [
        "sangtaeha"
      ],
      "labels": [
        "editorial"
      ],
      "body": "Would be nice to highlight what has changed from the original paper as that paper is still a good source to start with and understand cubic.",
      "createdAt": "2020-11-17T05:15:38Z",
      "updatedAt": "2020-12-16T08:41:21Z",
      "closedAt": "2020-12-16T08:41:21Z",
      "comments": [
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "RFC 8312 was close to the original paper, and this version clarifies a few implementation details. This is more like we explain the difference between RFC 8312 and a new version. @larseggert and @lisongxu If you want to include this, I can help. We may have to use a separate section for this information? ",
          "createdAt": "2020-11-17T05:49:32Z",
          "updatedAt": "2020-11-17T05:49:32Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Yes, a separate section (or an appendix) makes sense. I think discussing both the changes from the paper to RFC8312 and from RFC8312 to this document (RFC8312bis) would make sense?",
          "createdAt": "2020-11-17T06:14:49Z",
          "updatedAt": "2020-11-17T06:14:49Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "Actually the main reason why I checked the paper is because it has the pseudo code. I also look at the linux implementation but that's much harder to understand, especially if your implementation doesn't need the same optimisations. Might be also worth discussing in an appendix. ",
          "createdAt": "2020-11-17T06:30:51Z",
          "updatedAt": "2020-11-17T06:30:51Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "@mirjak I agree.",
          "createdAt": "2020-11-17T06:32:22Z",
          "updatedAt": "2020-11-17T06:32:22Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @sangtaeha for helping with this section",
          "createdAt": "2020-11-17T15:15:42Z",
          "updatedAt": "2020-11-17T15:16:34Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@sangtaeha would you start a PR for this?",
          "createdAt": "2020-11-25T09:44:32Z",
          "updatedAt": "2020-11-25T09:44:32Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert Yes, let me get back to you on this.",
          "createdAt": "2020-11-25T20:26:32Z",
          "updatedAt": "2020-11-25T20:26:32Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "@mirjak @lisongxu @larseggert There are a few differences between the original paper and RFC8312. The major difference is the first bullet. The second bullet of each version might be trivial and can be removed. Any feedback on the following? After that, I will submit a PR.\r\n\r\n## RFC 8312\r\n\r\n- It changed the definition of beta_cubic constant and thus updated the pseudocode of CUBIC accordingly. For example, beta_cubic in the original paper was the window decrease constant while RFC8312 changed it to CUBIC multiplication decrease factor. With this change, the current congestion window size after a loss event is beta_cubic * W_max while it was (1-beta_cubic) * W_max in the original paper.\r\n- It included the discussion on safety features of CUBIC, such as CUBIC's fairness in small and high bandwidth-delay product (BDP) networks and the recommended CUBIC constant C.\r\n\r\n## Original paper\r\n\r\n- The original paper included the pseudocode of CUBIC implementation using Linux's pluggable congestion control framework, which excludes system-specific optimizations. The simplified pseudocode might be a good source to start with and understand CUBIC.\r\n- It also includes experimental results showing its performance and fairness.",
          "createdAt": "2020-12-01T09:21:10Z",
          "updatedAt": "2020-12-01T09:21:59Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @sangtaeha ",
          "createdAt": "2020-12-01T13:55:42Z",
          "updatedAt": "2020-12-01T13:55:42Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "There is one more difference: W_last_max in the paper and in the Linux code is called W_max in the RFC. Thanks",
          "createdAt": "2020-12-01T14:21:29Z",
          "updatedAt": "2020-12-01T14:21:29Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "Good point. I add that. Thanks, @lisongxu ",
          "createdAt": "2020-12-01T18:40:20Z",
          "updatedAt": "2020-12-01T18:40:20Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> There is one more difference: W_last_max in the paper and in the Linux code is called W_max in the RFC. Thanks\r\n\r\nI think the paper uses W_max in the text but only uses W_last_max in the code.\r\n\r\nOther differences that I see based on the recent changes to the IETF draft:\r\n1. K formula has changed in the RFC, to cbrt ((W_max - cwnd)/C) whereas in the paper it is cbrt((W_max * Beta)/C) where Beta = 1-cubic_beta\r\n2. TCP friendly window is called W_est in the RFC whereas it is W_tcp in the paper (subtle difference). Also, we added a note to change alpha_aimd to 1 when W_est > W_max\r\n3. Fast Convergence section - Although Section 3.7 describes the fast convergence using W_max and W_last_max (which is same as the RFC), the corresponding pseudocode in Algorithm 1 only uses W_last_max (as W_max) and it seems a bit incorrect. Not sure what we add regarding this.",
          "createdAt": "2020-12-01T20:11:44Z",
          "updatedAt": "2020-12-01T20:12:04Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @goelvidhi. Yes, we may have more changes as well. I will incorporate them into the list.",
          "createdAt": "2020-12-02T02:18:39Z",
          "updatedAt": "2020-12-02T02:18:39Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Should we also discuss the improvements taken from the NSDI paper, and cite that?",
          "createdAt": "2020-12-02T06:34:25Z",
          "updatedAt": "2020-12-02T06:34:25Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert Yes, we can include those in the list of changes since RFC 8312.",
          "createdAt": "2020-12-02T06:50:06Z",
          "updatedAt": "2020-12-02T06:50:06Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "@goelvidhi Yes, the Fast Convergence pseudocode was wrong while the explanation was correct. That was the issue of using w_max and w_last_max in different places. We may not add this issue but we should add the changes in the K formula and TCP friendly region which now emulates TCP throughput using segments or bytes received instead of time t.   ",
          "createdAt": "2020-12-02T06:55:42Z",
          "updatedAt": "2020-12-02T06:55:42Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good.",
          "createdAt": "2020-12-02T07:26:01Z",
          "updatedAt": "2020-12-02T07:26:01Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "MDU6SXNzdWU3NDQ0MzQ0MzQ=",
      "title": "Add details about response to ECN marks",
      "url": "https://github.com/NTAP/rfc8312bis/issues/11",
      "state": "CLOSED",
      "author": "mohittahiliani",
      "authorAssociation": "NONE",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [
        "editorial"
      ],
      "body": "It would be nice to describe how a CUBIC sender should respond to ECN marks from the receiver. On receiving an ECE mark, the Linux CUBIC enters a CWR state and follows PRR.\r\n\r\nMore details about this are available in the document:\r\nhttps://docs.google.com/document/d/1QiDqBo94wKr1eptTFe6xAB0RWWlwYOy8VLOWrpVAie8/edit",
      "createdAt": "2020-11-17T05:52:58Z",
      "updatedAt": "2020-12-04T08:41:15Z",
      "closedAt": "2020-12-04T08:41:15Z",
      "comments": [
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "@mohittahiliani In fact, CUBIC is not different from the other CCs (e.g., NewReno/SACK) in dealing with ECN marks (treating as a congestion event). Responding to ECN is always beneficial for loss-based algorithms. Yes, we can add that. ",
          "createdAt": "2020-11-17T16:54:56Z",
          "updatedAt": "2020-11-17T16:54:56Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "This was discussed during IETF 109 tcpm meeting. I think what @mohittahiliani was referring to was to document CWR and PRR as done in Linux on ECN which is probably not the same reaction as 3 dup ACKs.\r\n\r\nI am not sure if we want to document this behavior of Linux on ECN signaling.",
          "createdAt": "2020-11-18T07:44:48Z",
          "updatedAt": "2020-11-18T07:44:48Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "@goelvidhi @mohittahiliani If so, all standard loss-based TCP CCs in Linux will do the same for ECN. PRR is how Linux reduces its cwnd and different platforms could do differently. By the way, CUBIC treats ECN as a loss event and sets W_max upon receiving ECN-Echo, which may be enough?  The current draft already has the following.\r\n\r\n~~~\r\nAfter a window reduction in response to a congestion event is detected by \r\nduplicate ACKs or Explicit Congestion Notification-Echo (ECN-Echo) ACKs [RFC3168], \r\nCUBIC registers the congestion window size where it got the congestion event \r\nas W_max and performs a multiplicative decrease of congestion window.\r\n~~~",
          "createdAt": "2020-11-18T08:39:04Z",
          "updatedAt": "2020-11-18T08:44:21Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "I did point out this text to @mohittahiliani during the tcpm meeting.\r\nI agree that we don't have to document the CWR and PRR for CUBIC specifically.",
          "createdAt": "2020-11-18T09:32:32Z",
          "updatedAt": "2020-11-18T09:32:32Z"
        },
        {
          "author": "tomhenderson",
          "authorAssociation": "NONE",
          "body": "I might suggest that Section 4.5 on Multiplicative Decrease include an additional sentence \"For both loss and congestion events, the sender MAY employ a fast recovery algorithm to gradually adjust the congestion window to its new reduced value.\"  I believe that without this, implementers will assume that cwnd must be immediately reduced (also because PRR does not mention any applicability to ECN).\r\n\r\nThere is also an opportunity to add ECN support to PRR if that RFC is being revised.",
          "createdAt": "2020-11-18T15:16:45Z",
          "updatedAt": "2020-11-18T15:16:45Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @tomhenderson. We will add that.",
          "createdAt": "2020-11-18T19:37:05Z",
          "updatedAt": "2020-11-18T19:37:05Z"
        },
        {
          "author": "mohittahiliani",
          "authorAssociation": "NONE",
          "body": "Thank you all for the discussion!",
          "createdAt": "2020-11-21T19:46:12Z",
          "updatedAt": "2020-11-21T19:46:12Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Would someone volunteer to craft a PR for this?",
          "createdAt": "2020-11-25T09:44:00Z",
          "updatedAt": "2020-11-25T09:44:00Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "I can work on this one",
          "createdAt": "2020-11-25T10:23:26Z",
          "updatedAt": "2020-11-25T10:23:26Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "NONE",
          "body": "This is not the same thing, but it also fits the topic line: reference [KWAF17] in RFC 8312 is an I-D but it is now RFC 8511, and it's not cited for what it really is about in RFC 8312. RFC 8511 proposes that senders should back off less in response to a CE-mark (note, this is in the world of ECT(0) ) than to a packet loss, because the CE-mark not only indicates congestion - it also indicates the presence of an AQM algorithm, which probably keeps the queue relatively short.\r\n\r\nWe found this to be generally beneficial, some details here:  https://folk.universitetetioslo.no/michawe/research/publications/Networking2017ABE.pdf\r\nand recommend a value of 0.85 for cubic_beta in the RFC, for whoever wants to participate in this experiment.\r\n\r\nI'm not saying that Cubic should now change its backoff factor for good, but the experiment should probably be cited as such, and the reference updated - and if one of you implementers would like to try out a value greater than 0.8, such as 0.85 or 0.8, that would of course be extra cool!",
          "createdAt": "2020-12-02T18:16:41Z",
          "updatedAt": "2020-12-02T18:16:41Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@mwelzl The mention of [KWAF17] in Section 5.4 is to note the aggressiveness of CUBIC in fast networks leading to more queuing in the network. For the CUBIC draft, I think it would be best to provide a generic recommendation instead of pointing to specific RFCs for congestion window reduction during fast recovery.",
          "createdAt": "2020-12-03T09:29:21Z",
          "updatedAt": "2020-12-03T09:29:21Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWU3NDQ3OTk3NzM=",
      "title": "Overly aggressive window increase",
      "url": "https://github.com/NTAP/rfc8312bis/issues/14",
      "state": "CLOSED",
      "author": "lisongxu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [
        "design"
      ],
      "body": "Since we are revising this RFC, I guess it is a good time to fix some Cubic bugs reported in [our NSDI 2019 paper](https://www.usenix.org/conference/nsdi19/presentation/sun) .\r\n\r\nThis RFC sets W_cubic(t + RTT) as the target window size after in the next RTT. However, this targe size may be too high, like even higher than 2 * cwnd (i.e., more aggressive than slow start), in the following special cases.\r\n\r\n   * case 1: RTT is extremely long. An extremely long RTT is very likely an indication of network congestion, in such an environment it is dangerous to set a very high target. \r\n\r\n  * case 2: after a long idle period (i.e., a big increase of t). This is a [bug reported and fixed by Google](http://bitsup.blogspot.com/2015/09/).\r\n\r\n  * case 3: after a long application rate-limited period (i.e., a bug increase of t). Similar to case 2\r\n\r\nTo be safer, we may change Equation (1) as follow to fix all the above bugs\r\n\r\n```\r\n    W_cubic(t) = C*(t-K)^3 + origin_point (Eq. 1)\r\n    if (W_cubic (t) > 2* cwnd)\r\n        W_cubic(t)  =  2 * cwnd\r\n```\r\nNote that, Linux Cubic already does something similar ([line 328](https://github.com/torvalds/linux/blob/master/net/ipv4/tcp_cubic.c#L328)) by limiting target to be no more then 1.5 * cwnd.\r\n\r\nThanks",
      "createdAt": "2020-11-17T14:44:17Z",
      "updatedAt": "2020-11-24T09:11:15Z",
      "closedAt": "2020-11-24T09:11:15Z",
      "comments": [
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "@lisongxu Agreed. We also include this change in the list of changes for this new revision.",
          "createdAt": "2020-11-17T19:09:52Z",
          "updatedAt": "2020-11-17T19:09:52Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@lisongxu Below is my response for the three cases you mentioned,\r\n1. At least we use SRTT instead of RTT which mitigates the problem somewhat\r\n2. For any idle period, we reset the epoch period to 0.\r\n3. Same as 2.\r\n\r\nHaving said that, your suggestion is a safe option regardless.\r\n",
          "createdAt": "2020-11-18T06:47:15Z",
          "updatedAt": "2020-11-18T06:47:30Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert  I can do this change. Feel free to assign :-)",
          "createdAt": "2020-11-18T06:47:56Z",
          "updatedAt": "2020-11-18T06:47:56Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "What I proposed is a simple fix mainly for other implementations. For bug 2, Google already proposed a fix that has been implemented in [Linux](https://github.com/torvalds/linux/blob/master/net/ipv4/tcp_cubic.c#L151) and been adopted into the cubic RFC. (Section 5.8). Thanks ",
          "createdAt": "2020-11-18T14:28:34Z",
          "updatedAt": "2020-11-18T14:28:34Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Would good to give this issue a more descriptive title.",
          "createdAt": "2020-11-19T14:47:48Z",
          "updatedAt": "2020-11-19T14:47:48Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert done",
          "createdAt": "2020-11-19T19:31:35Z",
          "updatedAt": "2020-11-19T19:31:35Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@yuchungcheng  Case 2 is already fixed by Google in function [bictcp_cwnd_event](https://github.com/torvalds/linux/blob/master/net/ipv4/tcp_cubic.c#L149). How about case 3? Does bictcp_cwnd_event also fix case 3? Thanks",
          "createdAt": "2020-11-19T19:35:34Z",
          "updatedAt": "2020-11-19T19:35:34Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@lisongxu  The fix to bound the CUBIC target cwnd is added to https://github.com/NTAP/rfc8312bis/pull/3. Let me know if there is any remaining items for this issue.",
          "createdAt": "2020-11-20T04:17:28Z",
          "updatedAt": "2020-11-20T04:17:28Z"
        },
        {
          "author": "yuchungcheng",
          "authorAssociation": "NONE",
          "body": "I believe bictcp_cwnd_event does fix case 3, specifically on the comment of\n\" We were application limited (idle) for a while...\"\n\nThis commit message has more details:\ncommit 30927520dbae297182990bb21d08762bcc35ce1d\nAuthor: Eric Dumazet <edumazet@google.com>\nDate:   Wed Sep 9 21:55:07 2015 -0700\n\n    tcp_cubic: better follow cubic curve after idle period\n\n    Jana Iyengar found an interesting issue on CUBIC :\n\n    The epoch is only updated/reset initially and when experiencing losses.\n    The delta \"t\" of now - epoch_start can be arbitrary large after app idle\n    as well as the bic_target. Consequentially the slope (inverse of\n    ca->cnt) would be really large, and eventually ca->cnt would be\n    lower-bounded in the end to 2 to have delayed-ACK slow-start behavior.\n\n    This particularly shows up when slow_start_after_idle is disabled\n    as a dangerous cwnd inflation (1.5 x RTT) after few seconds of idle\n    time.\n\n    Jana initial fix was to reset epoch_start if app limited,\n    but Neal pointed out it would ask the CUBIC algorithm to recalculate the\n    curve so that we again start growing steeply upward from where cwnd is\n    now (as CUBIC does just after a loss). Ideally we'd want the cwnd growth\n    curve to be the same shape, just shifted later in time by the amount of\n    the idle period.\n\n    Reported-by: Jana Iyengar <jri@google.com>\n    Signed-off-by: Eric Dumazet <edumazet@google.com>\n    Signed-off-by: Yuchung Cheng <ycheng@google.com>\n    Signed-off-by: Neal Cardwell <ncardwell@google.com>\n    Cc: Stephen Hemminger <stephen@networkplumber.org>\n    Cc: Sangtae Ha <sangtae.ha@gmail.com>\n    Cc: Lawrence Brakmo <lawrence@brakmo.org>\n    Signed-off-by: David S. Miller <davem@davemloft.net>\n\nOn Thu, Nov 19, 2020 at 11:35 AM Lisong Xu <notifications@github.com> wrote:\n\n> @yuchungcheng <https://github.com/yuchungcheng> Case 2 is already fixed\n> by Google in function bictcp_cwnd_event\n> <https://github.com/torvalds/linux/blob/master/net/ipv4/tcp_cubic.c#L149>.\n> How about case 3? Does bictcp_cwnd_event also fix case 3? Thanks\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/NTAP/rfc8312bis/issues/14#issuecomment-730591804>, or\n> unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AM5EPYAUMQWLOANKGDO7DEDSQVXRJANCNFSM4TYVHEFQ>\n> .\n>\n",
          "createdAt": "2020-11-20T04:50:25Z",
          "updatedAt": "2020-11-20T04:50:25Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "> @lisongxu The fix to bound the CUBIC target cwnd is added to #3. Let me know if there is any remaining items for this issue.\r\n\r\nCould I ask that we do individual PRs to address individual issues? It sometimes causes a little rebasing effort, but it's much easier to review such PRs compared to ones that contain changes for multiple issues.",
          "createdAt": "2020-11-20T05:13:30Z",
          "updatedAt": "2020-11-20T05:13:30Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@yuchungcheng Thanks.\r\n\r\nThe reason that I am not sure about case 3 is that Cubic still sends out packets just at a low rate limited by application instead of cwnd. If Cubic remains in case 3 for a long time,  cwnd will not be increased for a long time but it is not idle. As a result, I guess bictcp_cwnd_event does not fix case 3, because bictcp_cwnd_event only detects the idle period? Am I missing something? Thanks",
          "createdAt": "2020-11-20T05:28:57Z",
          "updatedAt": "2020-11-20T05:28:57Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> > @lisongxu The fix to bound the CUBIC target cwnd is added to #3. Let me know if there is any remaining items for this issue.\r\n> \r\n> Could I ask that we do individual PRs to address individual issues? It sometimes causes a little rebasing effort, but it's much easier to review such PRs compared to ones that contain changes for multiple issues.\r\n\r\nSorry about that but the fix in #3 is incomplete without the bounds on target. Will try to keep them separate as much as possible.",
          "createdAt": "2020-11-20T07:18:47Z",
          "updatedAt": "2020-11-20T07:18:47Z"
        },
        {
          "author": "yuchungcheng",
          "authorAssociation": "NONE",
          "body": "@lisongxu <https://github.com/lisongxu>  I see your point now -- however it\ngets tricky what the right action is.\n\nFor example, let's cwnd is 100, and the application keeps using only 99\npkts for 5 minutes w/o experiencing any losses (so it's\n\"application-limited\"), then starts using cwnd fully 1 second after. should\nt = 5m or 1s? 1s seems over-conservative afterall cwnd was nearly fully\nused all time.\n\nAn obvious opposite example is the application using the minimal cwnd of 1\nfor a long time.\n\nMy sense is, for most application-limited traffic eventually go idle.\nAddressing the idle period may be good enough (if we want to keep it\nsimple).\n\nOn Thu, Nov 19, 2020 at 9:29 PM Lisong Xu <notifications@github.com> wrote:\n\n> @yuchungcheng <https://github.com/yuchungcheng> Thanks.\n>\n> The reason that I am not sure about case 3 is that Cubic still sends out\n> packets just at a low rate limited by application instead of cwnd. If Cubic\n> remains in case 3 for a long time, cwnd will not be increased for a long\n> time but it is not idle. As a result, I guess bictcp_cwnd_event does not\n> fix case 3, because bictcp_cwnd_event only detects the idle period? Am I\n> missing something? Thanks\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/NTAP/rfc8312bis/issues/14#issuecomment-730860015>, or\n> unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AM5EPYBPVJOSO3W35HWUL3LSQX5CNANCNFSM4TYVHEFQ>\n> .\n>\n",
          "createdAt": "2020-11-20T07:28:16Z",
          "updatedAt": "2020-11-20T07:28:16Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@yuchungcheng  Doesn't https://tools.ietf.org/html/rfc7661 solve the different app-limited scenarios?",
          "createdAt": "2020-11-20T08:51:16Z",
          "updatedAt": "2020-11-20T08:51:16Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@yuchungcheng Thank you! \r\n\r\nYes, we should avoid overly conservative (e.g., 1s in your example) and overly aggressive (e.g., 5m in your example). This is why I am suggesting a simple fix to set the lower bound (cwnd) and the upper bound (2*cwnd) to the target cwnd in the next RTT, and the detailed discussions can be found [in issue #1](https://github.com/NTAP/rfc8312bis/issues/1) . Thanks",
          "createdAt": "2020-11-20T14:46:32Z",
          "updatedAt": "2020-11-20T14:46:32Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@goelvidhi Thank you. That (rfc7661) requests a major change to Cubic, and I believe that the basic idea of rfc7661 is consistent with what we have been discussed (i.e., avoiding overly conservative and overly aggressive and being responsive to congestion). Thanks",
          "createdAt": "2020-11-20T14:50:27Z",
          "updatedAt": "2020-11-20T14:50:27Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "NONE",
          "body": "AFAICT the effect of the proposed fix in the first message in this thread -- https://github.com/NTAP/rfc8312bis/issues/14#issue-744799773 -- would be to bound the rate of increase of the cwnd to at most doubling each round trip time. Is that the intent?\r\n\r\nThe Linux TCP CUBIC implementation has already always bounded the rate of increase of the cwnd to at most 1.5x per round trip time. Initially it did this implicitly (the logic only allowed cwnd increases on at most every alternate ACK), and then when the stretch ACKs fixes were put in place the bound became explicit. See:\r\n  https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/tcp_cubic.c?id=d578e18ce93f5d33a7120fd57c453e22a4c0fc37\r\n\r\nGiven that separate pre-existing bound of 1.5x per round trip, AFAICT the proposed fix of bounding to less than 2x per round trip would be NOP, AFAICT? Or perhaps I misunderstand the proposal.\r\n\r\nBy the way, for YouTube we found this implicit bound of 1.5x per round trip was important for keeping losses at a reasonable level. This has a large impact on behavior, and presumably big implications for fairness between CUBIC implementations. So this may be important to document in the RFC, if it is not already (I couldn't find it, but I may have just missed it).\r\n",
          "createdAt": "2020-11-20T16:19:18Z",
          "updatedAt": "2020-11-20T16:22:03Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@nealcardwell Yes, you are right that Linux has already implemented the 1.5x upper bound. I am fine to change the upper bound from 2.0x to 1.5x. What is important is to add an upper bound to RFC to make sure that all other implementations also implement something similar. Thanks\r\n\r\n",
          "createdAt": "2020-11-20T16:28:34Z",
          "updatedAt": "2020-11-20T16:28:34Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed by https://github.com/NTAP/rfc8312bis/pull/3",
          "createdAt": "2020-11-24T09:11:15Z",
          "updatedAt": "2020-11-24T09:11:15Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWU3NDQ5MTQ3ODk=",
      "title": "Acknowledge previous authors/editors",
      "url": "https://github.com/NTAP/rfc8312bis/issues/15",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "larseggert"
      ],
      "labels": [
        "editorial"
      ],
      "body": "In the ack section.",
      "createdAt": "2020-11-17T17:00:00Z",
      "updatedAt": "2020-11-18T08:07:58Z",
      "closedAt": "2020-11-18T08:07:58Z",
      "comments": []
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWU3NDUzMTgwNzI=",
      "title": "Add Injong as co-author",
      "url": "https://github.com/NTAP/rfc8312bis/issues/16",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Welcome @injongrhee! Please prepare a pull request to add yourself to the authors' block and `CODEOWNERS`.",
      "createdAt": "2020-11-18T04:27:02Z",
      "updatedAt": "2020-12-17T07:33:04Z",
      "closedAt": "2020-12-17T07:12:45Z",
      "comments": [
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Merged, thanks! @Injongrhee could you please accept the invite to join the repo, so we can assign you reviews, etc.?",
          "createdAt": "2020-12-17T07:20:26Z",
          "updatedAt": "2020-12-17T07:20:26Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert, @Injongrhee could not find that invitation. Can you send an invite to him again?",
          "createdAt": "2020-12-17T07:31:14Z",
          "updatedAt": "2020-12-17T07:31:14Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Done. He should have gotten an email and see a notification in GitHub.",
          "createdAt": "2020-12-17T07:33:04Z",
          "updatedAt": "2020-12-17T07:33:04Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "MDU6SXNzdWU3NDU0MTUyMzg=",
      "title": "Add Vidhi as co-author",
      "url": "https://github.com/NTAP/rfc8312bis/issues/17",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [
        "editorial"
      ],
      "body": "@goelvidhi please prepare a pull request to add yourself to the authors' block and `CODEOWNERS`. Welcome aboard!",
      "createdAt": "2020-11-18T07:38:20Z",
      "updatedAt": "2020-12-02T16:24:58Z",
      "closedAt": "2020-12-02T16:24:58Z",
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you @larseggert and all other Authors.",
          "createdAt": "2020-11-18T07:52:45Z",
          "updatedAt": "2020-11-18T07:52:45Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you! @goelvidhi ",
          "createdAt": "2020-11-18T19:40:32Z",
          "updatedAt": "2020-11-18T19:40:32Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWU3NDU0NDYzMjY=",
      "title": "Replace modelled TCP Reno window approach with AIMD emulation",
      "url": "https://github.com/NTAP/rfc8312bis/issues/20",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [
        "design"
      ],
      "body": "Yuchung Cheng [wrote](https://mailarchive.ietf.org/arch/msg/tcpm/KUQtS5nnRA1TaBzF2M2tnmTryGQ):\r\n>I'd recommend replacing the modelled TCP Reno window approach in\r\nsection 4.2 with an AIMD emulation (Linux's approach).\r\n>\r\n>In our experience, TCP-friendly regions are the predominant mode of\r\n(Linux) Cubic for any regular Internet connection. IOW Cubic is often\r\n\"Reno\" unless the loss rate is abysmal. The modelled approach is based\r\non a simple bulk transfer where modern network applications are mostly\r\nstructured traffic (burst, idle, repeat). Under such traffic\r\nstructures the model has two issues:\r\n>\r\n>The model assumes cwnd overshoot causes losses that are repaired in\r\none round of fast recovery. In reality, the losses are often due to\r\nbursts to short messages, causing more rounds and even timeouts to\r\nrepair. So the overall loss rate \"p\" tends to be higher than the ideal\r\nmodel, causing the model to underestimate the window (hence runs in a\r\nmore conservative Reno). Instead Linux's approach is to simply emulate\r\nReno AIMD based on the number of packets per ACK. This also avoids\r\nsquare-root operation.",
      "createdAt": "2020-11-18T08:27:38Z",
      "updatedAt": "2020-11-24T12:02:50Z",
      "closedAt": "2020-11-24T12:02:50Z",
      "comments": [
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree, and this is reasonable, as CUBIC is based on time t but AIMD is not.  Thanks",
          "createdAt": "2020-11-18T19:40:05Z",
          "updatedAt": "2020-11-18T19:40:05Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "I am not sure what's the AI here - do we need to modify Eq. 3?",
          "createdAt": "2020-11-19T03:19:06Z",
          "updatedAt": "2020-11-19T03:19:06Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Eq 3 is fine. But we need to change Eq 4 to update W_est for each ACK, instead of using that t/RTT.\r\n\r\nThanks",
          "createdAt": "2020-11-19T03:48:48Z",
          "updatedAt": "2020-11-19T18:06:25Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "In my earlier comment, AI = Action Item.\r\n\r\nIn Apple's implementation, I use bytes_acked / cwnd per ACK received instead of t/RTT. That ensures once the entire congestion window is acknowledged, the increase is 1MSS. I didn't file an issue for this as I thought this is an implementation choice. Does the below look like it:\r\n```\r\nOn every ACK,\r\nW_est = W_max*beta_cubic +\r\n                   [3*(1-beta_cubic)/(1+beta_cubic)] * (bytes_acked/cwnd)\r\n```",
          "createdAt": "2020-11-19T03:55:46Z",
          "updatedAt": "2020-11-19T03:57:20Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "How about the following?\r\n\r\nAt the beginning of a congestion avoidance stage, \r\n```\r\n    W_est = cwnd\r\n```\r\n\r\nOn every ACK,\r\n```\r\n   W_est += [3*(1-beta_cubic)/(1+beta_cubic)] * (Segments_acked/cwnd)\r\n```\r\n\r\n\r\n\r\n",
          "createdAt": "2020-11-19T04:34:39Z",
          "updatedAt": "2020-11-19T04:34:39Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, that's how an implementation would do it.\r\n\r\nWith this proposal, I think https://github.com/NTAP/rfc8312bis/issues/2 would be good to address as well. I think when we use segments_acked/cwnd instead of t/RTT, the W_est growth after it reached W_max, should use alpha_aimd = 1.",
          "createdAt": "2020-11-19T05:50:44Z",
          "updatedAt": "2020-11-19T05:50:44Z"
        },
        {
          "author": "rscheff",
          "authorAssociation": "NONE",
          "body": "FYI: freebsd is following the rtt-based tcp-friendly approach. However, we are not particularly fond of this due to the interaction with app-limited/discontinous data availablilty. Changing this into a bytes_acked/cwnd approach, which removes the RTT during that region, sounds good.",
          "createdAt": "2020-11-19T11:28:15Z",
          "updatedAt": "2020-11-19T11:28:15Z"
        },
        {
          "author": "yuchungcheng",
          "authorAssociation": "NONE",
          "body": "I like Lisong's proposal to use Segments_acked or Rscheff's Bytes_acked. We have changed Linux Cubic several years ago to perform well under the prevalent ACK-thining/compression world (notably for cable and wireless networks). Sometimes we get one ACK for more than one hundred segments.\r\n\r\nhttps://www.spinics.net/lists/netdev/msg314082.html\r\n",
          "createdAt": "2020-11-19T17:47:37Z",
          "updatedAt": "2020-11-19T17:47:37Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @yuchungcheng . Could you please take a look at [issue 14](https://github.com/NTAP/rfc8312bis/issues/14) for a bug that Google fixed?",
          "createdAt": "2020-11-19T19:37:12Z",
          "updatedAt": "2020-11-19T19:37:12Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "MDU6SXNzdWU3NDY0NTg2NDk=",
      "title": "Clear definition of \"the beginning of the current congestion avoidance stage\"",
      "url": "https://github.com/NTAP/rfc8312bis/issues/21",
      "state": "CLOSED",
      "author": "rscheff",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "While improving the FreeBSD Cubic implementation, we found that there is ambiguity as to when to define \"the beginning of the current congestion avoidance stage\". However, for the classical design assumption for TCP with infinite data available to send, the minutae don't matter much.\r\n\r\nBut in a corner case, let us assume the send buffer allows the transmission of exactly ssthresh bytes. After that, the application stalls for some time (in multiples of the RTT) before making more data available to send...\r\n\r\nIn the original code, t(0) was set, once cwnd > ssthresh (before the application stall above). \r\n\r\nHowever, that can lead to excessive jumps, when cubic re-calculates cwnd the next time data is available for sending, as an excessive amount of time may have passed.\r\n\r\nWhen FreeBSD is doing now ([https://reviews.freebsd.org/D25746](D25746)) is to track properly, when the first time to recalculate cwnd is after having left ssthresh (or having been application limited, which is similar).\r\n\r\nWe have not looked closely how app-limited and request/response type flows are handled with cubic in Linux or other OS.\r\n\r\nA clear definition as to when to start taking the base t(0) for calculating t in the cubic formular may be good to have.",
      "createdAt": "2020-11-19T10:41:56Z",
      "updatedAt": "2020-11-19T14:47:23Z",
      "closedAt": "2020-11-19T14:47:22Z",
      "comments": [
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @rscheff . This is what we are discussing in \"[Some bugs to fix #14](https://github.com/NTAP/rfc8312bis/issues/14)\".\r\n\r\nWhat Linux does and what the current RFC 8312 specifies is \"Section 5.8: CUBIC does not raise its congestion window size if the flow is currently limited by the application instead of the congestion window.  In case of long periods when cwnd has not been updated due  to the application rate limit, such as idle periods, t in Eq. 1 MUST NOT include these periods; otherwise, W_cubic(t) might be very high after restarting from these periods.\"\r\n\r\n",
          "createdAt": "2020-11-19T14:08:14Z",
          "updatedAt": "2020-11-19T14:08:14Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Closing this, since the discussion is in #14 ",
          "createdAt": "2020-11-19T14:47:22Z",
          "updatedAt": "2020-11-19T14:47:22Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "MDU6SXNzdWU3NDc4MTk0MzM=",
      "title": "Add handling of spurious retransmissions",
      "url": "https://github.com/NTAP/rfc8312bis/issues/23",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [
        "design"
      ],
      "body": "I wrote up a blog last year describing [my experience implementing Cubic for QUIC](https://huitema.wordpress.com/2019/11/11/implementing-cubic-congestion-control-in-quic/). There were three points:\r\n\r\n1) Issues with the formula base \"Reno compatibility\", which is documented in issue #20 \r\n2) Sensitivity of Hystart to delay jitter, which is more an issue with Hystart than with Cubic\r\n3) Sensitivity to spurious repeats\r\n\r\nI think that third issue should be addressed in the revised RFC. The basic problem is that any detected packet loss causes the host to reduce the window and start a new epoch. In some environments we can see spurious loss detection, caused for example by delayed ACKs or out of order delivery. These spurious losses can be easily identified in QUIC, and with some extra work in TCP. It would be useful if the revised RFC has a section on handling spurious losses.\r\n\r\nThe handling that I did implement was simple: reset the epoch parameters to the value of the previous epoch, before the loss. Documenting at least that would be nice.\r\n\r\n",
      "createdAt": "2020-11-20T21:56:16Z",
      "updatedAt": "2020-12-14T07:12:07Z",
      "closedAt": "2020-12-14T07:12:07Z",
      "comments": [
        {
          "author": "nealcardwell",
          "authorAssociation": "NONE",
          "body": "Fixing this would be great, since spurious retransmissions (e.g. from reordering) are so common. FWIW, undoing cwnd reductions is not correctly implemented in Linux TCP CUBIC (only cwnd is reverted, not the epoch parameters), but @yuchungcheng has a patch for this that we should be able to incorporate into Linux.\r\n",
          "createdAt": "2020-11-20T22:17:58Z",
          "updatedAt": "2020-11-20T22:17:58Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a good suggestion. Hopefully, it will promote any future congestion controllers draft to include this scenario among others, i.e. aim for completeness.",
          "createdAt": "2020-11-21T00:06:21Z",
          "updatedAt": "2020-11-21T00:06:21Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you all, yes, I agree that this is a very good suggestion.  \r\n\r\nWhat are some common reasons for spurious retransmissions?   \r\n\r\n@nealcardwell you mentioned packet ordering, do you know why it is common (now)? because of more wireless/cellular networks?  \r\n\r\n@huitema you mentioned ACK compression in your blog (interesting to read!), could you please explain why ACK compression leads to spurious retransmissions? \r\n\r\nThank you!\r\n",
          "createdAt": "2020-11-21T03:40:22Z",
          "updatedAt": "2020-11-21T03:40:22Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "NONE",
          "body": "@lisongxu the RACK draft has one perspective on some reasons for reordering: https://tools.ietf.org/html/draft-ietf-tcpm-rack-13#section-2.2\r\n\r\n   3.  Packet reordering.  Link-layer protocols (e.g., 802.11 block\r\n       ACK), link bonding, or routers' internal load-balancing (e.g.,\r\n       ECMP) can deliver TCP segments out of order.  ...",
          "createdAt": "2020-11-21T03:54:55Z",
          "updatedAt": "2020-11-21T03:54:55Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "I observed that on some wireless connections (WiFi plus fixed LTE), one of the routers on path was bundling short packets together and only sending them when the bundle had attained a sufficient size. (QUIC ACK are short packets, but they are encrypted and the routers cannot tell them from other short packets.) In my case, the packet bundling process caused extra delays, and sometimes the timers were firing.\r\n\r\nAs for reordering, that's very common too. @nealcardwell has access to much better telemetry than I do, but one behavior I saw was routers putting short packets in front of the queue, before longer packets. That can confuse algorithms like RACK.",
          "createdAt": "2020-11-21T03:58:03Z",
          "updatedAt": "2020-11-21T03:58:03Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you, Neal and Christian!",
          "createdAt": "2020-11-21T06:08:04Z",
          "updatedAt": "2020-11-21T06:08:04Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Would someone volunteer to craft a PR for this?",
          "createdAt": "2020-11-25T09:43:36Z",
          "updatedAt": "2020-11-25T09:43:36Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "I can work on this",
          "createdAt": "2020-11-25T10:20:49Z",
          "updatedAt": "2020-11-25T10:20:49Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "NONE",
          "body": "I wonder how \"reset the epoch parameters to the value of the previous epoch, before the loss\" is different from \"only initialize the epoch parameters when a CA epoch begins *normally*, i.e. not after a spurious loss event\".\r\n\r\nIn the latter case, the fix could just be a matter of writing:  \"If the loss event preceding this CA epoch was not spurious: \"  in front of the text describing how some variables are initialised at the beginning of CA.",
          "createdAt": "2020-12-02T11:24:29Z",
          "updatedAt": "2020-12-02T11:24:29Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "NONE",
          "body": "IMHO it is important to do more than add the text \"If the loss event preceding this CA epoch was not spurious: \".\r\n\r\nThe CUBIC implementation will not know at the time of the loss event whether the loss recovery episode was spurious or not. So for the implementation these are necessarily two different events at different times:\r\n\r\n (a) loss event\r\n (b) subsequent discovery that the loss recovery episode was spurious\r\n\r\nIMHO it is important to document exactly how the algorithm handles both (a) and (b), since there is a specific set of algorithm variables that need to be saved in (a) and then restored in (b). (It would be easy for an implementation to forget to save/store one ore more of the variables.)\r\n",
          "createdAt": "2020-12-02T14:34:27Z",
          "updatedAt": "2020-12-02T14:34:27Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "NONE",
          "body": "Hm, so maybe \"saving\" and \"restoring\" is a kernel implementation specific requirement?\r\n\r\nI thought that the \"epoch parameters\" are things like the cwnd at the time of starting CA and the time when CA begins (to later calculate t), for example. These things can be set exactly when CA begins - and when it does, TCP can (in principle) know how it got there - via a regular termination of, e.g., FR, or via a spurious loss event \"undo\".",
          "createdAt": "2020-12-02T14:39:29Z",
          "updatedAt": "2020-12-02T14:39:29Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "NONE",
          "body": "It is not the case that TCP will always know when CA begins whether the preceding loss event was spurious or not. For example, DSACKs for spurious retransmits often arrive one round-trip *after* the loss recovery episode completes and the CA episode begins. So if the loss recovery episode is detected as spurious via DSACKs, then usually the sender does not know at the time CA starts that the loss recovery was spurious.\r\n\r\nSo the implementation needs to be prepared for the events (a) and (b) in my timeline above to be separate events at separate times.\r\n",
          "createdAt": "2020-12-02T15:02:54Z",
          "updatedAt": "2020-12-02T15:02:54Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "NONE",
          "body": "Ah, sure; I didn't think of that - DSACKs in particular are a good example, thanks.",
          "createdAt": "2020-12-02T16:06:43Z",
          "updatedAt": "2020-12-02T16:06:43Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@nealcardwell Thank you for your comments! We are working on a section for this issue and plan to refer to some possible methods (e.g., using DSACK) to determine whether a loss event was spurious or not. Are you aware of any related documents or RFCs? Thanks",
          "createdAt": "2020-12-09T14:23:14Z",
          "updatedAt": "2020-12-09T14:23:14Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "NONE",
          "body": "I'm not Neal, but still - AFAIK there are three well known methods, which are documented in RFCs: Eifel (RFCs 3522 / 4015, working very well but only if you have timestamps), F-RTO (RFC 5682), working very well and not needing anything extra from the receiver but limited to timeouts, and DSACK (RFC 3708), which is reliable when available, but late.\r\n\r\nVarious other methods are possible, depending on the transport... quite possibly something reliable could be done with QUIC. I once worked on doing it with the ECN nonce, which noone ever used anyway and which is now even obsolete  :-) https://folk.universitetetioslo.no/michawe/research/projects/spurious/index.html",
          "createdAt": "2020-12-09T14:32:41Z",
          "updatedAt": "2020-12-09T14:32:41Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @yuchungcheng , @nealcardwell  mentioned that you already have a patch to undo the cwnd reduction of Cubic in case of spurious loss events. In this case, do you think it is better to shift epoch_start as Cubic currently [does for application-limited cases](https://github.com/torvalds/linux/blob/master/net/ipv4/tcp_cubic.c#L149) (i.e., exclude the spurious-loss-related period from K)? Otherwise, Cubic would increase its cwnd too aggressively, especially if the fast recovery period is very long. Thanks",
          "createdAt": "2020-12-09T14:37:48Z",
          "updatedAt": "2020-12-09T14:37:48Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you so much, @mwelzl ! This is very helpful!",
          "createdAt": "2020-12-09T14:38:20Z",
          "updatedAt": "2020-12-09T14:38:20Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "NONE",
          "body": "Yes, thanks, @mwelzl. That's a nice summary of all the undo mechanisms I'm aware of (and all the undo mechanisms that I can think of in the Linux TCP stack).\r\n",
          "createdAt": "2020-12-09T15:01:19Z",
          "updatedAt": "2020-12-09T15:01:19Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "NONE",
          "body": "Re \"do you think it is better to shift epoch_start as Cubic currently does for application-limited cases\", I think it is much better to restore the epoch_start and related variables (epoch_start, last_max_cwnd, cwnd,...) to the values they had before the spurious loss recovery, so that the sender can quickly get back to the cwnd curve it would have had if there had not been a spurious loss recovery. And this is what the draft patch by @yuchungcheng did.\r\n",
          "createdAt": "2020-12-09T15:05:33Z",
          "updatedAt": "2020-12-09T15:05:33Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you, @nealcardwell ! Just to clarify, there are two possible different methods to restore Cubic, depending on whether we restore cwnd or epoch_start. Considering one example, where the original cwnd was 100 and the original epoch_start was 10 seconds just before the spurious loss.\r\n\r\n1) restore to the original cwnd just before the spurious loss.  For the above example, we restore cwnd back to 100 after detecting the spurious loss. But to do so, we need to shift epoch_start accordingly (i.e., plus the time period between when the spurious loss occurred and when it was detected).\r\n\r\n2) restore to the original epoch_start. For the above example, we restore epoch_start back to 10 seconds after detecting the spurious loss, but then the new cwnd calculated using the restored original epoch_start would be much higher than the original cwnd 100.  \r\n\r\nAmong these two methods, it seems that method 1 is safer. \r\n\r\nThanks",
          "createdAt": "2020-12-09T15:38:23Z",
          "updatedAt": "2020-12-09T15:38:23Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "About the \"other transports\": for QUIC, detection of spurious loss detection is very simple because all packets have monotonically increasing sequence numbers. Spurious loss detection happens as follow:\r\n\r\n1) At time t, packet number N is marked as lost by standard loss detection, triggering actions like scheduling retransmission of some of the frames carried by the packet and signalling of a packet loss event to the congestion controller.\r\n2) Later, at time t + dt, an acknowledgement is received for the same packet number N. At that point, a \"spurious loss detection\" event is sent to the congestion controller.\r\n\r\n",
          "createdAt": "2020-12-09T15:52:03Z",
          "updatedAt": "2020-12-09T15:52:03Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "For the correction of spurious losses, what I did in my implementation of QUIC was pretty much what @nealcardwell described: restore the epoch start and the associated variables. Only restoring the CWIN leaves the connection in a \"half-way\" state between erasing the spurious loss and suffering from it, and that's probably a bad idea.",
          "createdAt": "2020-12-09T15:58:54Z",
          "updatedAt": "2020-12-09T15:58:54Z"
        },
        {
          "author": "yuchungcheng",
          "authorAssociation": "NONE",
          "body": "Lisong -- my (drafted) patch does #1. diff attached (it was written a few\nyears ago so may not apply cleanly)\n\n\n\n\nOn Wed, Dec 9, 2020 at 7:38 AM Lisong Xu <notifications@github.com> wrote:\n\n> Thank you, @nealcardwell <https://github.com/nealcardwell> ! Just to\n> clarify, there are two possible different methods to restore Cubic,\n> depending on whether we restore cwnd or epoch_start. Considering one\n> example, where the original cwnd was 100 and the original epoch_start was\n> 10 seconds just before the spurious loss.\n>\n>    1.\n>\n>    restore to the original cwnd just before the spurious loss. For the\n>    above example, we restore cwnd back to 100 after detecting the spurious\n>    loss. But to do so, we need to shift epoch_start accordingly (i.e., plus\n>    the time period between when the spurious loss occurred and when it was\n>    detected).\n>    2.\n>\n>    restore to the original epoch_start. For the above example, we restore\n>    epoch_start back to 10 seconds after detecting the spurious loss, but then\n>    the new cwnd calculated using the restored original epoch_start would be\n>    much higher than the original cwnd 100.\n>\n> Among these two methods, it seems that method 1 is safer.\n>\n> Thanks\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/NTAP/rfc8312bis/issues/23#issuecomment-741853499>, or\n> unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AM5EPYB46BOXXSTT6PAJFM3ST6KYBANCNFSM4T5JQAGA>\n> .\n>\n",
          "createdAt": "2020-12-09T17:46:24Z",
          "updatedAt": "2020-12-09T17:46:24Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "NONE",
          "body": "@lisongxu, you mentioned: \"there are two possible different methods to restore Cubic, depending on whether we restore cwnd or epoch_start\". AFAICT it is better to restore both cwnd and epoch_start (to the values they had immediately before the spurious loss detection event). How does that sound?\r\n\r\nYou also mentioned: \"1. restore to the original cwnd just before the spurious loss. For the above example, we restore cwnd back to 100 after detecting the spurious loss. But to do so, we need to shift epoch_start accordingly (i.e., plus the time period between when the spurious loss occurred and when it was detected).\" In this case, why would we need to shift epoch_start? Why not restore epoch_start to the value it had before the spurious loss detection event?\r\n\r\nMy sense would be that the goal for handling spurious retransmissions should be that, as much as possible, the state of the CUBIC algorithm should be restored so that the behavior of the connection would be as if the spurious retransmissions never happened. This is what Reno does in Linux, and it seems to me that this should be doable for CUBIC as well.",
          "createdAt": "2020-12-09T22:46:35Z",
          "updatedAt": "2020-12-09T22:46:35Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you all for your comments!\r\n\r\n@yuchungcheng  Hi Yuchung, it seems that the diff attachment was blocked somewhere. Could you please directly email it to me at xu@unl.edu? Thank you!",
          "createdAt": "2020-12-10T04:18:33Z",
          "updatedAt": "2020-12-10T04:18:33Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@nealcardwell Hi Neal, I can see that my original description is not that clear. Below I try to describe the two methods using two figures.\r\n\r\nMethod 1: undo cwnd and shift epoch_start so that cwnd continues smoothly from the value it had before the spurious loss. \r\n![cubic](https://user-images.githubusercontent.com/10427041/101723253-86126500-3a71-11eb-84b8-f053775e69e1.jpg)\r\n\r\nMethod 2:  undo cwnd and undo epoch_start. In this case, there is a big jump from restored cwnd and the next RTT cwnd (calculated using restored epoch_start)\r\n![cubic2](https://user-images.githubusercontent.com/10427041/101723556-1e104e80-3a72-11eb-9118-cf040113ce78.jpg)\r\n\r\nBoth methods are ok, but method 1 is more conservative and thus possibly safer?\r\n\r\nThanks",
          "createdAt": "2020-12-10T05:03:22Z",
          "updatedAt": "2020-12-10T05:03:22Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @lisongxu for the graphical explanation. I agree with @nealcardwell that setting cwnd and epoch start to the value before the spurious loss event occurred would be good. Which means cwnd is set to 100 and epoch start to epoch_start and W_cubic(t) will likely look like what method 2 shows soon after as t would have progressed much further.\r\n\r\nOTOH method 1 is more conservative, and I don't understand how can a transport extrapolate the shifted epoch start? From your graph, if spurious loss occurred at X and spurious loss detection occurred at Y (at which point we update cwnd to 100), how does one calculate the time X` (between X and Y) for the shifted epoch start?",
          "createdAt": "2020-12-10T07:27:33Z",
          "updatedAt": "2020-12-10T08:35:48Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "NONE",
          "body": "Thanks @lisongxu for the very nice graphical explanation. I agree with @goelvidhi  and maintain that restoring both cwnd and epoch start to the value before the spurious loss event occurred would be the best approach.\r\n\r\nKeeping in mind the typical long time-scales over which the CUBIC curve evolves (for high-BDP connections for which the CUBIC curve is governing behavior, rather than the Reno emulation), and the quick 1-2 round-trip resolution of undo events, my sense is that a depiction that better conveys the sense of Method 2 (restoring both cwnd and epoch start ) would be something like:\r\n\r\n![image](https://user-images.githubusercontent.com/11696413/101785344-a3275200-3aca-11eb-941d-9ed7f71b7d55.png)\r\n",
          "createdAt": "2020-12-10T14:35:03Z",
          "updatedAt": "2020-12-10T14:35:03Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you all for the constructive discussions. Then let's choose method 2, which should be easier to implement than method 1. In addition, the revised RFC requires that the per-RTT cwnd increment is limited by that [1.5x upper bound](https://github.com/NTAP/rfc8312bis/issues/14), so method 2 should be fine even in special cases where undo happens many RTTs after a spurious loss event.",
          "createdAt": "2020-12-10T15:08:03Z",
          "updatedAt": "2020-12-10T15:08:03Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "MDU6SXNzdWU3NTQxNjQyNDg=",
      "title": "Initialization",
      "url": "https://github.com/NTAP/rfc8312bis/issues/28",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "NONE",
      "assignees": [
        "lisongxu"
      ],
      "labels": [
        "editorial"
      ],
      "body": "This is tiny and editorial:\r\n\r\nSection 4.7 of RFC 8312 talks about how values are initialized after an RTO; it seems obvious that these values would also be used at the very beginning, but this is never explicitly said. It seems obvious that, at this point, W_last_max should be set to W_max, but how to initialize W_last_max is also not explicitly said (unless I missed it).",
      "createdAt": "2020-12-01T08:19:58Z",
      "updatedAt": "2020-12-14T07:10:00Z",
      "closedAt": "2020-12-14T07:10:00Z",
      "comments": [
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @mwelzl. W_last_max should be initialized to 0.\r\n\r\nBy the way, there is a confusing difference between RFC and Linux code: RFC has two variables, W_last_max and W_max, whereas Linux code has only W_last_max that corresponds to W_max in RFC. This is confusing, so I would recommend removing W_last_max from the RFC, as it is used only in Section 4.6. \r\n\r\nHow about changing paragraphs 2, 3, 4 of Section 4.6 as follows?\r\n\r\n_With fast convergence, when a congestion event occurs, we update W_max as follows before the window reduction described in Section 4.5._\r\n\r\n```\r\n      if (cwnd < W_max){                        // should we make room for others\r\n          W_max = W_max*(1.0+beta_cubic)/2.0;   // further reduce W_max\r\n      } else {\r\n          W_max = cwnd                          // remember cwnd before reduction\r\n      }\r\n```\r\n\r\n_At a congestion event, if the current cwnd is less than W_max, this indicates that the saturation point experienced by this flow is getting reduced because of the change in available bandwidth.  Then we allow this flow to release more bandwidth by reducing W_max further.  This action effectively lengthens the time for this flow to increase its congestion window because the reduced W_max forces the flow to have the plateau earlier.  This allows more time for the new flow to catch up to its congestion window size._\r\n\r\nThen remove the following line from Section 4.5, because W_max is set in Section 4.6 now.\r\n\r\n```\r\nW_max = cwnd;                 // save window size before reduction\r\n```\r\n",
          "createdAt": "2020-12-01T14:20:34Z",
          "updatedAt": "2020-12-01T14:20:34Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "NONE",
          "body": "Oh yes, this is much better! Thanks!",
          "createdAt": "2020-12-01T14:25:46Z",
          "updatedAt": "2020-12-01T14:25:46Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> Thanks, @mwelzl. W_last_max should be initialized to 0.\r\n> \r\n> By the way, there is a confusing difference between RFC and Linux code: RFC has two variables, W_last_max and W_max, whereas Linux code has only W_last_max that corresponds to W_max in RFC. This is confusing, so I would recommend removing W_last_max from the RFC, as it is used only in Section 4.6.\r\n> \r\n> How about changing paragraphs 2, 3, 4 of Section 4.6 as follows?\r\n> \r\n> _With fast convergence, when a congestion event occurs, we update W_max as follows before the window reduction described in Section 4.5._\r\n> \r\n> ```\r\n>       if (cwnd < W_max){                        // should we make room for others\r\n>           W_max = W_max*(1.0+beta_cubic)/2.0;   // further reduce W_max\r\n>       } else {\r\n>           W_max = cwnd                          // remember cwnd before reduction\r\n>       }\r\n> ```\r\n\r\nThis looks good. One thing to note though, earlier we were saving W_last_max = W_max (before applying fast convergence) and now we won't have that state saved. Instead we would always compare with W_max after fast convergence is applied.\r\n",
          "createdAt": "2020-12-02T07:33:22Z",
          "updatedAt": "2020-12-02T07:33:22Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Anyone willing to create a PR for this one?",
          "createdAt": "2020-12-03T12:52:51Z",
          "updatedAt": "2020-12-03T12:52:51Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "I can help with this one. ",
          "createdAt": "2020-12-03T14:39:06Z",
          "updatedAt": "2020-12-03T14:39:06Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@lisongxu could you prepare a PR? we'd like to be able to submit a -01 version to the IETF soon and ask for adoption.",
          "createdAt": "2020-12-10T07:46:26Z",
          "updatedAt": "2020-12-10T07:46:26Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert done, thanks",
          "createdAt": "2020-12-10T16:22:09Z",
          "updatedAt": "2020-12-10T16:22:09Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "MDU6SXNzdWU3NzI1NDMyMzU=",
      "title": "\"TCP-Friendly\" is a bit misleading",
      "url": "https://github.com/NTAP/rfc8312bis/issues/38",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [
        "lisongxu"
      ],
      "labels": [],
      "body": "Given that a lot of TCP deployments use Cubic, I think that the intent here is to be friendly to Reno instead.  As the text establishes, it is AIMD(1, 0.5) that this wants to be sensitive to.\r\n\r\nIt might have made sense to talk about TCP when Cubic wasn't widely deployed, but now it is just confusing.",
      "createdAt": "2020-12-22T00:08:25Z",
      "updatedAt": "2021-02-19T09:24:47Z",
      "closedAt": "2021-02-19T09:24:47Z",
      "comments": [
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Agreed. We need to do a larger rewrite of much of the beginning of the document, which was historically correct but is now outdated, given that all stacks default to CUBIC.",
          "createdAt": "2020-12-22T06:57:07Z",
          "updatedAt": "2020-12-22T06:57:07Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "I can also help to revise the text later next week, is it ok? Thanks, Lars",
          "createdAt": "2021-02-03T06:04:09Z",
          "updatedAt": "2021-02-03T06:04:09Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "MDU6SXNzdWU3OTkxMjExNTE=",
      "title": "Change introductory text to reflect deployment experience",
      "url": "https://github.com/NTAP/rfc8312bis/issues/39",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "lisongxu"
      ],
      "labels": [
        "editorial"
      ],
      "body": "The abstract, introduction and other text throughout the document need to be updated to reflect the significantly broader deployment experience CUBIC has seen since RFC8312 was published. At that time, it had been the default for Linux for years, but since then, it's also been the default for Windows and Apple stacks.",
      "createdAt": "2021-02-02T09:54:14Z",
      "updatedAt": "2021-02-19T09:24:47Z",
      "closedAt": "2021-02-19T09:24:47Z",
      "comments": [
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, Lars. I can help to revise the text later next week, is it ok? ",
          "createdAt": "2021-02-03T06:03:16Z",
          "updatedAt": "2021-02-03T06:03:16Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@lisongxu I just wanted to check with you if you'd have time to work on it? :-)",
          "createdAt": "2021-02-16T03:53:56Z",
          "updatedAt": "2021-02-16T03:53:56Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Vidhi,\n\nThanks for checking with me. Really sorry that I am much busier than what I expected due to multiple back to back deadlines. It looks like that I will have some time to work on it next week after Monday (my last deadline this month :-) ).\n\nThanks\nLisong\n\n________________________________\nFrom: Vidhi Goel <notifications@github.com>\nSent: Monday, February 15, 2021 9:54 PM\nTo: NTAP/rfc8312bis <rfc8312bis@noreply.github.com>\nCc: Lisong Xu <xu@unl.edu>; Mention <mention@noreply.github.com>\nSubject: Re: [NTAP/rfc8312bis] Change introductory text to reflect deployment experience (#39)\n\nNon-NU Email\n________________________________\n\n@lisongxu<https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_lisongxu&d=DwMCaQ&c=Cu5g146wZdoqVuKpTNsYHeFX_rg6kWhlkLF8Eft-wwo&r=8GgbmpxpPRnPS9z8_jUQhw&m=AMehHSET3Bpt_r3IZ4ZDgyRqVko3-w4Z_w8m9ys__Ro&s=diWMNEcKyo_-XJXx8f_Q82bvoxlQFnmER9PLlTpG_4Y&e=> I just wanted to check with you if you'd have time to work on it? :-)\n\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub<https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_NTAP_rfc8312bis_issues_39-23issuecomment-2D779563927&d=DwMCaQ&c=Cu5g146wZdoqVuKpTNsYHeFX_rg6kWhlkLF8Eft-wwo&r=8GgbmpxpPRnPS9z8_jUQhw&m=AMehHSET3Bpt_r3IZ4ZDgyRqVko3-w4Z_w8m9ys__Ro&s=JVA21F0udJ1-VhvDChtnEsXz2cERIOTimpkazU-IlJk&e=>, or unsubscribe<https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_notifications_unsubscribe-2Dauth_ACPRVIJL2VNJEMYKSTA5Q23S7HT6DANCNFSM4W6KNQJQ&d=DwMCaQ&c=Cu5g146wZdoqVuKpTNsYHeFX_rg6kWhlkLF8Eft-wwo&r=8GgbmpxpPRnPS9z8_jUQhw&m=AMehHSET3Bpt_r3IZ4ZDgyRqVko3-w4Z_w8m9ys__Ro&s=C1urot0udNfkV9HL6wQBlqhrpxHB9ToGWiSZq-vrCNk&e=>.\n",
          "createdAt": "2021-02-16T04:05:08Z",
          "updatedAt": "2021-02-16T04:05:08Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Mon, Feb 22 is the cutoff date for i-D submissions for IETF-110. If we're not ready to submit by then, we'll have to wait until mid-March. Which isn't a huge issue, but since we're going to ask for WG adoption, it would be nice to have a more up-to-date I-D to discuss.",
          "createdAt": "2021-02-16T08:50:10Z",
          "updatedAt": "2021-02-16T08:50:10Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "I see. I will try my best. Thanks\nLisong\n\n________________________________\nFrom: Lars Eggert <notifications@github.com>\nSent: Tuesday, February 16, 2021 2:50 AM\nTo: NTAP/rfc8312bis <rfc8312bis@noreply.github.com>\nCc: Lisong Xu <xu@unl.edu>; Mention <mention@noreply.github.com>\nSubject: Re: [NTAP/rfc8312bis] Change introductory text to reflect deployment experience (#39)\n\nNon-NU Email\n________________________________\n\nMon, Feb 22 is the cutoff date for i-D submissions for IETF-110. If we're not ready to submit by then, we'll have to wait until mid-March. Which isn't a huge issue, but since we're going to ask for WG adoption, it would be nice to have a more up-to-date I-D to discuss.\n\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub<https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_NTAP_rfc8312bis_issues_39-23issuecomment-2D779682893&d=DwMCaQ&c=Cu5g146wZdoqVuKpTNsYHeFX_rg6kWhlkLF8Eft-wwo&r=8GgbmpxpPRnPS9z8_jUQhw&m=hSUqqOiPfh2Q1N6MuR2Ij_Ox6ZKD-HzrODl1-Istx0g&s=1lbItThazxoaa6MwBWONmQOg-GF9RhrjJ7vhEK1LWYg&e=>, or unsubscribe<https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_notifications_unsubscribe-2Dauth_ACPRVIJ2MY375Q7JVZCWOPDS7IWVLANCNFSM4W6KNQJQ&d=DwMCaQ&c=Cu5g146wZdoqVuKpTNsYHeFX_rg6kWhlkLF8Eft-wwo&r=8GgbmpxpPRnPS9z8_jUQhw&m=hSUqqOiPfh2Q1N6MuR2Ij_Ox6ZKD-HzrODl1-Istx0g&s=Rb4Gdva2BCz8mFAj60V9sTJh2uHK8qaQPSHjCD-WT5I&e=>.\n",
          "createdAt": "2021-02-17T00:32:22Z",
          "updatedAt": "2021-02-17T00:32:22Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "MDU6SXNzdWU4MTE5MDMyNzA=",
      "title": "Adaptive adjustment",
      "url": "https://github.com/NTAP/rfc8312bis/issues/43",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Is this \"adaptive adjustment\" that is mentioned in the text something that is still planned? Or should we remove this?",
      "createdAt": "2021-02-19T10:30:21Z",
      "updatedAt": "2021-02-22T10:17:49Z",
      "closedAt": "2021-02-22T10:17:49Z",
      "comments": [
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "I am fine with removing it. Thanks\r\n",
          "createdAt": "2021-02-19T14:14:40Z",
          "updatedAt": "2021-02-19T14:14:40Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Removed as part of #42 ",
          "createdAt": "2021-02-22T10:17:49Z",
          "updatedAt": "2021-02-22T10:17:49Z"
        }
      ]
    },
    {
      "number": 44,
      "id": "MDU6SXNzdWU4MTE5MDM2NTI=",
      "title": "\"prior_cwnd\" is not defined",
      "url": "https://github.com/NTAP/rfc8312bis/issues/44",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "\"prior_cwnd\" is used in the text but not defined.",
      "createdAt": "2021-02-19T10:30:50Z",
      "updatedAt": "2021-02-19T16:18:44Z",
      "closedAt": "2021-02-19T16:18:44Z",
      "comments": [
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "all prior_* variables are assigned in Section 4.9 for undo.",
          "createdAt": "2021-02-19T14:16:35Z",
          "updatedAt": "2021-02-19T14:16:35Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Ah yes!",
          "createdAt": "2021-02-19T16:18:35Z",
          "updatedAt": "2021-02-19T16:18:35Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "MDU6SXNzdWU4MTM1MDI2OTE=",
      "title": "CUBIC for QUIC",
      "url": "https://github.com/NTAP/rfc8312bis/issues/45",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [
        "editorial"
      ],
      "body": "Since most of the new implementations for CUBIC will be in the context of QUIC stacks (as opposed to TCP stacks), it would be useful to add a section or an appendix on how one would do that. For example, it might make sense to describe how CUBIC would be integrated into an implementation that followed the [QUIC -recovery](https://quicwg.org/base-drafts/draft-ietf-quic-recovery.html) draft.",
      "createdAt": "2021-02-22T13:29:27Z",
      "updatedAt": "2021-03-11T03:41:51Z",
      "closedAt": "2021-03-11T03:41:51Z",
      "comments": [
        {
          "author": "junhochoi",
          "authorAssociation": "NONE",
          "body": "quiche provides cubic as a default congestion control: https://github.com/cloudflare/quiche/blob/master/src/recovery/cubic.rs\r\nThis is mostly as-is implemetation of RFC8312 and HyStart++ draft. I am working on updating this following changes in this draft, such as https://github.com/cloudflare/quiche/pull/861\r\n\r\nFor implementor, most things are same, but QUIC defines (and I think most of TCP stack other than Linux?) congestion control window as a unit of bytes but the RFC8312 and this drafts defined cwnd as a unit of segment, so need to be careful when you calculate K and W_cubic.",
          "createdAt": "2021-02-24T02:37:14Z",
          "updatedAt": "2021-02-24T02:37:37Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Would you be interested in submitting a PR that would summarize these changes? Are there other QUIC stacks that are implementing CUBIC from scratch? I think picoquic did?",
          "createdAt": "2021-02-24T06:43:27Z",
          "updatedAt": "2021-02-24T06:43:27Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "IMO, it is quite straight forward to implement CUBIC using the pseudocode in [QUIC Recovery](https://quicwg.org/base-drafts/draft-ietf-quic-recovery.html) draft and adding the CUBIC pieces to the functions defined in it.\r\n\r\nCUBIC draft defines congestion window in segments which most implementors simply convert to bytes by multiplying by MSS.\r\n",
          "createdAt": "2021-02-24T07:30:32Z",
          "updatedAt": "2021-02-24T07:30:32Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "My notes on implementing Cubic for QUIC are at https://huitema.wordpress.com/2019/11/11/implementing-cubic-congestion-control-in-quic/. I already provided feedback to the \"bis\" RFC. Yes, porting Cubic to QUIC is fairly straightforward. My main implementation issue was understanding the dimensions of each formula.\r\n\r\nTwo important points from the bis draft:\r\n\r\n1. Forget about the TCP friendly formula. It does not work well, because RTT jitter will translate in CWIN swings. It is much simpler to just run the RENO algorithm in parallel and set the CWIN to max(Reno, Cubic)\r\n2. You really want to implement the recovery from spurious losses discussed in the bis draft. I think this is actually the reason for the drop in perf in face of reordering mentioned in the EPIC paper \"Making QUIC Quicker With QUIC Offload\". Not the CPU cost of reordering.",
          "createdAt": "2021-02-24T08:05:35Z",
          "updatedAt": "2021-02-24T08:05:35Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you @huitema for the issues you had filed earlier. All of these have been addressed. \r\n\r\n> My notes on implementing Cubic for QUIC are at https://huitema.wordpress.com/2019/11/11/implementing-cubic-congestion-control-in-quic/. I already provided feedback to the \"bis\" RFC. Yes, porting Cubic to QUIC is fairly straightforward. My main implementation issue was understanding the dimensions of each formula.\r\n\r\nThis is fixed with the new section [Definitions](https://tools.ietf.org/html/draft-eggert-tcpm-rfc8312bis-02#section-4.1)\r\n> \r\n> Two important points from the bis draft:\r\n> \r\n> 1. Forget about the TCP friendly formula. It does not work well, because RTT jitter will translate in CWIN swings. It is much simpler to just run the RENO algorithm in parallel and set the CWIN to max(Reno, Cubic)\r\n\r\nAIMD friendly formula now is based on RENO - [Section 4.3](https://tools.ietf.org/html/draft-eggert-tcpm-rfc8312bis-02#section-4.3)\r\n\r\n> 2. You really want to implement the recovery from spurious losses discussed in the bis draft. I think this is actually the reason for the drop in perf in face of reordering mentioned in the EPIC paper \"Making QUIC Quicker With QUIC Offload\". Not the CPU cost of reordering.\r\n\r\nIIRC, this was the issue you had filed and we add a new section [Spurious Congestion Events](https://tools.ietf.org/html/draft-eggert-tcpm-rfc8312bis-02#section-4.9)\r\n\r\n",
          "createdAt": "2021-02-24T08:16:51Z",
          "updatedAt": "2021-02-24T08:16:51Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "@goelvidhi yes, I appreciate that the issues have been addressed in the new draft. This is good. @larseggert was asking whether there was something specific to say about Cubic for QUIC. The main remaining issue is about translating the windows counts from \"packets\" to \"bytes\". When I ported Cubic to QUIC, I spent some time doing that. I first rewrote the Cubic formula:\r\n```\r\n                                             3\r\n                      W     (t) = C * (t - K)  + W\r\n                       cubic                      max\r\n```\r\nIn a \"neutral\" way:\r\n```\r\n                                                    3\r\n                                        /    /t - K\\     \\\r\n                      W     (t) = W  * (C' *( ----- )  + 1)\r\n                       cubic       max  \\    \\  K  /     /\r\n```\r\nThis rewrite helped me understand what was going on. We have a windows size coefficient, `Wmax`, expressed in the same unit as CWIN; a coefficient C' that is a pure scalar and defines the `aggressiveness` of the implementation; and a cubic curve that is a function of `(t-K)/K`. The same rewrite helps understand the coefficient C -- or C' in the new notation.\r\n```\r\n                            C     3\r\n                      C' = --- * K\r\n                            W\r\n                             max\r\n```\r\nWhich reduces to:\r\n```\r\n                                   / W    - W    \\\r\n                            C     /   max    start\\     \r\n                      C' = --- * ( ----------------)\r\n                            W     \\       C       /\r\n                             max\r\n\r\n                             / W    - W    \\\r\n                            /   max    start\\     \r\n                      C' = ( ----------------)\r\n                            \\       W       /\r\n                             \\       max   /\r\n```\r\nIn most cases, when `sstresh` is larger than 2 packets, this reduces further:\r\n```\r\n                      W      = \u03b2 W\r\n                       start      max\r\n\r\n                      C' = (1 - \u03b2)\r\n\r\n                                                         3\r\n                                        /         /t - K\\     \\\r\n                      W     (t) = W  * ((1 - \u03b2) *( ----- )  + 1)\r\n                       cubic       max  \\         \\  K  /     /\r\n```\r\nThe formula does not depend on the unit of W, packet or bytes. The coefficient C disappears, but of course it is key in computing the pseudo-period `K` of the cubic curve.",
          "createdAt": "2021-02-24T19:43:47Z",
          "updatedAt": "2021-02-24T19:43:47Z"
        },
        {
          "author": "junhochoi",
          "authorAssociation": "NONE",
          "body": "@huitema re: Spurious Congestion Events. What's your algorithm to detect a spurious retransmissions in QUIC? In the draft DSACK, F-RTO and Eifel is listed but I think none of them is directly applicable to QUIC recovery.\r\n\r\nI tried to do similar thing in Reno before, motivated by your work: https://github.com/cloudflare/quiche/pull/308\r\nIt's still Reno but the idea is same.\r\n\r\nI used the condition `\"<end of recovery> - <start of recovery> < 2 x minRTT\"` here but maybe it's too simple.",
          "createdAt": "2021-02-25T01:13:54Z",
          "updatedAt": "2021-02-25T01:14:43Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "Picoquic detects spurious retransmission event by keeping a list of packets that were recently retransmitted. The logic is:\r\n\r\n1. when the packet is first sent, keep a copy in the list of packets not-yet-acknowledged.\r\n2. when an ACK is received, remove the acked packets from the not-yet-acknowledged list. Mark the frames inside the packet as processed (e.g. stream frames so the corresponding stream data is never repeated; ack frames so ack ranges are marked as already known by the peer). Signal that data was acked to CC engine. (but see also step 4)\r\n3. when running loss detection, if a packet is deemed lost, mark frames for retransmission as appropriate; move the packet copy from the not-yet-acknowledged list to the \"retransmitted\" list. Signal that packet was lost to CC engine.\r\n4. when an ACK is received, check whether some of the acked packets are in the retransmitted list. If so, signal spurious retransmission to the CC engine. Also, mark the frames inside the packet as processed, etc.\r\n5. every so often, trim the retransmitted list and remove the packets that are too old.",
          "createdAt": "2021-02-25T01:49:08Z",
          "updatedAt": "2021-02-25T01:50:09Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n>                                                          3\r\n>                                         /         /t - K\\     \\\r\n>                       W     (t) = W  * ((1 - \u03b2) *( ----- )  + 1)\r\n>                        cubic       max  \\         \\  K  /     /\r\n> ```\r\n> \r\n> The formula does not depend on the unit of W, packet or bytes. The coefficient C disappears, but of course it is key in computing the pseudo-period `K` of the cubic curve.\r\n\r\n@huitema you arrived at this formula by substitution but I don't see how is it better than \r\n[Figure 1](https://www.ietf.org/archive/id/draft-eggert-tcpm-rfc8312bis-02.html#figure-1).\r\n\r\nFor folks who use bytes instead of segments for congestion window, they would still need to divide by mss in [Figure 2](https://www.ietf.org/archive/id/draft-eggert-tcpm-rfc8312bis-02.html#figure-2) to compute K.\r\n\r\nI think the units that we have added in the new draft will help folks in deciding when to divide/multiply by segment size.\r\n",
          "createdAt": "2021-02-26T02:37:37Z",
          "updatedAt": "2021-02-26T02:37:37Z"
        },
        {
          "author": "junhochoi",
          "authorAssociation": "NONE",
          "body": "@huitema thanks for how to detect spurious retransmission! I will take a look if this is applicable to quiche.",
          "createdAt": "2021-02-26T08:18:43Z",
          "updatedAt": "2021-02-26T08:18:43Z"
        },
        {
          "author": "junhochoi",
          "authorAssociation": "NONE",
          "body": "Additionally,\r\n- integer vs floating point arithmetic: most of quic implementaion is userland, easier to use floating point arithmetic for various calculation. But for high performance it'll be better to make it integer ops only. \r\n- I wrote a blog post last year when I implemented cubic in quiche: https://blog.cloudflare.com/cubic-and-hystart-support-in-quiche/\r\n- [quicly](https://github.com/h2o/quicly/blob/master/lib/cc-cubic.c) and [msquic](https://github.com/microsoft/msquic/blob/main/src/core/congestion_control.c) has CUBIC too.",
          "createdAt": "2021-02-26T08:18:53Z",
          "updatedAt": "2021-02-26T08:18:53Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "@goelvidhi I started this rewriting of formulas in an attempt to understand how the coefficients C and \u03b2 affect the behavior of Cubic. The rewritten formula shows that the key coefficients are really:\r\n\r\n* An amplitude coefficient, \u03b2. Changing the value of \u03b2 from for example 3/4th to 7/8th reduces the amplitude of the variations, both before the inflection point and after it.\r\n* A pseudo-period K, which sets the time between the beginning of the epoch and the inflection point. Shorter values of K will cause Cubic to adapt and probe faster, and vice versa.\r\n\r\nThe rewriting also shows the problem with the original formula. This formula results from experiments and adaptations, but it is quite hard to understand how K will vary with bandwidth, latency, and the value of C. A stated design goal of Cubic is to share the bottleneck bandwidth fairly between competing connections experiencing different RTTs. I would expect that the computation of the pseudo-period result such design goals, from design principles, but the formulas are very hard to derive. We end up with empirical tuning, such as \"we tried C=0.0004 and it works well\". I don't find that very satisfactory.",
          "createdAt": "2021-02-26T19:19:08Z",
          "updatedAt": "2021-02-26T19:19:40Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Quoting from the draft, \r\n\r\n> Two CUBIC flows with different RTTs have a throughput ratio that is linearly proportional to the inverse of their RTT ratio, where the throughput of a flow is approximately the size of its congestion window divided by its RTT.\r\n\r\n> Specifically, CUBIC maintains a window increase rate independent of RTTs outside of the AIMD-friendly region, and thus flows with different RTTs have similar congestion window sizes under steady state when they operate outside the AIMD-friendly region.\r\n\r\nThe bandwidth will be shared fairly in the sense that the congestion window will grow similarly but the throughput is still inversely proportional to the RTT. @lisongxu can comment more on this, but the whole point of Cubic increase function and K is to be independent of RTT / latency to give similar cwnd growth to competing flows.",
          "createdAt": "2021-02-27T09:58:26Z",
          "updatedAt": "2021-02-27T10:02:26Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "I understand that each loss event triggers a computation of the formula, and that at equilibrium the average WMAX is a function of packet loss rate. So, yes, in that sense there is fairness. On the other hand, that property is also true for new Reno. There are two problems on New Reno with high latency links: the dependency on loss rate, which limits the size of the window; and the dependency on RTT, which privilege short RTT. WMAX in Cubic converges at a higher value than ssthresh in Reno, which is better for high latency links. But we still have the issue of RTT unfairness.",
          "createdAt": "2021-02-27T17:21:32Z",
          "updatedAt": "2021-02-27T17:21:32Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "If by RTT unfairness, you mean throughput inversely proportional to RTT, then yes, that is a design limitation of CUBIC. I am not sure what update you are expecting/suggesting :-)",
          "createdAt": "2021-03-07T22:51:17Z",
          "updatedAt": "2021-03-07T22:51:26Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "Sorry, not expecting any change at this point. I should write all that in a paper.",
          "createdAt": "2021-03-08T03:20:02Z",
          "updatedAt": "2021-03-08T03:20:02Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "So does the current text address all issues raised by @junhochoi and @huitema? If yes, I will close this.",
          "createdAt": "2021-03-08T13:50:35Z",
          "updatedAt": "2021-03-08T13:50:35Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "And FYI, I am planning to submit a new revision before the TCPM meeting, to roll in all the changes since -01. If we need additional changes that are easy to make to address this issue, it would be good to get them in soon.",
          "createdAt": "2021-03-08T16:26:41Z",
          "updatedAt": "2021-03-08T16:26:41Z"
        },
        {
          "author": "junhochoi",
          "authorAssociation": "NONE",
          "body": "My question is answered in the different ticket so it's ok. I think the goal of this issue is to add some text around QUIC implementation?",
          "createdAt": "2021-03-08T17:00:44Z",
          "updatedAt": "2021-03-08T17:00:44Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "As I mentioned earlier, with the current CUBIC draft, it is quite straight forward to adopt it for QUIC by plugging into the pseudo code in QUIC recovery draft. @junhochoi is there anything specific that seemed tricky to implement Cubic for QUIC?",
          "createdAt": "2021-03-08T17:46:12Z",
          "updatedAt": "2021-03-08T17:46:12Z"
        },
        {
          "author": "junhochoi",
          "authorAssociation": "NONE",
          "body": "@goelvidhi I am still working on updating quiche CUBIC according to this draft. I may find more but I commented most of them in this ticket already.\r\n\r\nAlso it's one of my comment but again, in \"Spurious Congestion Events\" section most of algorithms detecting spurious retransmission is not directly applicable in QUIC and QUIC recovery draft doesn't mention about it, so you need to implement your own.",
          "createdAt": "2021-03-08T22:09:25Z",
          "updatedAt": "2021-03-08T22:09:25Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, I had discussed this briefly in QUIC WG and I was pointed to the below text. I know that this text doesn't talk about how the congestion controller should react to it but once a spurious loss is detected (some TCP RFCs talk about how to detect it), one can follow the CUBIC Section for Spurious Congestion events.\r\n\r\n> Spuriously declaring packets as lost leads to unnecessary retransmissions and may result in degraded performance due to the actions of the congestion controller upon detecting loss. Implementations can detect spurious retransmissions and increase the reordering threshold in packets or time to reduce future spurious retransmissions and loss events.",
          "createdAt": "2021-03-09T01:46:40Z",
          "updatedAt": "2021-03-09T01:46:40Z"
        },
        {
          "author": "WesleyRosenblum",
          "authorAssociation": "NONE",
          "body": "One thing I noticed is that if you use min RTT instead of smoothed RTT ([as Linux TCP Cubic does](https://github.com/torvalds/linux/blob/05a59d79793d482f628a31753c671f2e92178a21/net/ipv4/tcp_cubic.c#L266)), you can potentially end up with a divide by zero in the `w_est` calculation. This is because the [QUIC Recovery pseudocode](https://tools.ietf.org/id/draft-ietf-quic-recovery-34.html#name-initialization) initializes the min_rtt to 0. An endpoint can enter congestion avoidance without receiving any acks for any ack-eliciting packets (only non-ack eliciting packets), and thus min_rtt would still be zero at the time `w_est` is calculated. This can be addressed by initializing `min_rtt` to `kInitialRtt` instead of zero.\r\n\r\nThough, now that `w_est` no longer incorporates `t/RTT` this shouldn't be an issue. ",
          "createdAt": "2021-03-10T07:49:47Z",
          "updatedAt": "2021-03-10T07:49:47Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@WesleyRosenblum is this something that should be fixed in the QUIC -recovery document? If yes, please file an issue at https://github.com/quicwg/base-drafts/issues",
          "createdAt": "2021-03-10T09:51:58Z",
          "updatedAt": "2021-03-10T09:51:58Z"
        },
        {
          "author": "WesleyRosenblum",
          "authorAssociation": "NONE",
          "body": "Thanks @larseggert, I've opened an issue to the Quic WG: https://github.com/quicwg/base-drafts/issues/4833",
          "createdAt": "2021-03-10T19:06:09Z",
          "updatedAt": "2021-03-10T19:09:49Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "As of now, there is nothing to do here. I am closing this issue.",
          "createdAt": "2021-03-11T03:41:51Z",
          "updatedAt": "2021-03-11T03:41:51Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "MDU6SXNzdWU4MTUwMTEyODQ=",
      "title": "In PDF, alpha/beta looks broken",
      "url": "https://github.com/NTAP/rfc8312bis/issues/46",
      "state": "CLOSED",
      "author": "junhochoi",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "In a converted PDF, it looks like alpha -> \u00ce\u00b1 and beta -> \u00ce\u00b2\r\n\r\nFor example,\r\n```\r\n\u03b1_{aimd} = 3 * \\frac{1 - \u03b2_{cubic}}{1 + \u03b2_{cubic}}\r\n```\r\n\r\nlooks like following:\r\n\r\n<img width=\"745\" alt=\"Screen Shot 2021-02-23 at 6 02 39 PM\" src=\"https://user-images.githubusercontent.com/1229714/108934304-8a2a3980-7601-11eb-96cb-dc0fa1a7855a.png\">\r\n",
      "createdAt": "2021-02-24T02:06:28Z",
      "updatedAt": "2021-04-19T11:41:36Z",
      "closedAt": "2021-04-19T11:41:36Z",
      "comments": [
        {
          "author": "junhochoi",
          "authorAssociation": "NONE",
          "body": "others (txt, html) looks fine.",
          "createdAt": "2021-02-24T02:07:40Z",
          "updatedAt": "2021-02-24T02:07:40Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Which PDF are you looking at? (This is likely a Unicode bug in the converter.)",
          "createdAt": "2021-02-24T06:46:23Z",
          "updatedAt": "2021-02-24T06:47:15Z"
        },
        {
          "author": "junhochoi",
          "authorAssociation": "NONE",
          "body": "I am looking https://tools.ietf.org/pdf/draft-eggert-tcpm-rfc8312bis-02.txt\r\n(wow it's PDF but has .txt extension)",
          "createdAt": "2021-02-24T08:44:25Z",
          "updatedAt": "2021-02-24T08:44:25Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Thanks, I filed https://trac.tools.ietf.org/tools/ietfdb/ticket/3191",
          "createdAt": "2021-02-24T09:27:44Z",
          "updatedAt": "2021-02-24T09:27:44Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Closing this, since it's an issue with tools.ietf.org and not this document.",
          "createdAt": "2021-04-19T11:41:36Z",
          "updatedAt": "2021-04-19T11:41:36Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "MDU6SXNzdWU4MTU5NzA2NDM=",
      "title": "Question on AIMD-Friendly Region",
      "url": "https://github.com/NTAP/rfc8312bis/issues/47",
      "state": "CLOSED",
      "author": "junhochoi",
      "authorAssociation": "NONE",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [],
      "body": "Hi, while I am implementing this change in quiche, I want to make sure my understanding is correct on \"AIMD-Friendly Region\" section.\r\n\r\nIt says to use\r\n```\r\nW_{est} = W_{est} + \u03b1_{aimd} * \\frac{segments\\_acked}{cwnd}\r\n```\r\nTo calculate W_est value and alpha_aimd initially is\r\n\r\n```\r\n\u03b1_{aimd} = 3 * \\frac{1 - \u03b2_{cubic}}{1 + \u03b2_{cubic}}\r\n```\r\n\r\nSince \u03b2_{cubic is 0.7 (Section 4.6), it comes down to\r\n\r\n```\r\n\u03b1_{aimd} = 3 * (1-0.7)/(1+0.7) = 0.529\r\n```\r\n\r\nAnd \u03b1_{aimd} will become 1 when W_est >= W_max.\r\n\r\nWhich means in each ACK, W_est can be calculated as follows:\r\n\r\n```\r\nW_est = W_est + 0.529 * (segments_acked / cwnd)               (W_est < W_max)\r\nW_est = W_est + 1 * (segments_acked / cwnd)                   (W_est >= W_max)\r\n```\r\n\r\nIs my understanding correct? My concern is when W_est < W_max, it's slower than Reno.\r\n\r\nAlso, I think the definition of segments_acked is missing in the draft.",
      "createdAt": "2021-02-25T00:56:43Z",
      "updatedAt": "2021-03-04T03:57:32Z",
      "closedAt": "2021-03-04T03:57:32Z",
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "It looks right. In CUBIC, we start with W_est = 0.7 * cwnd (which is higher than new Reno).\r\n\r\nThe idea of AIMD growth for W_est is to reach the W_max in the same amount of time as New Reno would and as we have a higher starting point for W_est, the growth function is slower than new Reno. And after W_est has reached W_max, we continue with Reno like growth.\r\n\r\nReg. definition of segments_acked, we could add it. Although it seemed obvious to me. :-)",
          "createdAt": "2021-02-25T08:48:54Z",
          "updatedAt": "2021-02-25T08:48:54Z"
        },
        {
          "author": "junhochoi",
          "authorAssociation": "NONE",
          "body": "Thanks for a kind explanation!\r\n\r\nI have some more question\u3134 during my implementation:\r\n\r\n1) In the draft, W_est is\r\n\r\n```\r\nW_est = W_est + alpha_aimd * (segments_acked / cwnd)   (Fig. 4)\r\n```\r\n\r\nHowever, I think `cwnd` here is `W_est`, to match to Reno definition?\r\n\r\n```\r\nW_est = W_est + alpha_aimd * (segments_acked / W_est)\r\n```\r\n\r\nOtherwise I am confused what is `cwnd` here. In the beginning of CA cwnd is 7, but both using the same value or a current cwnd doesn't make sense to me.\r\n\r\nAlso in any case it's slower growth than Reno.\r\n\r\n2) assuming I use 2nd equation for W_est, I tried to plot each W_* values:\r\n\r\n- W_max = 10\r\n- When I run Reno separately, it starts from 5 (10 x 0.5). (Reno cwnd)\r\n- W_est starts from 7 (10 * 0.7). I expect it will meet at W_max, but in the sheet, both meet around after 8.8 (after 12 ACKs) in the draft, not 10. \r\n- W_cubic is only for reference. it doesn't need to match at 10\r\n- X = time Y = cwnd\r\n\r\n![Screen Shot 2021-02-25 at 11 48 10 PM](https://user-images.githubusercontent.com/1229714/109271128-ec329c80-77c3-11eb-8864-bdea4371758d.png)\r\n\r\nAfter 10, both never meet again because they use same slope.\r\n\r\nI tried to play with a different alpha_aimd values and when alpha_aimd = 0.7 (beta_cubic) both meet at 10.\r\n\r\n![Screen Shot 2021-02-25 at 11 49 52 PM](https://user-images.githubusercontent.com/1229714/109271289-28fe9380-77c4-11eb-8bde-fd4aba8924b6.png)\r\n\r\nIs my understanding correct?\r\n\r\nDatasheet is here: https://docs.google.com/spreadsheets/d/1DvNb-hmPpJ31M7RWWqHNCIgBQwKLXWewvzDDWraG8ns/edit?usp=sharing",
          "createdAt": "2021-02-26T07:54:40Z",
          "updatedAt": "2021-02-26T09:07:11Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> However, I think `cwnd` here is `W_est`, to match to Reno definition?\r\n> \r\n> ```\r\n> W_est = W_est + alpha_aimd * (segments_acked / W_est)\r\n> ```\r\n> \r\n> Otherwise I am confused what is `cwnd` here. In the beginning of CA cwnd is 7, but both using the same value or a current cwnd doesn't make sense to me.\r\n> \r\n\r\ncwnd is current congestion window (cubic window or AIMD window, whichever is greater) because we want to increase by alpha_aimd on every RTT and only the current congestion window (not AIMD window) represents one RTT when the full window is ACKed.",
          "createdAt": "2021-02-27T09:30:45Z",
          "updatedAt": "2021-02-27T09:30:45Z"
        },
        {
          "author": "junhochoi",
          "authorAssociation": "NONE",
          "body": "@goelvidhi Thanks. I tried `cwnd` (updated my sheet) as well but it doesn't completely solve my concern, this simulated AIMD started bigger than Reno (because beta_cubic(0.7) > 0.5 of Reno) but soon it's slower growth than Reno. If this is true, simply running Reno in parallel and taking max(reno, cubic) in AIMD region would help. However let it closed and I'll look into a little more.",
          "createdAt": "2021-03-03T08:43:43Z",
          "updatedAt": "2021-03-03T08:43:43Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "(I don't think this should have been closed.)",
          "createdAt": "2021-03-03T11:41:51Z",
          "updatedAt": "2021-03-03T11:41:51Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Junho, \r\n\r\nThe AIMD (a, b) analysis considers the steady-state performance with a deterministic loss model\r\n- a deterministic loss model:  a packet is lost every 1/p packet. \r\n- steady state:  cwnd increases and reaches Wmax  just before a packet is lost, and then it repeats the same pattern again and again. \r\n\r\nThere is a relation between a and b such that AIMD(a,b) achieves the same average cwnd for a given p.\r\n\r\nThe above analysis assumes that cwnd increases up to Wmax, and thus a is only the increase parameter up to W_max. \r\n\r\nThank you\r\nLisong",
          "createdAt": "2021-03-03T17:31:15Z",
          "updatedAt": "2021-03-03T17:31:15Z"
        },
        {
          "author": "junhochoi",
          "authorAssociation": "NONE",
          "body": "@lisongxu Thanks for your kind explanation! Yes now I understand better. Closing this ticket.",
          "createdAt": "2021-03-04T03:57:32Z",
          "updatedAt": "2021-03-04T03:57:32Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "MDU6SXNzdWU4MjM2OTUxNTM=",
      "title": "Fast convergence",
      "url": "https://github.com/NTAP/rfc8312bis/issues/51",
      "state": "CLOSED",
      "author": "lisongxu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "larseggert",
        "sangtaeha",
        "goelvidhi",
        "Injongrhee"
      ],
      "labels": [],
      "body": "It seems that there is a mistake in Section 4.7\r\n\r\nCurrent draft\r\n~~~ \r\nW_max\r\n= \r\nW_max * (1 + \u03b2_cubic)/2,   if  cwnd < W_max\r\ncwnd,                      otherwise\r\n~~~\r\n\r\nbut it should be \r\n~~~ \r\nW_max\r\n= \r\ncwnd * (1 + \u03b2_cubic)/2,   if  cwnd < W_max\r\ncwnd,                      otherwise\r\n~~~\r\n\r\n\r\nAlso I like to make the following change to clearly specify the behavior with fast convergence is disabled\r\n\r\n~~~ \r\nW_max\r\n= \r\ncwnd * (1 + \u03b2_cubic)/2,   if  (cwnd < W_max) and (fast convergence is enabled)\r\ncwnd,                      otherwise\r\n~~~\r\n\r\nThanks!\r\nLisong\r\n\r\n\r\n\r\n\r\n",
      "createdAt": "2021-03-06T16:59:36Z",
      "updatedAt": "2021-03-08T16:21:47Z",
      "closedAt": "2021-03-08T16:21:47Z",
      "comments": [
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Submit a PR?",
          "createdAt": "2021-03-07T06:30:54Z",
          "updatedAt": "2021-03-07T06:30:54Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "yes, I will do it",
          "createdAt": "2021-03-07T14:17:37Z",
          "updatedAt": "2021-03-07T14:17:37Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "MDU6SXNzdWU4MjU4NzY4MDY=",
      "title": "ssthresh and cwnd_start should not exceed Beta_cubic * congestion window at loss",
      "url": "https://github.com/NTAP/rfc8312bis/issues/53",
      "state": "CLOSED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Lisong's mentioned this in an off-line discussion,\r\n\r\nBelow I will use X to refer to (beta * cwnd right before the congestion event).\r\n\r\nAn implementation of CUBIC can choose different ways to adjust the cwnd during the fast recovery and timeout.\r\n\r\nBut after the fast recovery/ECN, it should set cwnd (i.e., cwnd_start) and ssthresh to X. This is because all the parameters (such as C, alpha, and beta) of CUBIC are chosen based on this assumption. If an implementation chooses its own ssthresh and own cwnd_start, then the performance of such an implementation will be very different from what we expected. \r\n\r\nI understand and agree with your motivation to be more flexible (as CUBIC may be implemented for various purposes, TCP, UDP, media streaming as RC 7661, QUIC, .... ). Therefore, I would suggest that an implementation SHOULD set ssthresh and cwnd_start to X, and it MAY set them to a value lower than X as the cost of lower performance. But it MUST NOT set them to a value higher than X. \r\n\r\n",
      "createdAt": "2021-03-09T12:48:54Z",
      "updatedAt": "2021-03-11T07:54:38Z",
      "closedAt": "2021-03-11T07:54:38Z",
      "comments": [
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "I think #54 is supposed to address this? Marking it as such.",
          "createdAt": "2021-03-09T13:43:40Z",
          "updatedAt": "2021-03-09T13:43:40Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "MDU6SXNzdWU4Mjk4MTQxMTA=",
      "title": "Update the definition of W_max to include fast convergence scenario",
      "url": "https://github.com/NTAP/rfc8312bis/issues/55",
      "state": "CLOSED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "lisongxu"
      ],
      "labels": [
        "editorial"
      ],
      "body": "Copying some suggestions from Lisong here,\r\n\r\nchange  \"wmax: size of cwnd just before cwnd was reduced in the last congestion event\".    \r\nto  \"wmax: size of cwnd just before cwnd was reduced in the last congestion event when fast convergence is disabled\" \r\nor  \"wmax: cwnd (without fast convergence) or reduced cwnd (with fast convergence) just before cwnd was reduced in the last congestion event\" ?",
      "createdAt": "2021-03-12T06:50:43Z",
      "updatedAt": "2021-04-21T08:47:15Z",
      "closedAt": "2021-04-21T08:47:15Z",
      "comments": [
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Do we still want to make this change?",
          "createdAt": "2021-04-19T11:41:02Z",
          "updatedAt": "2021-04-19T11:41:02Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, I can make this change in one or two days. Thanks\nLisong\n\n________________________________\nFrom: Lars Eggert ***@***.***>\nSent: Monday, April 19, 2021 6:41 AM\nTo: NTAP/rfc8312bis ***@***.***>\nCc: Subscribed ***@***.***>\nSubject: Re: [NTAP/rfc8312bis] Update the definition of W_max to include fast convergence scenario (#55)\n\nNon-NU Email\n________________________________\n\nDo we still want to make this change?\n\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub<https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_NTAP_rfc8312bis_issues_55-23issuecomment-2D822401363&d=DwMCaQ&c=Cu5g146wZdoqVuKpTNsYHeFX_rg6kWhlkLF8Eft-wwo&r=8GgbmpxpPRnPS9z8_jUQhw&m=pv4Dx4acp12dxZuDKww6xQX6Z-QleZdDAUMQ4OqkdDw&s=DuZq2cNwkxAZcnw1NSunYP4y12gJ1PTIDd20SqbPWXY&e=>, or unsubscribe<https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_notifications_unsubscribe-2Dauth_ACPRVIKU2TYAYOYHMMRHLO3TJQJFZANCNFSM4ZBWNJHA&d=DwMCaQ&c=Cu5g146wZdoqVuKpTNsYHeFX_rg6kWhlkLF8Eft-wwo&r=8GgbmpxpPRnPS9z8_jUQhw&m=pv4Dx4acp12dxZuDKww6xQX6Z-QleZdDAUMQ4OqkdDw&s=86DfIc2L_tI3mGi93CNlX_OOFqamITJRIYo0fA-K_O4&e=>.\n",
          "createdAt": "2021-04-19T13:26:11Z",
          "updatedAt": "2021-04-19T13:26:11Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks Lisong. Will assign the issue to you.\r\n(Sorry I was slow in responding)",
          "createdAt": "2021-04-20T00:49:26Z",
          "updatedAt": "2021-04-20T00:49:26Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "No problem. Thanks\nLisong\n\n________________________________\nFrom: Vidhi Goel ***@***.***>\nSent: Monday, April 19, 2021 7:49 PM\nTo: NTAP/rfc8312bis ***@***.***>\nCc: Lisong Xu ***@***.***>; Assign ***@***.***>\nSubject: Re: [NTAP/rfc8312bis] Update the definition of W_max to include fast convergence scenario (#55)\n\nNon-NU Email\n________________________________\n\nThanks Lisong. Will assign the issue to you.\n(Sorry I was slow in responding)\n\n\u2014\nYou are receiving this because you were assigned.\nReply to this email directly, view it on GitHub<https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_NTAP_rfc8312bis_issues_55-23issuecomment-2D822888811&d=DwMCaQ&c=Cu5g146wZdoqVuKpTNsYHeFX_rg6kWhlkLF8Eft-wwo&r=8GgbmpxpPRnPS9z8_jUQhw&m=My_tMFcunG7TroQNrs6TTNxb1oete3g1ZDqj-NqwR5Q&s=T3dt1Jp_yLCUshLlWFL6dwoQhmUCzSPq4qM6jngVeLs&e=>, or unsubscribe<https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_notifications_unsubscribe-2Dauth_ACPRVIPDA5D5SHKPQXJU2EDTJTFSPANCNFSM4ZBWNJHA&d=DwMCaQ&c=Cu5g146wZdoqVuKpTNsYHeFX_rg6kWhlkLF8Eft-wwo&r=8GgbmpxpPRnPS9z8_jUQhw&m=My_tMFcunG7TroQNrs6TTNxb1oete3g1ZDqj-NqwR5Q&s=jtBOeJtOSLIuMzI8kcQNU7nQqfQEq946rRkTRa_zqqo&e=>.\n",
          "createdAt": "2021-04-20T00:55:31Z",
          "updatedAt": "2021-04-20T00:55:31Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "@lisongxu Yes, this is more precise. \"wmax: size of cwnd just before cwnd was reduced in the last congestion event when fast convergence is disabled\"",
          "createdAt": "2021-04-20T00:59:46Z",
          "updatedAt": "2021-04-20T00:59:46Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks Sangtae! Any suggestions on how to clearly describe wmax when fast convergence is enabled?",
          "createdAt": "2021-04-20T01:10:42Z",
          "updatedAt": "2021-04-20T01:10:42Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "One suggestion,\r\n\r\n```\r\nwmax: size of cwnd just before cwnd was reduced in the last congestion event when fast convergence is disabled.\r\nHowever, if fast convergence is enabled, the size may be further reduced based on the current saturation point.\r\n",
          "createdAt": "2021-04-20T01:57:02Z",
          "updatedAt": "2021-04-20T01:58:14Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, Vidhi!",
          "createdAt": "2021-04-20T02:49:20Z",
          "updatedAt": "2021-04-20T02:49:20Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Just updated. Thanks",
          "createdAt": "2021-04-20T02:53:12Z",
          "updatedAt": "2021-04-20T02:53:12Z"
        }
      ]
    },
    {
      "number": 57,
      "id": "MDU6SXNzdWU4NTgzNjk3NDY=",
      "title": "linux's cubic fix? (better follow cubic curve after idle period)",
      "url": "https://github.com/NTAP/rfc8312bis/issues/57",
      "state": "CLOSED",
      "author": "junhochoi",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "help wanted"
      ],
      "body": "http://bitsup.blogspot.com/2015/09/thanks-google-tcp-team-for-open-source.html\r\nhttps://github.com/torvalds/linux/commit/30927520dbae297182990bb21d08762bcc35ce1d\r\n\r\nDoes rfc8312bis need to mention/include about this algorithm?",
      "createdAt": "2021-04-15T00:47:25Z",
      "updatedAt": "2021-04-15T22:03:08Z",
      "closedAt": "2021-04-15T22:03:08Z",
      "comments": [
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "This is discussed in [Section 5.8](https://ntap.github.io/rfc8312bis/draft-ietf-tcpm-rfc8312bis.html#name-behavior-for-application-li). Thanks",
          "createdAt": "2021-04-15T22:00:04Z",
          "updatedAt": "2021-04-15T22:00:04Z"
        },
        {
          "author": "junhochoi",
          "authorAssociation": "NONE",
          "body": "Indeed. Thanks!",
          "createdAt": "2021-04-15T22:03:08Z",
          "updatedAt": "2021-04-15T22:03:08Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "MDU6SXNzdWU4Njg5MTc4NTg=",
      "title": "Michael Scharf's review",
      "url": "https://github.com/NTAP/rfc8312bis/issues/59",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "[Michael Scharf wrote:](https://mailarchive.ietf.org/arch/msg/tcpm/3Sm4wYQzf_Azakp36sdQY_3r0oM/)\r\n\r\n>In the current version, the abstract, introduction and some later non-normative sections are by and large copied from RFC 8312. While that is perfectly reasonable for a -bis document, I believe the document could be a bit more explicit regarding the new status as PS, even if this would imply some editorial changes as compared to RFC 8312.\r\n>\r\n>As of today, 8312bis is probably one of the most important and most widely deployed TCP standards. But the text is not necessarily written that way, given its origins.\r\n>\r\n>Here are some examples of what comes into my mind:\r\n>\r\n>1/ Abstract:\r\n>\r\n>\"CUBIC is an extension to the traditional TCP standards. It differs from the traditional TCP standards only in the congestion control algorithm on the sender side.\"\r\n>\r\n>IMHO one could also start here with something much more explicit along the lines of \"CUBIC is a standard TCP congestion control algorithm [...]\".\r\n>\r\n>Personally, I don't like the term \"traditional standards\" in this context. In fact, after 8312bis will be published as PS, CUBIC may actually become part of what one could consider as \"traditional standards\". Maybe it would be better to avoid that term altogether? At least, I believe it could be avoided by rewording the abstract.\r\n>\r\n>2/ Introduction: \r\n>\r\n>The key sentence \"It is therefore to be regarded as the current standard for TCP congestion control\" comes at the end after a lot of text on the historical background.\r\n>\r\n>An alternative would be to start in the introduction with what CUBIC is as according to this document and why CUBIC is relevant. Obviously, the historical context _is_ important and must be explained in the document. But I am less sure whether the history needs to be at the beginning of the introduction. At least newcomers to congestion control may more care about the content of this Proposed Standard and less about research that resulted in RFC 8312.\r\n>\r\n>3/ Section 5.4:\r\n>\r\n>\"CUBIC has been extensively studied by using both NS-2 simulation and testbed experiments, covering a wide range of network environments. More information can be found in [HKLRX06]. Additionally, there is decade-long deployment experience with CUBIC on the Internet.\"\r\n>\r\n>This is another example where the most important message as of 2021 comes somewhere at the end. Given the experience with CUBIC, one could just start with the last sentence \"There is decade-long deployment experience...\" and then state something along the lines of \"The original CUBIC design has been studied extensively by using both NS-2 simulation and testbed experiments...\". Just as a thought.\r\n>\r\n>Probably the existing text in -01 also works in all these cases and this is just about editorial style. But I think we could at least discuss whether some alternative wordings would make sense given the new PS status, in particular for newcomers who may not have read RFC 8312 and don't know its history (and probably never have to once this PS is published).",
      "createdAt": "2021-04-27T14:40:18Z",
      "updatedAt": "2021-05-05T18:22:58Z",
      "closedAt": "2021-05-05T18:22:58Z",
      "comments": []
    },
    {
      "number": 61,
      "id": "MDU6SXNzdWU5MDgwNzY0MjI=",
      "title": "Mention that CUBIC can be used for SCTP, QUIC, etc.?",
      "url": "https://github.com/NTAP/rfc8312bis/issues/61",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [
        "WG LC",
        "editorial"
      ],
      "body": "[Yoshi said](https://mailarchive.ietf.org/arch/msg/tcpm/W-t1q8q6Q0Ofjcp0iXOgmY18mr0):\r\n>1: While this draft focuses on only TCP,  CUBIC can actually be applied to other transport protocols \r\n    such as QUIC, SCTP. Do we want to mention it in the draft or is it out of scope?\r\n",
      "createdAt": "2021-06-01T09:05:03Z",
      "updatedAt": "2021-06-08T06:34:52Z",
      "closedAt": "2021-06-08T06:34:52Z",
      "comments": []
    },
    {
      "number": 62,
      "id": "MDU6SXNzdWU5MDgwNzc4OTM=",
      "title": "Events detected by RACK",
      "url": "https://github.com/NTAP/rfc8312bis/issues/62",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [
        "WG LC"
      ],
      "body": "[Yoshi said](https://mailarchive.ietf.org/arch/msg/tcpm/W-t1q8q6Q0Ofjcp0iXOgmY18mr0):\r\n>>2: Section 3.1 \"After a window reduction in response to a congestion event is\r\n     detected by duplicate ACKs or Explicit Congestion Notification-Echo\r\n     (ECN-Echo, ECE) ACKs [RFC3168], CUBIC remembers the congestion window...\"\r\n>\r\n>   I think the events detected by RACK (or PTO for QUIC) can also be included here.\r\n",
      "createdAt": "2021-06-01T09:06:41Z",
      "updatedAt": "2021-07-22T05:22:27Z",
      "closedAt": "2021-07-22T05:22:27Z",
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "thanks @nsdyoshi. Do you have any specific suggestions in terms of how much should we talk about RACK or should we just add a one-liner?",
          "createdAt": "2021-06-16T07:05:55Z",
          "updatedAt": "2021-06-16T07:05:55Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "one liner works for me, but, I think the following part in Section 4.6 also needs to be updated.\r\n\r\n> When a packet loss is detected by duplicate ACKs or by receiving packets carrying ECE flags, CUBIC updates Wmax and reduces cwnd and ssthresh immediately as described below\r\n",
          "createdAt": "2021-06-16T16:14:12Z",
          "updatedAt": "2021-06-16T16:14:12Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@goelvidhi could you create a PR for this?",
          "createdAt": "2021-07-15T11:28:04Z",
          "updatedAt": "2021-07-15T11:28:21Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "yes, will send something soon.",
          "createdAt": "2021-07-16T08:11:37Z",
          "updatedAt": "2021-07-16T08:11:37Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@goelvidhi could we get this done by the end of the week, so we can post a new draft on Monday?",
          "createdAt": "2021-07-20T07:35:50Z",
          "updatedAt": "2021-07-20T07:35:50Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "MDU6SXNzdWU5MDgwODE4MjM=",
      "title": "'Equation' rather than 'Figure'",
      "url": "https://github.com/NTAP/rfc8312bis/issues/63",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "larseggert"
      ],
      "labels": [
        "WG LC",
        "editorial"
      ],
      "body": "[Yoshi said](https://mailarchive.ietf.org/arch/msg/tcpm/W-t1q8q6Q0Ofjcp0iXOgmY18mr0):\r\n>4: Section 4.2  I personally prefer to refer the equations in the draft as 'Equation' rather than 'Figure'  if there's \r\n    no strong reason for it.  \r\n",
      "createdAt": "2021-06-01T09:11:11Z",
      "updatedAt": "2021-06-05T14:27:23Z",
      "closedAt": "2021-06-05T14:27:23Z",
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Whenever some relevant text is followed by an equation, we refer to it as `formula` or `equation`. But if we are referring to an equation in the later text, then we use the term `figure`. This seems consistent with other sections of the draft.\r\n\r\nI do like your advice of changing the figure to equation though. So I will try to change it at all places.",
          "createdAt": "2021-06-03T09:46:29Z",
          "updatedAt": "2021-06-03T09:46:29Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert the text in the raw file uses the below code which shows as Figure 1. Is there an easy way to change this to Equation 1?\r\n> {: #eq1 artwork-align=\"center\" }",
          "createdAt": "2021-06-03T10:22:43Z",
          "updatedAt": "2021-06-03T10:22:43Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> With kramdown-xml2rfc2629, it's unfortunately not possible to change this. We would need to add an RFC Editor Note instructing them to manually make the change. Opened https://github.com/NTAP/rfc8312bis/issues/63\r\n\r\nJust saw your reply on the email. In that case, I believe we just need to add a note. Do you want to do that?",
          "createdAt": "2021-06-03T10:39:41Z",
          "updatedAt": "2021-06-03T10:39:41Z"
        }
      ]
    },
    {
      "number": 64,
      "id": "MDU6SXNzdWU5MDgwODIzNjM=",
      "title": "Two meanings for a_aimd",
      "url": "https://github.com/NTAP/rfc8312bis/issues/64",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [
        "WG LC"
      ],
      "body": "[Yoshi said](https://mailarchive.ietf.org/arch/msg/tcpm/W-t1q8q6Q0Ofjcp0iXOgmY18mr0):\r\n> 5: Section 4.3  It seems to me that there are two meanings for a_aimd in this section. \r\n    One is the additive factor for CUBIC and the other is a generic parameter for AIMD() function. \r\n    This looks a bit confusing to me.\r\n",
      "createdAt": "2021-06-01T09:11:50Z",
      "updatedAt": "2021-06-16T06:38:43Z",
      "closedAt": "2021-06-16T06:38:43Z",
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Both of these mean the same thing. The additive factor for CUBIC is defined such that the result of AVG_AIMD(alpha_aimd, beta_aimd) for both AIMD like congestion controllers and Cubic is same. \r\n\r\nAfter making that comparison, the draft basically describes what alpha_aimd is equivalent to for Cubic and since it is represented using B_cubic on the right hand side, I don't think there is a need to define two different alpha_aimd.\r\n<img width=\"305\" alt=\"Screen Shot 2021-06-03 at 2 39 27 AM\" src=\"https://user-images.githubusercontent.com/10913828/120623819-ed074a00-c414-11eb-92a9-67e910aa8f77.png\">\r\n\r\n\r\n",
          "createdAt": "2021-06-03T09:40:58Z",
          "updatedAt": "2021-06-03T09:40:58Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@nsdyoshi does this address your comment?",
          "createdAt": "2021-06-03T10:52:46Z",
          "updatedAt": "2021-06-03T10:52:46Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry. my view is a bit different.\r\nIn Section 4.1.1, alpha_aimd is defined as a constant, which is around 0.529\r\nOTOH, alpha_aimd in Figure 3 is a variable. You can set arbitrary value to it.\r\n\r\nAt least, this is confusing to me. But, I'm fine to keep it if all other folks don't think in this way.\r\nI would like to hear other people's thought a bit more.\r\n\r\n",
          "createdAt": "2021-06-05T10:39:10Z",
          "updatedAt": "2021-06-05T10:39:10Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@Lars I am not sure if other folks are looking at these issues, what's the best way to get their opinion on this? ",
          "createdAt": "2021-06-08T02:37:11Z",
          "updatedAt": "2021-06-08T02:37:11Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@nsdyoshi Thanks, Yoshi. I can see that it is kind of confusing. Section 4.3 describes an analysis of an AIMD algorithm with parameters alpha and beta to explain why and how CUBIC determines its alpha value. We thought about introducing two more variables (alpha, and beta) explicitly for CUBIC, which seem more confusing (too many variables). ",
          "createdAt": "2021-06-08T02:40:59Z",
          "updatedAt": "2021-06-08T02:40:59Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "> @Lars I am not sure if other folks are looking at these issues, what's the best way to get their opinion on this? \n\nOn the list.",
          "createdAt": "2021-06-08T06:35:17Z",
          "updatedAt": "2021-06-08T06:35:17Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@nsdyoshi  I have sent this on the list. If no response is received, would you be fine with closing this issue as is?",
          "createdAt": "2021-06-10T03:45:08Z",
          "updatedAt": "2021-06-10T03:45:08Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "@goelvidhi yes, fine with me. But, I think we might want to set a certain deadline and notify people.",
          "createdAt": "2021-06-10T09:26:53Z",
          "updatedAt": "2021-06-10T09:26:53Z"
        },
        {
          "author": "chromi",
          "authorAssociation": "NONE",
          "body": "I think the explanation would be clearer if the formula for AVG_AIMD was rewritten using **unsuffixed** \u03b1 and \u03b2 parameters, \u03b1(aimd) and \u03b2(aimd) were used exclusively to refer to the Reno parameters, and \u03b1(cubic) and \u03b2(cubic) used to refer exclusively to the CUBIC parameters.\r\n\r\nThe process of calculating \u03b1(cubic) can then be explained as equalising the values of AVG_AIMD(\u03b1(aimd), \u03b2(aimd)) and AVG_AIMD(\u03b1(cubic), \u03b2(cubic)).",
          "createdAt": "2021-06-12T16:44:18Z",
          "updatedAt": "2021-06-12T16:44:18Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "I have opened a PR where I use alpha and beta for general equation and further derivation of alpha.\r\nLater I use alpha_cubic to refer to Cubic specifically. Feel free to review and provide comments on the PR.",
          "createdAt": "2021-06-15T08:50:47Z",
          "updatedAt": "2021-06-15T08:50:47Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "MDU6SXNzdWU5MDgwODI4MjM=",
      "title": "Description for P is required",
      "url": "https://github.com/NTAP/rfc8312bis/issues/65",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "lisongxu"
      ],
      "labels": [
        "WG LC"
      ],
      "body": "[Yoshi said](https://mailarchive.ietf.org/arch/msg/tcpm/W-t1q8q6Q0Ofjcp0iXOgmY18mr0):\r\n> 6: Section 4.3  The description for P is required for Figure 3.\r\n",
      "createdAt": "2021-06-01T09:12:22Z",
      "updatedAt": "2021-07-21T05:39:06Z",
      "closedAt": "2021-07-21T05:39:06Z",
      "comments": [
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, Yoshi, for catching it. P is the packet loss rate. We will describe it in the specification. Thanks",
          "createdAt": "2021-06-08T02:31:27Z",
          "updatedAt": "2021-06-08T02:31:27Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@lisongxu could you create a PR for this?",
          "createdAt": "2021-07-15T11:27:39Z",
          "updatedAt": "2021-07-15T11:27:39Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Working on it. Thanks\nLisong\n\n________________________________\nFrom: Lars Eggert ***@***.***>\nSent: Thursday, July 15, 2021 6:27 AM\nTo: NTAP/rfc8312bis ***@***.***>\nCc: Lisong Xu ***@***.***>; Mention ***@***.***>\nSubject: Re: [NTAP/rfc8312bis] Description for P is required (#65)\n\nNon-NU Email\n________________________________\n\n@lisongxu<https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_lisongxu&d=DwMCaQ&c=Cu5g146wZdoqVuKpTNsYHeFX_rg6kWhlkLF8Eft-wwo&r=8GgbmpxpPRnPS9z8_jUQhw&m=hcMhgdwOBPuTwpG61fOBY13UQ7mI13VPuCiB5MRhsKI&s=l-0PivoNWhk9aySMHAxwt2zB1egqX2-q0gphOW2HADM&e=> could you create a PR for this?\n\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub<https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_NTAP_rfc8312bis_issues_65-23issuecomment-2D880618050&d=DwMCaQ&c=Cu5g146wZdoqVuKpTNsYHeFX_rg6kWhlkLF8Eft-wwo&r=8GgbmpxpPRnPS9z8_jUQhw&m=hcMhgdwOBPuTwpG61fOBY13UQ7mI13VPuCiB5MRhsKI&s=U79LbXpEqYn6ypVHIEyhCh4nUlcn9aLUpNack52Gaps&e=>, or unsubscribe<https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_notifications_unsubscribe-2Dauth_ACPRVIMQPJI6IXT34VUXBODTX3A3NANCNFSM454HZOZQ&d=DwMCaQ&c=Cu5g146wZdoqVuKpTNsYHeFX_rg6kWhlkLF8Eft-wwo&r=8GgbmpxpPRnPS9z8_jUQhw&m=hcMhgdwOBPuTwpG61fOBY13UQ7mI13VPuCiB5MRhsKI&s=zsn9dfF3nCTMRJhnzd24at8z1ISaDb0-FzDSvSQRUHk&e=>.\n",
          "createdAt": "2021-07-15T16:16:26Z",
          "updatedAt": "2021-07-15T16:16:26Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "MDU6SXNzdWU5MDgwODMzOTI=",
      "title": "Analysis in [FHP00] doesn't include delayed ACK factor",
      "url": "https://github.com/NTAP/rfc8312bis/issues/66",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "lisongxu"
      ],
      "labels": [
        "WG LC"
      ],
      "body": "[Yoshi said](https://mailarchive.ietf.org/arch/msg/tcpm/W-t1q8q6Q0Ofjcp0iXOgmY18mr0):\r\n> 7: Section 4.3  I think The analysis in [FHP00] doesn't include delayed ACK factor. So, the AIMD TCP model here \r\n   can be a bit aggressive compared to a TCP that doesn't enable ABC and uses delayed ACK. \r\n  This is fine, but I think it might be good to clarify it.\r\n",
      "createdAt": "2021-06-01T09:13:00Z",
      "updatedAt": "2021-07-21T05:39:06Z",
      "closedAt": "2021-07-21T05:39:06Z",
      "comments": [
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, Yoshi. Yes, we can clarify this in the specification. ",
          "createdAt": "2021-06-08T02:27:55Z",
          "updatedAt": "2021-06-08T02:27:55Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@lisongxu could you create a PR for this?",
          "createdAt": "2021-07-15T11:27:22Z",
          "updatedAt": "2021-07-15T11:27:22Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure, working on it. Sorry for the delay.\nLisong\n\n________________________________\nFrom: Lars Eggert ***@***.***>\nSent: Thursday, July 15, 2021 6:27 AM\nTo: NTAP/rfc8312bis ***@***.***>\nCc: Lisong Xu ***@***.***>; Mention ***@***.***>\nSubject: Re: [NTAP/rfc8312bis] Analysis in [FHP00] doesn't include delayed ACK factor (#66)\n\nNon-NU Email\n________________________________\n\n@lisongxu<https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_lisongxu&d=DwMCaQ&c=Cu5g146wZdoqVuKpTNsYHeFX_rg6kWhlkLF8Eft-wwo&r=8GgbmpxpPRnPS9z8_jUQhw&m=8itWjWYYxX7tJjCUJLGzLZLzKJRebd3BCnYFz49lBJU&s=u_7Aabjrf69KQzvUs7STEWtZU0bwldtMkXN8yJ_b7rk&e=> could you create a PR for this?\n\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub<https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_NTAP_rfc8312bis_issues_66-23issuecomment-2D880617882&d=DwMCaQ&c=Cu5g146wZdoqVuKpTNsYHeFX_rg6kWhlkLF8Eft-wwo&r=8GgbmpxpPRnPS9z8_jUQhw&m=8itWjWYYxX7tJjCUJLGzLZLzKJRebd3BCnYFz49lBJU&s=BL_vXgMK_ulvdP77MbhDEJ8kpyZlWHrD5mWIa7YqhcI&e=>, or unsubscribe<https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_notifications_unsubscribe-2Dauth_ACPRVINXAIIPZ5WVTULUZR3TX3A2JANCNFSM454H2VLA&d=DwMCaQ&c=Cu5g146wZdoqVuKpTNsYHeFX_rg6kWhlkLF8Eft-wwo&r=8GgbmpxpPRnPS9z8_jUQhw&m=8itWjWYYxX7tJjCUJLGzLZLzKJRebd3BCnYFz49lBJU&s=383go1JfNiih-80bN0TcW_UDZhBsrGkFzxKBdHwfuDQ&e=>.\n",
          "createdAt": "2021-07-15T16:11:10Z",
          "updatedAt": "2021-07-15T16:11:10Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "MDU6SXNzdWU5MDgwODQ3NTY=",
      "title": "segments_acked rather than bytes_acked; cwnd in segments",
      "url": "https://github.com/NTAP/rfc8312bis/issues/67",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [
        "WG LC"
      ],
      "body": "[Yoshi said](https://mailarchive.ietf.org/arch/msg/tcpm/W-t1q8q6Q0Ofjcp0iXOgmY18mr0):\r\n>8: Section 4.3  I am not very sure why segments_acked is used rather than byted_acked here. What is the benefit of it?\r\n    How do we calculate when the acks are split? \r\n   Also, I think it should be clarified that cwnd is expressed in segments here in this case.\r\n",
      "createdAt": "2021-06-01T09:14:35Z",
      "updatedAt": "2021-07-15T09:52:39Z",
      "closedAt": "2021-07-15T09:52:39Z",
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "segments_acked is used throughout the document to match the linux code.\r\n\r\nSection 4.1.2 (https://datatracker.ietf.org/doc/html/draft-ietf-tcpm-rfc8312bis-02#section-4.1.2) defines the units for all variables including `cwnd` which is in segments.\r\n\r\n> How do we calculate when the acks are split?\r\nI am guessing that this problem has already been solved in linux.\r\n",
          "createdAt": "2021-06-03T10:09:34Z",
          "updatedAt": "2021-06-03T10:09:34Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@nsdyoshi does this address your comment?",
          "createdAt": "2021-06-03T10:52:25Z",
          "updatedAt": "2021-06-03T10:52:25Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Ok. I see the definition in cwnd. I'm sorry, I overlooked.\r\nBut, my main question is why segments_acked is used and byte_acked is not used.  I believe we don't need to follow linux code.\r\nSome implementations may want to use byted_acked. Is it allowed? I think it would be better to provide some guidance here.",
          "createdAt": "2021-06-04T09:15:22Z",
          "updatedAt": "2021-06-04T09:15:22Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, implementations can use bytes_acked. Does the below text suffice:\r\n> The unit of all window sizes in this document is segments of the\r\nmaximum segment size (MSS), and the unit of all times is seconds.",
          "createdAt": "2021-06-05T01:43:20Z",
          "updatedAt": "2021-06-05T01:43:20Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it would be better to mention using bytes_acked is acceptable for implementations explicitly. \r\n\r\nBTW, when a segments_acked implementation sent a 1000 byte packet and only 500 bytes were acked, does it use fractions or use some other methods? \r\nAnother question is if we count sacked segments into this or not.  ",
          "createdAt": "2021-06-06T11:29:47Z",
          "updatedAt": "2021-06-06T11:29:47Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> BTW, when a segments_acked implementation sent a 1000 byte packet and only 500 bytes were acked, does it use fractions or use some other methods?\r\n\r\nIf the size of each segment = 1 MSS, then segments_acked = bytes_acked / 1 MSS.\r\n\r\n> Another question is if we count sacked segments into this or not.\r\n\r\nGood question, is that being done for new Reno or other congestion controllers? I looked at a few RFCs and didn't find any mention of using SACK bytes for congestion window. Do you know if any document has guidance on this?\r\n",
          "createdAt": "2021-06-08T00:22:58Z",
          "updatedAt": "2021-06-08T00:23:07Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "> If the size of each segment = 1 MSS, then segments_acked = bytes_acked / 1 MSS.\r\nI was wondering the case where the size of segment is not 1 MSS or the case where the size of segment is 1 MSS, but the received ACK covers only part of the segment. It seems to me that this point is a bit ambiguous in the draft.\r\n\r\n> Good question, is that being done for new Reno or other congestion controllers?\r\n\r\nRight. It's described in RFC6582 and RFC6675. \r\nI've thought about this and I think the explanation of the draft on this point is sufficient.",
          "createdAt": "2021-06-13T11:15:49Z",
          "updatedAt": "2021-06-13T11:15:49Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> I was wondering the case where the size of segment is not 1 MSS or the case where the size of segment is 1 MSS, but the received ACK covers only part of the segment. It seems to me that this point is a bit ambiguous in the draft.\r\n\r\nIf I were to use segments_acked as an implementor, I would just do bytes_acked / 1 MSS, whatever may be the size of the segment sent or ACKed. For example if MSS = 1448 and 1000 byte segment was sent and acked, then segments_acked = 1000/1448 and if 500 bytes were acked, then segments_acked = 500/1448.\r\n\r\nIf OTOH I was using bytes_acked in my implementation, then all one needs to do multiple or divide by 1MSS wherever necessary. ",
          "createdAt": "2021-06-17T08:45:14Z",
          "updatedAt": "2021-06-17T08:45:14Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "OK. In this case, I think it would be better to mention segments_acked is float number and can be less than 1.\r\nAlso, I think it would be good to provide a guidance for an implementation uses bytes_acked instead of segments_acked.\r\nSomething like multiplying segment-based parameters by 1 MSS. ",
          "createdAt": "2021-06-18T08:58:20Z",
          "updatedAt": "2021-06-18T08:58:20Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "ok, please review #77.",
          "createdAt": "2021-06-22T09:22:32Z",
          "updatedAt": "2021-06-22T09:22:32Z"
        }
      ]
    },
    {
      "number": 68,
      "id": "MDU6SXNzdWU5MDgwODU1MjA=",
      "title": "Why a_aimd can be set to 1 ",
      "url": "https://github.com/NTAP/rfc8312bis/issues/68",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [
        "WG LC"
      ],
      "body": "[Yoshi said](https://mailarchive.ietf.org/arch/msg/tcpm/W-t1q8q6Q0Ofjcp0iXOgmY18mr0):\r\n>> 9: Section 4.3  \"Note that once _W_est_ reaches _W_max_, that is, _W_est_ >= _W_max_, ...\"\r\n>\r\n>   I might miss something, but I'm not sure why  a_aimd can be set to 1 to be compatible with AIMD TCP.\r\n   Does this mean b_cubic is also updated? If not, why this can be compatible?",
      "createdAt": "2021-06-01T09:15:30Z",
      "updatedAt": "2021-06-10T15:28:51Z",
      "closedAt": "2021-06-10T15:28:51Z",
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "This is discussed in https://github.com/NTAP/rfc8312bis/issues/2. Note that we have updated the AIMD friendly formula to make it byte based just like New Reno. We have also removed B_cubic. \r\n<img width=\"714\" alt=\"Screen Shot 2021-06-03 at 12 44 50 AM\" src=\"https://user-images.githubusercontent.com/10913828/120607311-ebce2100-c404-11eb-8957-0a04008f6d1f.png\">\r\n",
          "createdAt": "2021-06-03T07:46:25Z",
          "updatedAt": "2021-06-03T07:46:25Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@nsdyoshi does this address your comment?",
          "createdAt": "2021-06-03T08:29:23Z",
          "updatedAt": "2021-06-03T08:29:23Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry.. it's still not clear to me. I'm wondering the following 2 points. \r\n\r\n- It seems to me that W_est has two phases in cwnd increasing. But, I believe this kind of behavior doesn't exist in Reno. I'm not sure why it has to have two phases.\r\n- if setting a_aimd to 1 is compatible with AIMD TCP,  a_aimd = 3 * (1-b_cubic) / (1+b_cubic) is not compatible with AIMD TCP?\r\n",
          "createdAt": "2021-06-04T08:15:36Z",
          "updatedAt": "2021-06-04T08:15:36Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> It seems to me that W_est has two phases in cwnd increasing. But, I believe this kind of behavior doesn't exist in Reno. I'm not sure why it has to have two phases.\r\n\r\nTwo phases because after loss, Cubic reduces its congestion window to 0.7x while New Reno reduces it to 0.5x. To have the same increase curve in AIMD friendly region, for Cubic, Alpha_aimd is < 1\r\n\r\n>if setting a_aimd to 1 is compatible with AIMD TCP, a_aimd = 3 * (1-b_cubic) / (1+b_cubic) is not compatible with AIMD TCP?\r\n\r\nThis is again the same reasoning. Before the cwnd reaches W_max, Cubic needs to be more conservative so alpha_aimd = 0.529 instead of 1. After we have reached the previous cwnd, i.e. W_max, Cubic can have the same alpha_aimd (i.e. 1) as New Reno has.\r\n",
          "createdAt": "2021-06-05T01:47:47Z",
          "updatedAt": "2021-06-05T01:47:57Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm. I'm not sure about it.\r\n\r\nIn my understanding, alpha_aimd = 0.529 is chosen because AMID(1, 0.5) =AIMD(0.529, 0.7). \r\nIf you change it to 1, it will be AIMD(1, 0.7) which is more aggressive than AIMD(1, 0.5)\r\n",
          "createdAt": "2021-06-05T10:39:13Z",
          "updatedAt": "2021-06-05T10:39:13Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "The throughput model of AIMD(alpha, beta) assumes a deterministic loss model where a packet is lost every time when the cwnd reaches w_max. \r\n\r\nThe \"a_aimd can be set to 1\" is proposed to clearly describe the behavior of CUBIC when cwnd > w_max.\r\n",
          "createdAt": "2021-06-08T02:23:30Z",
          "updatedAt": "2021-06-08T02:23:30Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "I had explained this in the last IETF meeting. Here is the diagram I used. For low BDPs when we use the AIMD friendly equation, alpha_aimd = 0.529 only has meaning until we reach W_max. After that New Reno and Cubic should behave the same. Otherwise, Cubic will have slower growth than New Reno.\r\n<img width=\"939\" alt=\"Screen Shot 2021-06-07 at 7 31 34 PM\" src=\"https://user-images.githubusercontent.com/10913828/121113499-fd2d7980-c7c6-11eb-89a8-a147557c8128.png\">\r\n",
          "createdAt": "2021-06-08T02:32:35Z",
          "updatedAt": "2021-06-08T02:33:11Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "OK. I understand the concept. Thank you so much. But, It seems to me the sentence looks a bit confusing. \r\nI am thinking about something like the below, but there might be better descriptions for this.\r\n\r\nNote that once _W_est_ reaches _W_max_, that is, _W_est_ >= _W_max_,\r\n \u03b1__aimd_ SHOULD be set to 1 because we don't know what new W_max will be at this point.\r\nThis ensures CUBIC to achieve the same congestion window increment as AIMD TCP.",
          "createdAt": "2021-06-09T09:41:20Z",
          "updatedAt": "2021-06-09T09:41:20Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you, Yoshi, for your suggestion!",
          "createdAt": "2021-06-09T14:19:23Z",
          "updatedAt": "2021-06-09T14:19:23Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "MDU6SXNzdWU5MDgwODYxOTA=",
      "title": "Overridden by linear growth by AIMD",
      "url": "https://github.com/NTAP/rfc8312bis/issues/69",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [
        "WG LC"
      ],
      "body": "[Yoshi said](https://mailarchive.ietf.org/arch/msg/tcpm/W-t1q8q6Q0Ofjcp0iXOgmY18mr0):\r\n>> 10: Section 4.5: \" The convex profile ensure that the window increases very slowly at the beginning..\"\r\n>\r\n>   I am wondering how much this part is accurate. Because of Principal 2,  even though cwnd is increased \r\n   through convex profile, I think it will be overridden by linear growth by AIMD. ",
      "createdAt": "2021-06-01T09:16:17Z",
      "updatedAt": "2021-06-22T07:20:03Z",
      "closedAt": "2021-06-22T07:20:03Z",
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "According to principle 2,\r\n> A congestion control algorithm designed to be friendly to AIMD TCP on\r\n>   a per-flow basis must increase its congestion window less\r\n>  aggressively in small BDP networks than in large BDP networks.\r\n\r\nCUBIC uses AIMD friendly equation for small BDPs, which means that it doesn't use the cubic curve in those scenarios.\r\nAnd AIMD algorithms like New Reno don't scale well in large BDPs.",
          "createdAt": "2021-06-03T10:05:16Z",
          "updatedAt": "2021-06-03T10:05:16Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@nsdyoshi does this address your comment?",
          "createdAt": "2021-06-03T10:52:08Z",
          "updatedAt": "2021-06-03T10:52:08Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Please let me explain a bit more.\r\n\r\nFrom Section 3.2\r\n> Furthermore, in cases when the cubic function of CUBIC would increase\r\n   the congestion window less aggressively than AIMD TCP, CUBIC simply\r\n   follows the window size of AIMD TCP to ensure that CUBIC achieves at\r\n   least the same throughput as AIMD TCP in small-BDP networks. \r\n\r\nFrom Section 4.3\r\n> CUBIC checks whether W_cubic(_t_)\r\n   is less than _W_est_. If so, CUBIC is in the AIMD-friendly region and\r\n   _cwnd_ SHOULD be set to _W_est_ at each reception of an ACK.\r\n\r\nIn my understanding,  w_cubic and w_est behave like this (well, this graph is not very precise as W_est will not be a straight line in the draft)\r\nAround W_max, w_cubic's window growth is small as it uses cubic function, but it will be overridden by W_est if we are following the logic described in the draft. This behavior is fine for me, but I think the description: \"very slowly\" in Section 4.5 is not very accurate because it is the same level as Reno.\r\nPlease point out if I overlook something here.\r\n\r\n![image](https://user-images.githubusercontent.com/73777040/120773757-7cc0fd00-c4d6-11eb-9d62-357562f740cf.png)\r\n",
          "createdAt": "2021-06-04T09:05:04Z",
          "updatedAt": "2021-06-04T09:05:04Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think you are mixing up two different things.\r\n\r\nSection 3.2 is talking about AIMD friendliness in Low BDP networks and that has nothing to do with how convex part of Cubic curve starts with a slow increase. That section is about, in low BDP networks, the max. window size attained by Cubic is generally low and that's why after a loss, AIMD like growth would be higher than cubic curve (even for concave).\r\n\r\nSection 4.5 is talking about, when cubic is NOT in AIMD friendly region, i.e. cwnd > W_est, and cwnd > W_max, then we use the convex curve. This would happen for high BDP networks. Although this convex increase would be greater than New Reno but it would be increasing slowly with respect to the cubic curve around W_max to probe for the new peak bandwidth and in most cases, Cubic will incur a loss soon and exit the convex phase.",
          "createdAt": "2021-06-05T04:52:17Z",
          "updatedAt": "2021-06-05T04:53:37Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm. It seems to me that you are explaining Section 4.5 is talking about the right side of the pink line in the figure. \r\nBut, I'm not very sure about it. Because at this point, cwnd is already over W_max, there is no need to be careful from my point of view. \r\n\r\nIn this case, I think the following sentences in the section is not applicable. It doesn't look carefully or very slowly to me.\r\n\r\n>In this region, CUBIC is very careful.  The convex profile ensures\r\n   that the window increases very slowly at the beginning and gradually\r\n   increases its increase rate.   \r\n\r\n\r\n\r\n![image](https://user-images.githubusercontent.com/73777040/120888219-fc6ccb80-c5ab-11eb-8d34-c7603878f57f.png)\r\n",
          "createdAt": "2021-06-05T10:38:58Z",
          "updatedAt": "2021-06-05T10:38:58Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@nsdyoshi  Thanks, Yoshi! Your figure is kind of misleading in that both the green curve (W_cubic) and orange line (W_est) pass W_max at the same time. In high-speed networks, the orange line increases very slowly and passes W_max much later than the green curve.  I added a new orange line in your figure to illustrate that. \r\n\r\n![120888219-fc6ccb80-c5ab-11eb-8d34-c7603878f57f](https://user-images.githubusercontent.com/10427041/121112213-ba26d280-c7d5-11eb-9bf9-78fafcdfcf11.png)\r\n",
          "createdAt": "2021-06-08T02:18:05Z",
          "updatedAt": "2021-06-08T02:18:05Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Section 4.5 talks about this scenario - in high BDP networks, the AIMD growth is very slow and it take a lot of RTTs to recover to W_max. So, cubic curve - concave then convex is used where convex would increase slowly around W_max. Something like this (plotted using actual values):\r\n\r\n<img width=\"754\" alt=\"Screen Shot 2021-06-07 at 7 26 51 PM\" src=\"https://user-images.githubusercontent.com/10913828/121113123-577a0a80-c7c6-11eb-969e-6e9aa4065427.png\">\r\n\r\n",
          "createdAt": "2021-06-08T02:27:07Z",
          "updatedAt": "2021-06-08T02:29:10Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, I saw Lisong's comment after I posted. But yes, we are both saying the same thing",
          "createdAt": "2021-06-08T02:28:10Z",
          "updatedAt": "2021-06-08T02:28:10Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, It's true for high BDP network case. But, I was thinking about small BDP network case. It seems to me that Section 4.5 doesn't talk about high BDP cases only. Because, even small BDP network cases will have convex region.\r\n\r\nIn small BDP case, I think w_est grows lot faster and the beginning of concave region will be overridden by it and convex region will start when cwnd becomes  lots bigger than w_max. \r\nIn this situation, I'm not very sure to say \"window increases very slowly at the beginning\" \r\n\r\nI am thinking that the explanation something like this might describe the behavior more accurately.\r\n\r\nUnless it is not overridden by AIMD window increase, CUBIC is very careful in this region.  \r\nThe convex profile aims that the window increases very slowly at the beginning and gradually increases its increase rate. ",
          "createdAt": "2021-06-13T11:15:16Z",
          "updatedAt": "2021-06-13T11:15:16Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@nsdyoshi I was able to plot the graph you initially posted with some sample values (W_max = 100, cwnd_start = 70, RTT = 75ms).\r\n<img width=\"711\" alt=\"Screen Shot 2021-06-17 at 12 51 28 AM\" src=\"https://user-images.githubusercontent.com/10913828/122354787-2e642300-cf06-11eb-988e-02f52c307b1c.png\">\r\n\r\nSection 4.5 starts with \r\n> When receiving an ACK in congestion avoidance, if CUBIC is not in the\r\nAIMD-friendly region and *cwnd* is larger than or equal to\r\n*W<sub>max</sub>*, then CUBIC is in the convex region.\r\n\r\nIMO, this clarifies in the very beginning that this section talks about when we are not in overridden by AIMD. \r\n\r\n",
          "createdAt": "2021-06-17T07:52:47Z",
          "updatedAt": "2021-06-17T08:16:04Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "right. but, when I look at the picture you've shown, the concave region starts at the point where cwnd is way bigger than w_max.\r\nIn this case, I'm not sure if the following description of the concave region is accurate. \r\nI think it would be good if we can provide more explanations here.\r\n\r\n> In this region, CUBIC is very careful.  The convex profile ensures\r\n   that the window increases very slowly at the beginning and gradually\r\n   increases its increase rate. ",
          "createdAt": "2021-06-18T08:14:37Z",
          "updatedAt": "2021-06-18T08:14:37Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, Yoshi.  That \"very slowly\" is about the behavior of cubic in the convex region, which is defined in Section 4.2 \"The concave region, if CUBIC is not in the AIMD-friendly region and cwnd is less than Wmax. The convex region, if CUBIC is not in the AIMD-friendly region and cwnd is greater than Wmax.\" ",
          "createdAt": "2021-06-18T20:19:34Z",
          "updatedAt": "2021-06-18T20:20:12Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm. sorry. I meant convex region.\r\nI quoted the texts from Section 4.5. So, it should describe the behavior of cubic in the convex region. \r\nThe 'very careful' and 'very slowly' describes the behavior of cubic well when BDP is large. (as shown in the first figure Vidhi put) \r\nHowever, I think this description is not very accurate when BDP is small (as shown in the second figure from Vidhi) \r\nThat's why I am thinking it might be good to add some more explanations here.",
          "createdAt": "2021-06-19T10:00:40Z",
          "updatedAt": "2021-06-19T10:00:40Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Both the 'very careful' and 'very slowly' describe the behavior of the convex/concave regions (that is, the behavior of the blue line).  If the green line is above the blue line, then CUBIC does not enter the convex or concave regions. Hope this helps.\r\n",
          "createdAt": "2021-06-19T14:19:46Z",
          "updatedAt": "2021-06-19T14:19:46Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Lisong, \r\n\r\nIn my thoughts, convex region starts when cwnd >= w_max and it's not in TCP friendly region. So, I thought the starting point of the convex region is the red dot in the following figure.\r\n\r\n![image](https://user-images.githubusercontent.com/73777040/122666467-3ae4b780-d162-11eb-9f5d-48685ecfb58c.png)\r\n\r\nBut, I am guessing you consider the starting point of the convex region is always cwnd = w_max. But, when cwnd_cubic < w_est, CUBIC is not in the region. (Please correct me if I miss something here)\r\n\r\nIn my reading of the draft, I think both interpretations are possible. I believe it would be good if we can eliminate ambiguity here.",
          "createdAt": "2021-06-20T08:15:13Z",
          "updatedAt": "2021-06-20T08:26:33Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> In my thoughts, convex region starts when cwnd >= w_max and it's not in TCP friendly region.\r\n\r\n@nsdyoshi you are right and this is what the draft mentions in Section 4.5\r\n\r\n> So, I thought the starting point of the convex region is the red dot in the following figure. \r\n\r\nCubic is in convex region at this red dot even if the convex profile starts at cwnd = W_max.\r\n\r\nPerhaps you are concerned about the below line and now I fully understand your concern. Although the intro in Section 4.5 says that Cubic starts at red dot, the below line is a bit contradictory as it probably assumes that Cubic will always be in convex region around W_max.\r\n> In this region, CUBIC is very careful. The convex profile ensures that the window increases very slowly at the beginning and gradually increases its increase rate. \r\n\r\nCombining your earlier suggestion with a minor modification, how about this:\r\n> Unless it is not overridden by AIMD window increase, CUBIC is very careful in this region. The convex profile aims that the window increases very slowly at the beginning when the cwnd is around W_max and then gradually increases its increase rate.\r\n",
          "createdAt": "2021-06-20T09:24:31Z",
          "updatedAt": "2021-06-20T09:26:10Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Yoshi, Finally I see the confusion. Thank you!\r\n\r\nHi Vidhi, \"Unless it is not overridden by AIMD window increase, CUBIC is very careful in this region\" should be \"Unless it is overridden by AIMD window increase, CUBIC is very careful in this region\"? Thank you!\r\n\r\n",
          "createdAt": "2021-06-20T14:25:27Z",
          "updatedAt": "2021-06-20T14:25:27Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Vidhi,\r\nThanks for the updates. I think we will need to update it as Lisong suggested, but other than that, it works for me.\r\nThanks for pointing out, Lisong!",
          "createdAt": "2021-06-21T05:56:02Z",
          "updatedAt": "2021-06-21T05:56:02Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks. Fixed it in #76 ",
          "createdAt": "2021-06-21T21:48:57Z",
          "updatedAt": "2021-06-21T21:48:57Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "MDU6SXNzdWU5MDgwODY4MTI=",
      "title": "Keeping w_max and reducing only cwnd",
      "url": "https://github.com/NTAP/rfc8312bis/issues/70",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [
        "WG LC"
      ],
      "body": "[Yoshi said](https://mailarchive.ietf.org/arch/msg/tcpm/W-t1q8q6Q0Ofjcp0iXOgmY18mr0):\r\n>>11: Section 4.7: \"we update w_max as follows, before the window reduction as described in section 4.6\"\r\n>\r\n>   I am wondering if reducing w_max is the right approach here. Because if we reduce w_max, CUBIC\r\n   can exit from convex region earlier than the case where fast convergence is not used. \r\n   It seems to me that keeping w_max and reducing only cwnd (using smaller value than b_cubic) \r\n   look more conservative. ",
      "createdAt": "2021-06-01T09:17:01Z",
      "updatedAt": "2021-06-07T08:20:18Z",
      "closedAt": "2021-06-07T08:20:17Z",
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> [Yoshi said](https://mailarchive.ietf.org/arch/msg/tcpm/W-t1q8q6Q0Ofjcp0iXOgmY18mr0):\r\n> \r\n> > > 11: Section 4.7: \"we update w_max as follows, before the window reduction as described in section 4.6\"\r\n> > \r\n> > \r\n> > I am wondering if reducing w_max is the right approach here. Because if we reduce w_max, CUBIC\r\n> > can exit from convex region earlier than the case where fast convergence is not used.\r\n> > It seems to me that keeping w_max and reducing only cwnd (using smaller value than b_cubic)\r\n> > look more conservative.\r\n\r\nDid you mean that it will exit the concave region earlier, and yes that's the intention. The point is to increase the time for this flow to increase its congestion window in order to release bandwidth to any potential new flows. In the below figure, the S curve is due to fast convergence by reducing W_max and you can see that it takes longer to grow congestion window that way as the flow will switch to convex side faster.\r\n![Cubic_curve](https://user-images.githubusercontent.com/10913828/120626158-3f496a80-c417-11eb-83be-60922e78a32c.png)\r\n\r\n\r\n",
          "createdAt": "2021-06-03T09:57:29Z",
          "updatedAt": "2021-06-03T09:57:29Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@nsdyoshi does this address your comment?",
          "createdAt": "2021-06-03T10:51:54Z",
          "updatedAt": "2021-06-03T10:51:54Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "I did some comparisons for this. The green line is the w_cubic without fast convergence. The blue line is the w_cubic with fast convergence proposed in the draft. The red line is the one I proposed.\r\n\r\nAs you can see, the blue line is more conservative when cwnd is closed to w_max while it's a little bit more aggressive than w_cubic without fast convergence when cwnd is very high. \r\nMy proposed method is not very conservative when cwnd is closed to w_max while it's a bit conservative when cwnd is very high. \r\n\r\nI think the behavior of current fast convergence algorithm is much better than what I proposed. \r\nAlthough It becomes a bit aggressive when cwnd is very high, I personally think this point is not very important.\r\n\r\n![image](https://user-images.githubusercontent.com/73777040/120921805-5936b780-c67a-11eb-8362-5a97d15304c3.png)\r\n",
          "createdAt": "2021-06-06T11:29:34Z",
          "updatedAt": "2021-06-06T11:29:34Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@nsdyoshi ok, so can this issue be closed with no action?",
          "createdAt": "2021-06-07T06:37:36Z",
          "updatedAt": "2021-06-07T06:37:36Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, I'm fine with it.",
          "createdAt": "2021-06-07T07:42:29Z",
          "updatedAt": "2021-06-07T07:42:29Z"
        }
      ]
    },
    {
      "number": 71,
      "id": "MDU6SXNzdWU5MDgwODczOTc=",
      "title": "Results are based on the algorithms",
      "url": "https://github.com/NTAP/rfc8312bis/issues/71",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "lisongxu"
      ],
      "labels": [
        "WG LC"
      ],
      "body": "[Yoshi said](https://mailarchive.ietf.org/arch/msg/tcpm/W-t1q8q6Q0Ofjcp0iXOgmY18mr0):\r\n>12: Section 5.2 and Section 5.3. Do these results are based on the algorithms and the parameter values \r\n   described in the draft?  If there're differences, I think it should be described. \r\n",
      "createdAt": "2021-06-01T09:17:41Z",
      "updatedAt": "2021-07-19T07:42:56Z",
      "closedAt": "2021-07-19T07:42:56Z",
      "comments": [
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@nsdyoshi Thanks, Yoshi. I guess you refer to the tables in Sections 5.1 and 5.2. Yes they are calculated for the algorithm and parameters described in the draft, and the source code to generate these tables is available on the github. ",
          "createdAt": "2021-06-08T02:02:30Z",
          "updatedAt": "2021-06-08T02:02:30Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@nsdyoshi is there any action item here?",
          "createdAt": "2021-06-22T02:52:17Z",
          "updatedAt": "2021-06-22T02:52:17Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh. sorry. I forgot to reply this one. If there's no difference, it's fine for me. \r\nIn my understanding, the CUBIC in the original paper uses b_cubic=0.8. So, I thought if the values in the tables were created when the paper was written, the values might not be very accurate.\r\n",
          "createdAt": "2021-06-22T08:31:25Z",
          "updatedAt": "2021-06-22T08:32:00Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "We should probably say that these values are for the current version of CUBIC.",
          "createdAt": "2021-06-22T10:13:33Z",
          "updatedAt": "2021-06-22T10:13:33Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, the tables have been updated, and source code to generate the tables is available on github. Thanks",
          "createdAt": "2021-06-22T13:14:29Z",
          "updatedAt": "2021-06-22T13:14:29Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Propose to close with no action. OK, @nsdyoshi?",
          "createdAt": "2021-07-15T11:26:56Z",
          "updatedAt": "2021-07-15T11:26:56Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm fine with no action.",
          "createdAt": "2021-07-18T09:35:23Z",
          "updatedAt": "2021-07-18T09:35:23Z"
        }
      ]
    },
    {
      "number": 83,
      "id": "MDU6SXNzdWU5ODM1NjI4OTQ=",
      "title": "Lower bound for congestion window (drops or classic ECN)",
      "url": "https://github.com/NTAP/rfc8312bis/issues/83",
      "state": "CLOSED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [],
      "body": "Markku Kojo said,\r\n>The draft modifies RFC 3168 when ECE arrives and would result\r\n  in cwnd < 2 MSS by setting a lower bound of 2 MSS for cwnd (only\r\n  ssthresh is supposed to have a lower bound of 2 MSS).\r\n  This is in conflict with RFC 3168, RFC 5033, and RFC 2914 which\r\n  require \"full backoff\", that is, a sender must continue decreasing\r\n  sending rate as long as congestion persists. This is a fundamental\r\n  property for any congestion control mechanism. For ECN, RFC 3168\r\n  (sec 6.1.2) requires that cwnd is halved until the minimum cwnd\r\n  of one MSS is received, and then the sender continues reducing\r\n  sending rate by using a timer with exponential backoff, if more\r\n  ECE-echo packets keep on arriving.\r\n>\r\n>  This implementation bug has been long with Linux and is present\r\n  in other stacks as well and should get corrected ASAP with\r\n  appropriate advise in all published RFCs, instead of replicating\r\n  the bug in the RFC series.",
      "createdAt": "2021-08-31T08:01:18Z",
      "updatedAt": "2021-10-22T12:59:34Z",
      "closedAt": "2021-10-22T12:59:34Z",
      "comments": [
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Where are we with this one?",
          "createdAt": "2021-10-11T07:32:47Z",
          "updatedAt": "2021-10-11T07:32:47Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "MDU6SXNzdWU5ODM1Njk2MjI=",
      "title": "RFC 8311 updates sender's response to CE / ECE",
      "url": "https://github.com/NTAP/rfc8312bis/issues/84",
      "state": "CLOSED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [],
      "body": "Markku Kojo said,\r\n> RFC 8311 (sec 4.1) allows modifying the TCP-sender response to\r\n  ECE for experimental purposes only. Has there been any discussion\r\n  with tsvwg in that modifying the TCP-response to ECE in CUBIC is\r\n  conflict with RFC 8311 as CUBIC is currently intended to become\r\n  a Standards Track RFC?",
      "createdAt": "2021-08-31T08:08:32Z",
      "updatedAt": "2021-11-01T09:49:17Z",
      "closedAt": "2021-11-01T09:49:17Z",
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@markkukojo CUBIC follows RFC 3168's below requirement,\r\n> The indication\r\n   of congestion should be treated just as a congestion loss in non-\r\n   ECN-Capable TCP.\r\n\r\nSure, it doesn't half the congestion window but the response to classic ECN is to behave same as loss.\r\nOTOH, RFC 8311 intends to allow experiments that treat CE markings different from loss by free'ing up the ECT(1) IP code-point. As CUBIC treats ECE flag and packet loss in the same way, it doesn't have anything to do with RFC 8311.",
          "createdAt": "2021-09-14T07:19:06Z",
          "updatedAt": "2021-09-14T07:19:16Z"
        },
        {
          "author": "bbriscoe",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree. The scope of RFC8311 is solely changes to ECN, whereas RFC8312bis changes the response to drop, and consequently also the response to ECN in order to continue to comply with stds track [RFC3168 \u00a75](https://datatracker.ietf.org/doc/html/rfc3168#section-5):\r\n>   Upon the receipt by an ECN-Capable transport of a single CE packet,\r\n>   the congestion control algorithms followed at the end-systems MUST be\r\n>   essentially the same as the congestion control response to a *single*\r\n>   dropped packet.  For example, for ECN-Capable TCP the source TCP is\r\n>   required to halve its congestion window for any window of data\r\n>   containing either a packet drop or an ECN indication.\r\n\r\nThe first sentence gives the normative requirement. The second sentence isn't normative, because later RFC3168 says it assumes the standard congestion response is defined elsewhere; specifically \u00a76.1 of RFC3168 says:\r\n>  We assume that the source TCP uses the standard congestion\r\n>   control algorithms of Slow-start, Fast Retransmit and Fast Recovery\r\n>   [RFC2581]. \r\n\r\nTherefore, it would be compatible with RFC3168 for a sender to follow the congestion response of a different stds track RFC, such as the one RFC8312bis will define.\r\n\r\nRFC3168 mentions the halving again later, and again doesn't make it normative, but does define a normative bound on the response (that it MUST not increase), see [RFC3168 \u00a76.1.2](https://datatracker.ietf.org/doc/html/rfc3168#section-6.1.2):\r\n>  The indication\r\n>   of congestion should be treated just as a congestion loss in non-\r\n>   ECN-Capable TCP. That is, the TCP source halves the congestion window\r\n>   \"cwnd\" and reduces the slow start threshold \"ssthresh\".  The sending\r\n>   TCP SHOULD NOT increase the congestion window in response to the\r\n>   receipt of an ECN-Echo ACK packet.\r\n\r\nFinally, even if RFC8311 were relevant, when it updates \u00a75 of RFC3168 (quoted above) by adding:\r\n>  unless otherwise\r\n>   specified by an Experimental RFC in the IETF document stream\r\n\r\n...that merely allows experimental RFCs to define different congestion responses without having to update RFC3168 (because an exp track RFC cannot update a stds track RFC). That is the stated purpose of RFC8311. It doesn't need to say that a stds track RFC can update RFC3168, because nothing prevents the IETF updating a stds track RFC with another stds track RFC.\r\n\r\nAssuming I'm correct, I suggest this issue is just closed with no action.\r\n",
          "createdAt": "2021-09-15T07:52:49Z",
          "updatedAt": "2021-09-15T09:42:51Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@markkukojo do you agree to close with no action based on the above?",
          "createdAt": "2021-09-15T14:49:34Z",
          "updatedAt": "2021-09-15T14:49:34Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@markkukojo ping?",
          "createdAt": "2021-10-11T07:31:56Z",
          "updatedAt": "2021-10-11T07:31:56Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "> ...that merely allows experimental RFCs to define different congestion responses without having to update RFC3168 (because an exp track RFC cannot update a stds track RFC). That is the stated purpose of RFC8311. It doesn't need to say that a stds track RFC can update RFC3168, because nothing prevents the IETF updating a stds track RFC with another stds track RFC.\r\n\r\nSure, a stds track RFC can update RFC3168. I might be wrong but my understanding was that TSVWG at this time is not ready to see other than experimental modifications to  RFC 3168? \r\n\r\nIn particular, when there is little or no experimental results to support a stds track update; as Bob has recently testified that there has been hardly any ECN enabled routers in the Internet, the long deployment experience cannot include experience on modified ECN response. At the same time, RFC 8511 (ABE) documents findings saying that positive results with a larger MD factor were found only when the sender is in CA. This does not support using a larger MD factor when an ECN capable sender is in slow start.\r\n\r\nI'd leave this for tcpm wg chairs to discuss with tsvwg chairs.\r\n\r\n\r\nNits on what is normative text. \r\n\r\nRFC 2119 (the one that was valid at the time RFC 3186 was published): \r\n  These words are often capitalized.\r\n\r\nRFC 8174:\r\n  These words can be used as defined here, but using them is not\r\n  required.  Specifically, normative text does not require the use\r\n  of these key words.  They are used for clarity and consistency\r\n  when that is what's wanted, but a lot of normative text does not\r\n  use them and is still normative.",
          "createdAt": "2021-10-15T02:04:05Z",
          "updatedAt": "2021-10-15T02:04:05Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@markkukojo based on what you write, I still don't understand if we can close this issue with no action, or else, what changes you want to see in the document.",
          "createdAt": "2021-10-15T06:50:24Z",
          "updatedAt": "2021-10-15T06:50:24Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": ">In particular, when there is little or no experimental results to support a stds track update; as Bob has recently testified that there has been hardly any ECN enabled routers in the Internet, the long deployment experience cannot include experience on modified ECN response. At the same time, RFC 8511 (ABE) documents findings saying that positive results with a larger MD factor were found only when the sender is in CA. This does not support using a larger MD factor when an ECN capable sender is in slow start.\r\n\r\nThe second statement is a bit of a contradiction of the first. If we can't believe the long deployment experience of CUBIC for ECN, then how can we believe RFC 8511's findings about large MD factor during CA.",
          "createdAt": "2021-10-16T06:17:53Z",
          "updatedAt": "2021-10-16T06:17:53Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "No answer from @markkukojo, closing.",
          "createdAt": "2021-11-01T09:49:17Z",
          "updatedAt": "2021-11-01T09:49:17Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "MDU6SXNzdWU5ODM1NzQ3Mzg=",
      "title": "RFC 8511 handling of ECE signal (slow start vs congestion avoidance)",
      "url": "https://github.com/NTAP/rfc8312bis/issues/85",
      "state": "CLOSED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [],
      "body": "Markku Kojo said,\r\n> ABE (RFC 8511) is currently the only experimental RFC to modify\r\n  the TCP-sender response to ECE. ABE allows modifying multiplicative\r\n  decrease factor only for AIMD TCP and only when ECE arrives in\r\n  congestion avoidance, that is, not when the sender is in slow-start.\r\n>\r\n>  Applying a decrease factor of 0.7 (or higher) when a congestion\r\n  singnal arrives and ends the initial slow start would be\r\n  inconsiderate because it extends the convergence time from\r\n  the slow-start overshoot. ABE has found that using a larger decrease\r\n  factor yields performance improvement when applied in congestion\r\n  avoidance, but not otherwise. Do we have data that would support\r\n  different findings with CUBIC?",
      "createdAt": "2021-08-31T08:13:28Z",
      "updatedAt": "2021-11-22T01:42:56Z",
      "closedAt": "2021-10-25T11:50:01Z",
      "comments": [
        {
          "author": "bbriscoe",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Markku raises a good question about how large the first reduction should be to come out of the flow-startup phase. Most cubic implementations resolve this by using a start-up algo that intends to overshoot by less than 2x, so that a reduction of 30% will usually be sufficient without another round.\r\n\r\n[\u00a7 4.10 of the rfc8312bis draft](https://datatracker.ietf.org/doc/html/draft-ietf-tcpm-rfc8312bis#section-4.10) mentions LSS, Hystart and standard RFC5681 SS.\r\n\r\nIf the draft did not mention RFC5681 slow-start as an option, I think this would resolve the matter (given I believe no Cubic implementations use it). It also ought to list the Hystart++ draft as the first option, given it is currently adopted  for the stds track, so it has potentially higher IETF 'status' than LSS (EXP) or Hystart (research paper).",
          "createdAt": "2021-09-15T08:21:38Z",
          "updatedAt": "2021-09-15T08:21:38Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@bbriscoe Has Hystart++ been adopted (stds track), I thought this was a verbal consensus in last IETF (111).\r\n\r\nI can rearrange the order starting with Hystart++, then LSS. As Hystart++ is an update to Hystart paper, I think we should mention it some way - not sure how. \r\nRegarding mentioning 5681, I think there are some implementations that still use it, it doesn't mean that's the right thing to put in a RFC. But currently, 5681 is the only approved standards track RFC. So, maybe we can keep that and mention the overshoot issue that comes with it.",
          "createdAt": "2021-09-15T16:25:23Z",
          "updatedAt": "2021-09-15T16:25:43Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "https://datatracker.ietf.org/doc/draft-ietf-tcpm-hystartplusplus/ exists and says `Intended status: Standards Track` in the document. But the datatracker doesn't have that reflected (yet). ",
          "createdAt": "2021-09-15T16:54:35Z",
          "updatedAt": "2021-09-15T16:54:35Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Please check #111, which intends to address this issue and #90",
          "createdAt": "2021-09-16T12:37:26Z",
          "updatedAt": "2021-09-16T12:37:26Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, this is a dup of #90 ",
          "createdAt": "2021-09-21T08:32:13Z",
          "updatedAt": "2021-09-21T08:32:13Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Leaving this open until the PR #111  gets merged.",
          "createdAt": "2021-09-21T08:35:35Z",
          "updatedAt": "2021-09-21T08:35:35Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "> Markku raises a good question about how large the first reduction should be to come out of the flow-startup phase. Most cubic implementations resolve this by using a start-up algo that intends to overshoot by less than 2x, so that a reduction of 30% will usually be sufficient without another round.\r\n>\r\nThis logic above seems to assume that a start-up algo (e.g., Hystart++) never fails. That is, it always exits slow start before the first congestion signal (drop or ECE), resulting in no or some number of drops. If a TCP sender still is in slow start when congestion is signalled, it means that the overshoot detection has failed and everything occurred just like without such an algo.\r\nAt least in such a case the TCP sender should not apply reduction other than 0.5. I cannot speak for Van Jacobson but I believe that the selection of the MD factor (0.5) was no coincidence but carefully selected to match with the maximum cwnd increase during slow start (double cwnd in each RTT) as otherwise it would result in an intentional overloading of the bottleneck immediately after the congestion event!\r\n\r\nSo, even if HyStart++ or any such algo is in use, we should not use a decrease factor larger than 0.5 if the TCP sender still is in slow start when congestion event occurs. And, even though I didn't mention it, this should be applied always with slow start, not only to initial slow start.\r\n\r\nWith Hystart++ we may distinguish between 3 major cases:\r\n1) The algo succeeds ideally and exits early early enough to avoid any pkt losses (or ECE signal).\r\n     This case does not need MD, so everything is fine.\r\n\r\n2) The algo fails to detect overshoot and exit slow start before a pkt loss is detected (or ECE arrives), i.e., the TCP sender is in slow start when congestion is signalled. In this case, a MD factor larger than 0.5 should not be used.\r\n\r\n3) The algo detects overshoot and exits slow start before the first pkt loss is detected (or ECE arrives) but cannot avoid losses (or ECE), i.e., it mitigates the impact of the overshoot by reducing the number of losses which vary from a single loss to the number of losses in case 2 minus 1 loss. The experimental results in the Hystart++ draft suggest that this might be the common case as  there is ~50% reduction is losses. Because RTOs are still quite common, it may suggest that case 2 is not that uncommon but more details would be needed to make any reliable conclusions. \r\n\r\nBob's suggestion that a reduction of 30% will usually be sufficient does not sound well advised, because it would not be enough for the avg case 3 where a half of the losses are avoided (i.e., 1.5x overshoot) as it would still result in too high cwnd value exceeding the actually available capacity. Note that overshoot by only 1 segment (one drop) basically would request for the same reaction as in normal CA where just one segment is dropped per cycle.\r\n  \r\nThe presence of the case 3 also suggests that it may be possible and reasonable to have a heuristic with Hystart++ that varies MD factor between 0.5 and beta (0.7) depending on how much cwnd exceeded the actual congestion (saturation) point, that is, how many losses the Hystart++ early exit was able to avoid; if only one or a few losses occur, then apply a MD factor of 0.7, and decrease the MD factor towards the case where the algo avoids only one or a few losses where a MD factor of 0.5 is applied. \r\n\r\n> [\u00a7 4.10 of the rfc8312bis draft](https://datatracker.ietf.org/doc/html/draft-ietf-tcpm-rfc8312bis#section-4.10) mentions LSS, Hystart and standard RFC5681 SS.\r\n> \r\n> If the draft did not mention RFC5681 slow-start as an option, I think this would resolve the matter (given I believe no Cubic implementations use it). It also ought to list the Hystart++ draft as the first option, given it is currently adopted for the stds track, so it has potentially higher IETF 'status' than LSS (EXP) or Hystart (research paper).\r\n",
          "createdAt": "2021-09-29T19:14:09Z",
          "updatedAt": "2021-09-29T19:14:09Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, IIRC from discussions years ago with Van, the 0.5 MD in Reno was motivated by the expected 2x overshoot from slow-start.\r\n\r\nAnd I definitely have seen many traces where CUBIC requires two consecutive fast recoveries after slow start to converge cwnd to the available BDP + buffer space, due this issue (two because 0.7^2 = 0.49).\r\n\r\nI agree using a 0.5 MD rather than 0.7 after slow start makes sense, and would probably show some nice benefits.\r\n\r\nBut this is a pretty significant change, and my sense is that it would be best to get some real world test data from at least one implementation to back up our intuitions before codifying a change this big.\r\n\r\n",
          "createdAt": "2021-09-29T19:54:18Z",
          "updatedAt": "2021-09-29T19:54:18Z"
        },
        {
          "author": "bbriscoe",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Need to be careful about mission-creep here.\r\nIf we start adding untried stuff, we shouldn't move that to stds track.\r\n\r\nHaving said that, how to make the reduction match the overshoot is an open question, and we can't get away from the fact that this is an important part of a CC algo.\r\n\r\nThis is why I said it's good enough to reduce by roughly the average overshoot of the start-up algo, rather than aiming for perfection.",
          "createdAt": "2021-10-01T14:48:44Z",
          "updatedAt": "2021-10-01T14:48:44Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "We have over three decades of experience and consensus that after a slow-start overshoot a TCP sender must do MD with factor of 0.5 to match the overshoot. And, as Neal pointed out, this is how it was designed in order to not intentionally continue with over-aggressive sending rate during fast recovery which would be against the congestion control principles.\r\nTo change this, a lot of evidence (= well-analysed experimental data) should be provided to back up any claims proposing it is safe. Now we have none as far as I know. \r\n\r\nThis draft intends to modify MD with the justification that AI is modified to be less aggressive than the current std AI such that it compensates the use of a larger MD factor of 0.7. Such justification does not cover slow start but only the operation in steady state, i.e., MD when in CA; this draft does not provide any compensation for using an MD factor of 0.7 when in slow start. To do so, it should propose increasing cwnd at most by factor of 1.428 per RTT in slow-start. Otherwise, it must continue using the MD factor of 0.5 when in slow start because that is known to be safe. And, as I pointed out, using HyStart++ does not solve it because it is not guaranteed to work always and we do not have a good understanding on how often and how much it fails.\r\n\r\nMy intention was not to suggest that this draft should seek for an MD factor in between 0.5 and 0.7 depending on when HyStart++ exited slow start (i.e., how much did it overshoot). I just threw an idea how HyStart++ could possibly be enhanced in the future to allow an MD factor larger than 0.5 in slow start. Bob's suggestion \"to reduce by roughly the average overshoot\" is definitely not well advised. It is like suggesting a solution that works roughly half the time and fails otherwise.",
          "createdAt": "2021-10-11T17:01:00Z",
          "updatedAt": "2021-10-11T17:01:00Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Please review #111 and make suggestions there if you all believe anything more needs to be said in the document about any of this. I'd like to close this issue soon.",
          "createdAt": "2021-10-15T06:56:16Z",
          "updatedAt": "2021-10-15T06:56:16Z"
        },
        {
          "author": "bbriscoe",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't believe the current text takes account of Markku's valid point, so this issue should not have been closed. If the draft wants to move to stds track, I suggest sthg like the following added on the end of the first para of \u00a74.10:\r\n\r\n`Which ever start-up algorithm is used, work might be needed to ensure that the end of slow start and the first multiplicative decrease of congestion avoidance work well together.`\r\n\r\n---\r\nOne response to Markku below, 'for the record' but it's not relevant to draft wording...\r\n\r\nIMO, it is not ill-advised to aim for the MD to match the average overshoot. When the MD is not exactly equal to the overshoot, it hasn't \"failed\"; it's just not been perfect.\r\n\r\nEqually with standard Reno, where there's an AQM, the overshoot relative to the AQM's intended target averages around 2 with lots of randomness either side. There are all sorts of different buffer sizes, and types of AQM with different heuristics that allow for slow start bursts on the Internet. So, in practice,  at the instant the start-up ends, it's likely to be increasingly imperfect the further the environment is from the average / expected position.\r\n\r\nSo all those years of experience with an MD of 0.5 matching an expected overshoot of x2 can be said to have supported the idea of aiming for the expectation of the overshoot (relative to the bottleneck's intended target).\r\n\r\nIf we advised anything else than trying to match the MD to the average overshoot, how would the two parts of the system know what the other was most likely to do? The only approach the network can take is to try to bring the queue back to its target, and it can only assume (if it needs to assume anything) that the CC will also be trying to match its reduction to its expectation of the overshoot. \r\n",
          "createdAt": "2021-10-19T12:03:28Z",
          "updatedAt": "2021-10-19T12:03:28Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Thanks for the suggestion, @bbriscoe. This is now a proposal in #125.",
          "createdAt": "2021-10-19T14:18:52Z",
          "updatedAt": "2021-10-19T14:18:52Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't believe the current text takes account of Markku's valid point, so this issue should not have been closed. If the draft wants to move to stds track, I suggest sthg like the following added on the end of the first para of \u00a74.10:\r\n> \r\n> `Which ever start-up algorithm is used, work might be needed to ensure that the end of slow start and the first multiplicative decrease of congestion avoidance work well together.`\r\n\r\nFirst, while this is a valid sentence it is not very useful for a standards track document because it does not provide actual specification nor a concrete advise. It might be ok for an experimental RFC but for a standards track RFC we must know better how to implement this. I think it would be very difficult for a random implementer to understand what to do based on this sentence?\r\n\r\nBut then to the actual point. Bob seems to focus on ECN (meaning there is AQM) because of the title of this issue? Remember that #85 and #86 were folded into one issue as suggested by Bob.\r\n\r\nI'm discussing this for the loss-based CC in the first place and in particular for tail drop which still is the majority of the Internet and must be properly addressed. \r\n\r\nThe original design of MD by Van Jacobson rightly handled MD separately depending on whether a pkt loss was detected during slow start or when in congestion avoidance (see Appendix C of [Jacob88]). \r\nWhen a pkt dropped in tail drop queue, a half of the current cwnd was guaranteed work without drop, i.e., this is the available capacity for the flow as correctly explained in [Jacob88].\r\n\r\nTherefore, cwnd must be at least halved, otherwise loss recovery is entered with a cwnd that is overaggressive and any excess pkts are guaranteed to be dropped. This is very bad because in slow start overshoot half of the pkts are dropped by default, meaning that a TCP sender must rexmit half a window of dropped pkts during fast recovery. If we add there extra packets (42% extra pkts with MD of 0.7) it is more or less guaranteed that some of the rexmits are dropped, resulting in RTO and very bad performance for a lone-flow in tail drop bottleneck. If there are competing flows, such an  overaggressive sender will have a significant bad impact to other flows likely to forcing several unnecessary pkt drops to other flows and thereby achieving unjustified benefit to itself on the expense of the other traffic (in the worst scenario all dropped pkts may belong to other flows, yielding significant benefit for the overaggressive flow). \r\n\r\nNothing related to the slow start overshoot behaviour have been separately studied and data presented to the wg in order to justify this behaviour. A very simple study focusing on the initial slow start behaviour would easily provide more insight to this issue. \r\n\r\nSuch behaviour is also against the congestion control principles as it is guaranteed to result in sending undelivered packets (see RFC 2914) that unnecessarily eat capacity from other flows sharing the path before the bottleneck. \r\n\r\nMoreover, it represents behaviour that RFC 2119 considers very bad:\r\n   \"Others may deliberately be implemented\r\n   with congestion avoidance algorithms that are more aggressive in\r\n   their use of bandwidth than other TCP implementations; this would\r\n   allow a vendor to claim to have a \"faster TCP\".  The logical\r\n   consequence of such implementations would be a spiral of increasingly\r\n   aggressive TCP implementations, or increasingly aggressive transport\r\n   protocols, leading back to the point where there is effectively no\r\n   congestion avoidance and the Internet is chronically congested.\"\r\n\r\nHyStart++ is now considered to be helping here but it is only intended to be used during the initial slow start! If a sender is in RTO recovery and a pkt is dropped before cwnd reaches ssthresh, it is likely to indicate that there is heavy congestion and the sender is required to be extremely careful in reducing cwnd appropriately and quickly. Using overaggressive MD of 0.7 in such a case guarantees inadequate cwnd decrease and further pkt drops during the loss recovery.\r\n\r\nIn addition, even when using HyStart++ it may occur during initial slow start that HyStart++ does not detect the overshoot timely and the sender ii still in slow start when a pkt drop occurs. This is the case I pointed to by saying that HyStart++ failed because it did not have any effect on behaviour and it is guaranteed that cwnd has value that is double the available capacity when a packet is dropped. That is why the rule must be that cwnd is halved when pkt drop occurs during slow start.  \r\n\r\nWhen AQM is in is, thing are somewhat different, particularly when AQM uses probabilistic drop. It is possible that a drop also occurs earlier such that cwnd does not yet have a value that is double the available capacity. This, however, is unlikely to be the common case as classic AQMs are known to be sloppy wit slow start. They are designed and configured to work \"well\" with senders in CA. In slow start the cwnd increase rate is so much faster that AQMs (most?) often react too late, i.e., after the avarage, than too early. \r\n\r\nAnyway, the behaviour with AQMs (with or without ECN) is not studied and results have not been presented to the wg, so I find it hard to make other than a conservative decision without any evidence when we are considering a stds track document. Experimental would be quite different decision and a lot could be left for later experimentation.\r\n\r\n[Jacob88]  V. Jacobson,  Congestion avoidance and control, SIGCOMM '88. \r\n\r\n\r\n",
          "createdAt": "2021-11-11T12:01:58Z",
          "updatedAt": "2021-11-11T12:01:58Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Another way to explain why MD is set to 0.7 is similar to a binary search for target = available BDP + buffer space. \r\n\r\nConsider the following example, \r\n\r\nRTT n:           cwnd = x,   no packet loss for those packets\r\nRTT n+1:      cwnd = 2*x,  packet loss\r\nTherefore, the target should be between x and 2*x. \r\n\r\nBy setting MD=0.7,  Cubic searches for the target starting from the middle point, that is approximately equal to 2*x*0.7=1.4*x.   \r\n\r\nSetting MD=0.5 is guaranteed to be safe but overly conservative. Setting MD close to 1 is overlay aggressive. \r\n\r\n\r\n\r\n",
          "createdAt": "2021-11-12T16:18:32Z",
          "updatedAt": "2021-11-12T16:18:32Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @lisongxu for your reply.\r\n\r\n> Another way to explain why MD is set to 0.7 is similar to a binary search for target = available BDP + buffer space.\r\n\r\nJust to be sure that the terminology I used is clear: I called this (actual) available  (buffering) capacity, i.e., where BDP  = base_e2e_RTT * bottleneck bit-rate, meaning that any buffer at bottleneck adds to the pure network buffering capacity. In other words, available buffering capacity equals to the max cwnd that a flow may have at the tip of the *normal* congestion avoidance cycle (saw tooth).\r\n\r\n> \r\n> Consider the following example,\r\n> \r\n> RTT n: cwnd = x, no packet loss for those packets RTT n+1: cwnd = 2_x, packet loss Therefore, the target should be between x and 2_x.\r\n\r\nWell, that is incorrect. x should be the target if a pkt loss is signalled when cwnd = 2*x and the sender *is still in slow start*  because x is the max available (buffering) capacity for the flow that slow start just determined. See the explanation with an simple example below (see also [Jacob88]). \r\n\r\nFor simplicity, let's consider a single flow case. Let's take an example network setting and begin with the regular congestion avoidance cycle. \r\nLet's assume a stable network with tail drop bottleneck:\r\nBDP = 100 pkts\r\nBottleneck buffer space: 100 pkts = BDP\r\n\r\nWhen a flow has reached steady state, it drops one pkt during each CA cycle once cwnd exceeds 200 pkts. With Reno CC, cwnd is decreased to ~100, and with CUBIC cwnd is decreased to ~140 and W_max is set to 200 (or to 201 if we are accurate). In both cases the bottleneck link is fully utilised: a Reno flow oscillates between 100 and 200, and a CUBIC flow between 140 and 200. So, the max cwnd for either flow is 200. Is that what you call target?\r\n\r\nNow, let's consider the initial slow start in the same example environment:\r\n\r\nThe TCP sender starts with whatever initial cwnd << 100. At some point after some number of RTTs cwnd = 100 (the most recent RTT is not necessarily a full RTT). From this point on the sender is fully utilising the bottleneck and the incoming ACKs for these 100 in flight segments arrive evenly spread over one RTT. Thereby, during the next RTT (= RTT n in your example) the sender injects 200 segments that are nicely ACK clocked and no pkt loss yet occurs. When the ACK for the 1st of these 200 segments arrives, it starts the next RTT (= RTT n+1 in your example) and the cwnd becomes 201, making the sender to inject two segments and one of these two segments gets dropped. Each subsequent ACK for these 200 segments also increases cwnd by 1 and results in the sender injecting 2 segments. So, during this RTT (RTT n+1) 400 segments are injected to the network and every second segment gets dropped at the bottleneck because available capacity is 200. When the first dupack arrives, cwnd = 400, that is, double the available capacity. If the sender applies MD of 0.5 as correctly designed by Van Jacobson, the resulting cwnd (=200) equals to the max cwnd available for the sender (the target?). If the network conditions are stable, there are no drops during the subsequent fast recovery because the sender is allowed to transmit at most 200 segments per RTT during the fast recovery.\r\n \r\nIf an MD factor > 0.5 is used, it means that the sender enters fast recovery with cwnd > 200, that is, it guarantees pkt drop(s) during fast recovery. Even worse, when SACK is in use, it is possible that all 200 dropped segments are retransmitted over the next RTT (RTT n+2); if the sender injects more than 200 segments over that RTT, it is likely that some of the retransmitted segments gets dropped and an RTO is required!\r\nIf MD of 0.7 is applied, the sender injects 280 segments in RTT n+2 (in fast recovery), resulting in 80 segments being dropped and meaning that very likely at least one of these dropped segments is a rexmitted segment (and quite likely more than one rexmitted segment is dropped).\r\n\r\nIf there are other competing flows sharing the bottleneck, a starting flow using MD of 0.7, unlike a flow using MD of 0.5, is overaggressive by sending excess pkts and does very likely force other flows also to drop extra pkts during its fast recovery (and subsequent CA cycle). For each pkt loss imposed to a competing flow the overaggressive flow gets one extra pkt of its own through and is likely force the other flow(s) to do MD which it/they possibly could have otherwise avoided and thereby steals capacity from the other flows unfairly.\r\n \r\n> By setting MD=0.7, Cubic searches for the target starting from the middle point, that is approximately equal to 2_x_0.7=1.4*x.\r\n> \r\n> Setting MD=0.5 is guaranteed to be safe but overly conservative. Setting MD close to 1 is overlay aggressive.\r\n\r\nSetting MD=0.5 when in slow start is not conservative, it is very optimistic because it allows continuing with cwnd that equals to the slow-start determined available capacity, not leaving any extra room as we saw in this example above. Therefore, a slow start overshoot with MD=0.5 may also sometimes result in loss of a rexmit during fast recovery, because network conditions are not necessarily stable. Note that RFC 5681 slow start does not allow doubling cwnd every RTT when delayed ACKs are in use. This increase in slow start roughly by factor of 1.5 per RTT leaves quite a good amount of extra room with MD=0.5 and is unlikely to be the reason for an pkt losses during fast recovery that follows slow start. Someone may argue (quite rightly) that increasing cwnd roughly by factor of 1.5 per RTT during slow start is too conservative, but that's is another discussion and let's not start debating on it here. \r\n\r\nAs I already indicated, selecting MD is a separate decision for a pkt loss occurring in slow start and for a pkt loss occurring in CA as discussed in [Jacob88]; MD=0.5 just happened  conveniently to become the MD in both cases by the original design and this MD value has been inherited in the congestion control RFCs without any distinction. \r\n\r\nIt seems that the above fact was left unnoticed in the CUBIC design and no experimental data has been gathered for backing up the decision to use MD=0.5 when the sender is in slow start?\r\n\r\nMoreover, I didn't notice it earlier but this also means that setting W_max should be different if the sender is in slow start when a pkt loss (congestion) is detected and cwnd is reduced.\r\nIf CUBIC sets W_max to size of cwnd just before cwnd was reduced when in slow start alike when in CA, it results not only starting the first CA epoch after fast recovery with an overaggressive cwnd (using MD=0.7) above the actual saturation point but also starting the subsequent CA with the concave phase and continuing with the concave phase until cwnd reaches value that is double the saturation point. This makes CUBIC (when not in Reno-friendly region) much  more aggressive than intended because it operates in the concave phase even though the cwnd size actually already exceeds the previous saturation point (which in the above example is 200 not 400).\r\n\r\nIMO this issue of which MD factor to use when in slow start is not resolved. Please also add the problem with setting W_max when in slow start to the set of open issues. ",
          "createdAt": "2021-11-22T01:42:56Z",
          "updatedAt": "2021-11-22T01:42:56Z"
        }
      ]
    },
    {
      "number": 86,
      "id": "MDU6SXNzdWU5ODM1NzcwMjU=",
      "title": "Slow-Start Overshoot w/ loss-based congestion conrol",
      "url": "https://github.com/NTAP/rfc8312bis/issues/86",
      "state": "CLOSED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [],
      "body": "Markku Kojo said,\r\n> The larger decrease factor of 0.7 seems unadviseable also if\r\n  used in the initial slow start with loss based congestion\r\n  control (w/ Not-ECT traffic); packets start getting dropped\r\n  when a TCP sender has increased cwnd in slow start such that\r\n  the available network bandwidth and buffering capacity at the\r\n  bottleneck is filled, but the TCP sender continues sending\r\n  more packets for one RTT doubling cwnd and hence also the number\r\n  of packets inflight before the congestion signal reaches the sender.\r\n  Now, even if the sender uses the standard decrease factor of 0.5,\r\n  the cwnd gets reduced only to a value that equals to the cwnd just\r\n  before (or around) the congestion point. That is, the network is\r\n  still full when the sender enters fast recovery but we do not\r\n  expect more drops during fast recovery in a deterministic model.\r\n  Only in congestion avoidance after the recovery, the sender\r\n  increases cwnd again and gets a packet drop that takes the\r\n  sender to a normal sawtooth cycle in an ideal case. So, the\r\n  convergence time from slow-start is expexted to be fast though\r\n  in reality loss recovery does not always work ideally with\r\n  such many drops in a window of data.\r\n>\r\n>  However, if the sender applies decrease factor of 0.7, it\r\n  continues in fast recovery with a 40% higher cwnd than what is\r\n  the available network capacity. This is very likely to result in\r\n  significant number of packet losses during fast recovery, and\r\n  very likely to result in loss of retransmissions. So, it is no\r\n  wonder that so many people have been very concerned about the\r\n  slow-start overshoot and the problems it creates.\r\n  It is very obvious that applying decrease factor of 0.7 in\r\n  the initial slow start is likely to extend the convergence\r\n  time from the slow-start overshoot significantly. Or, do we\r\n  have data that shows that such concern is unnecessary?\r\n  Also, a number of new loss-recovery mechanisms have been\r\n  introduced maybe mainly because of this?\r\n  I would hesitate recommending decrease factor of 0.7 when\r\n  a congestion event occurs during the initial slow start.",
      "createdAt": "2021-08-31T08:15:52Z",
      "updatedAt": "2021-10-18T10:17:26Z",
      "closedAt": "2021-10-18T10:17:26Z",
      "comments": [
        {
          "author": "bbriscoe",
          "authorAssociation": "CONTRIBUTOR",
          "body": "[Same response as for Issue #85](https://github.com/NTAP/rfc8312bis/issues/85#issuecomment-919805852).\r\n\r\nI suggest #85 and #86 are folded into one issue.",
          "createdAt": "2021-09-15T09:26:57Z",
          "updatedAt": "2021-09-15T09:26:57Z"
        }
      ]
    },
    {
      "number": 87,
      "id": "MDU6SXNzdWU5ODM1ODAxMDU=",
      "title": "RACK (and QUIC)",
      "url": "https://github.com/NTAP/rfc8312bis/issues/87",
      "state": "CLOSED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [],
      "body": "Markku Kojo said,\r\n> The draft states that RACK (and QUIC loss detection) can be used\r\n  with CUBIC to detect losses. However, it seems to have gone\r\n  unnoticed that RACK may also detect loss of a retransmission in\r\n  which case the congestion control response is required to be taken\r\n  twice, i.e., ssthresh and cwnd must be lowered again (MUST in\r\n  RFC 5681 Sec. 4.3). Once RACK got published all new congestion\r\n  controls and updates to existing RFCs must include this essential\r\n  congestion control response, if the congestion control mechanism\r\n  intends to use RACK for loss detection.\r\n>\r\n>  This draft does not have any such requirement nor does it specify\r\n  how this is done?",
      "createdAt": "2021-08-31T08:19:05Z",
      "updatedAt": "2021-12-13T16:24:35Z",
      "closedAt": "2021-12-13T16:24:35Z",
      "comments": [
        {
          "author": "bbriscoe",
          "authorAssociation": "CONTRIBUTOR",
          "body": "RACK detects a loss whether retransmission or not, and [\u00a73.4 of RACK [RFC8985]](https://datatracker.ietf.org/doc/html/rfc8985#section-3.4) says:\r\n>   Note that [RFC5681] mandates a\r\n>   principle that loss in two successive windows of data or the loss of\r\n>   a retransmission must be taken as two indications of congestion and\r\n>   therefore results in two separate congestion control reactions.\r\n\r\nSo surely it's not right to say \"all new congestion controls and updates to existing RFCs must include this essential congestion control response.\" A congestion control that uses RACK surely doesn't need to say anything special about lost retransmission, because just referring to the RACK RFC will be enough.\r\n\r\nIf I'm right, I suggest this issue is just closed with no action.",
          "createdAt": "2021-09-15T09:41:06Z",
          "updatedAt": "2021-09-15T09:41:34Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@markkukojo are you OK with the resolution @bbriscoe proposes?",
          "createdAt": "2021-09-15T14:12:32Z",
          "updatedAt": "2021-09-15T14:12:32Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "In addition to what Bob said, a packet loss whether of original packet or of a retransmission - both are considered loss. So, ssthresh and cwnd will be reduced twice. And as Bob said just mentioning RACK as a method to detect loss should be enough.\r\n> After a window reduction in response to a congestion event detected by duplicate ACKs, Explicit Congestion Notification-Echo (ECN-Echo, ECE) ACKs {{!RFC3168}}, TCP RACK {{!RFC8985}} or QUIC loss detection {{!RFC9002}}",
          "createdAt": "2021-09-15T23:29:31Z",
          "updatedAt": "2021-09-15T23:30:37Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@markkukojo can you check the above comments and let us know if there is still some unresolved?",
          "createdAt": "2021-09-25T08:11:00Z",
          "updatedAt": "2021-09-25T08:11:00Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for reminding and apologies for replying so slowly.\r\n\r\nUnfortunately Bob is very wrong here, or he just misunderstood my comment.\r\n\r\nRACK is a pure *loss detection* algorithm and RFC 8985 states it explicitly. So, it does not and cannot provide any congestion control response, i.e., it does not provide any algorithm nor actions to take when a loss of retransmission is detected. Therefore, RFC 8985 just reminds that when RACK is used for loss detection the congestion control response in use MUST follow this essential principle of reacting twice. For example, RFC 8985 does not say how CUBIC should select the new value of W_max, when a loss of rexmit is detected, so referring to RFC 8985 cannot be enough. \r\n\r\nWhen RACK was published, it introduced a way to detect a loss of a rexmit that is something that never existed in the RFC series before and hence no congestion control response in the RFC series is prepared to handle it. In other words, we do not have any RFC that advises an implementer how to do it correctly. Moreover, RFC 6675 machinery simply does not work if a loss of rexmit is detected. And, it is not a trivial \"just reduce twice\" modification but the whole machinery needs to be carefully rethought. Therefore, RFC 8985 explicitly prohibits using RACK with RFC 6675 (MUST NOT). Consequently, a possible update to RFC 6675 needs to include the response to a lost rexmit, if it intends to allow the use of RACK with it. Correspondingly, any new congestion control response algorithm must include correct actions to implement this \"reduce twice\" correctly in all scenarios so that any implementer has no problem in implementing it correctly. Otherwise, it must say that RACK MUST NOT be used with it.\r\n\r\nHope this clarifies the issue.\r\n",
          "createdAt": "2021-09-27T11:44:11Z",
          "updatedAt": "2021-09-27T11:44:11Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@markkukojo What Bob and I are trying to say here is that CUBIC provides guidance to packet losses - whether it is for original data packet or retransmission - CUBIC will reduce congestion window in the same way for both events. We are using RACK to detect packet losses and then providing guidance what to do after that.\r\nPlease see Section 4.6, \r\n> When a congestion event is detected by mechanisms described in Section 3.1, CUBIC updates Wmax and reduces cwnd and ssthresh immediately ..\r\n\r\nStill not convinced with the below comment you made,\r\n> And, it is not a trivial \"just reduce twice\" modification but the whole machinery needs to be carefully rethought. \r\n\r\nWhy do you think it is not as simple as reduce twice? For a network, packet is some bytes traveling through it - there is no difference in original data packet vs retransmission when it drops a packet. I am not getting why you think loss of a retransmissions should have a different response as compared to original data packet.\r\n\r\n",
          "createdAt": "2021-09-27T20:16:29Z",
          "updatedAt": "2021-09-27T20:17:15Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "The proposal here is still to close the issue with no action. If anyone objects, a PR would be nice.",
          "createdAt": "2021-10-11T07:31:15Z",
          "updatedAt": "2021-10-11T07:31:15Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@markkukojo waiting to hear from you :-)",
          "createdAt": "2021-10-13T05:39:17Z",
          "updatedAt": "2021-10-13T05:39:17Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n\r\n \r\n> Why do you think it is not as simple as reduce twice? For a network, packet is some bytes traveling through it - there is no difference in original data packet vs retransmission when it drops a packet. I am not getting why you think loss of a retransmissions should have a different response as compared to original data packet.\r\n\r\nThis is a bit tricky because it's not only about this draft but concerns more the other existing RFCs.\r\nFirst, no CUBIC nor any other algorithm does reduce cwnd and ssthresh always when there is a loss; They reduce only when first entering loss recovery and additional losses during the loss recovery do not  result in additional cwnd reduction as these are losses within the same RTT. However, loss of a rexmit is a loss on another RTT that occurs during loss recovery and needs a special attention and that is not currently present in the RFC series for any fast recovery algo:\r\n1. we need a detection algorithm that a) detects a loss of rexmit and b) indicates to the loss recovery and congestion control algorithms if it happened;\r\n2. we need a loss recovery algorithm that correctly selects what to (re)send;\r\n3. we need a congestion control algorithm to a) react to congestion events and b) correctly determine how much to send during recovery\r\n\r\nFor 1 a) we have RACK but for 1 b) we do not have anything because RFC 8985 does not track whether a loss it detects is an \"original\" loss or a loss of rexmit nor does it indicate when a loss of a rexmit occurs. It just marks a segment lost and that works in Linux to resend (again). \r\n\r\nFor 2 we only have RFC 6675 in the RFC series because RACK requires SACK. The fast recovery algorithm in  RFC 6675 is not written like Linux code, so e.g., NextSeg() does not work with lost rexmits. Similarly, the pipe algorithm does not count pipe correctly with lost rexmits so the congestion control does not work properly (for 3 b).  Also, other modifications are likely needed as well. That is why RFC 8985 says it must not be used with RFC 6675 (but RFC 6675 needs an update). \r\n\r\nFor 3 a) it is pretty much \"reduce again\" like you say, but depending on the cc algo one also needs to see how to correctly calculate the new values for cwnd and ssthresh as well as for any other variables that the cc algo needs in all possible scenarios. But the crucial info in this draft (and in others) is to be able to say exactly when to do this \"reduce again\". \r\n\r\nWhile RACK is fine as a detection algo I feel uneasy to say that one MAY use it with this draft as currently written because an implementer does not have necessary instructions in the RFC series how to do it correctly until RFC 6675 gets updated (or another RFC is published to describe how to implement loss recovery with lost rexmits correctly) and necessary extensions are added to RACK to track lost rexmits and to indicate when a loss of rexmit occurs.\r\nBecause  RFC 8985 and RFC 6675 do not give this necessary info, this draft basically should provide it but it is not the role of this draft as a pure congestion control algorithm. OTOH, if it is left unspecified, it is quite likely some implementers will try to figure it out themselves and would quite likely get it wrong (the experienced developers for major stacks are likely to get it right but there are tons of other stacks with developers to whom the RFCs should give precise implementation instructions). \r\n\r\nSo, this is maybe more of a process question what should be done to have all necessary pieces described properly and where to write it.",
          "createdAt": "2021-10-14T17:00:36Z",
          "updatedAt": "2021-10-14T17:00:36Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@markkukojo thanks for the context. Could we scope this back to 8312bis and decide whether concrete changes are needed or not? ",
          "createdAt": "2021-10-14T19:46:24Z",
          "updatedAt": "2021-10-14T19:46:24Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you @markkukojo for the detailed explanation.\r\n\r\n>Because RFC 8985 and RFC 6675 do not give this necessary info, this draft basically should provide it but it is not the role of this draft as a pure congestion control algorithm.\r\n\r\nI agree with this statement and the reason is QUIC (recovery time is set to when the loss was first detected on ACK and retransmitted packets are sent after that with new packet numbers and sent timestamp) can very clearly detect original losses and rexmit losses and that is documented well in RFC 9002. So, CUBIC just works with QUIC without any modification. Although the response in congestion control is the same for both type of losses which I think is the right thing.\r\n\r\nSo, I think there is no update needed in CUBIC for this issue.\r\n\r\n",
          "createdAt": "2021-10-15T08:19:44Z",
          "updatedAt": "2021-10-15T08:20:35Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@markkukojo do you agree with closing? If not, what **concrete** text changes would you like to propose?",
          "createdAt": "2021-11-01T09:48:54Z",
          "updatedAt": "2021-11-01T09:48:54Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 for Vidhi. It seems to me that we will need recovery algorithm for RACK with TCP which is outside of this draft. ",
          "createdAt": "2021-11-04T09:08:29Z",
          "updatedAt": "2021-11-04T09:08:29Z"
        }
      ]
    },
    {
      "number": 88,
      "id": "MDU6SXNzdWU5ODM1ODI2MDQ=",
      "title": "Fairness to AIMD congestion control",
      "url": "https://github.com/NTAP/rfc8312bis/issues/88",
      "state": "CLOSED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "lisongxu"
      ],
      "labels": [],
      "body": "Markku Kojo said,\r\n>The equation on page 12 to derive increase factor \u03b1_cubic that\r\n intends to achieve the same average window as AIMD TCP seems to\r\n  have its origins in a preliminary paper that states that the\r\n  authors do not have an explanation to the discrepancy between\r\n  their AIMD model and experimental results, which clearly deviate.\r\n  It seems to have gone unnoticed that the equation assumes equal\r\n  drop probability for the different values of the increase factor\r\n  and multiplicative decrease factor but the drop probability\r\n  changes when these factors change. The equations for the drop\r\n  probability / the # of packets in one congestion epoch\r\n  are available in the original paper and one can easily verify\r\n  this. Therefore, the equations used in CUBIC are not correct\r\n  and seem to underestimate _W_est_ for AIMD TCP, resulting in\r\n  moving away from AIMD-Friendly region too early. This gives\r\n  CUBIC unjustified advantage over AIMD TCP particularly in\r\n  environments with low level of statistical multiplexing. With\r\n  high level of multiplexing, drop probability goes higher and\r\n  differences in the drop probablilities tend to get small. On the\r\n  other hand, with such high level of competition, the theoretical\r\n  equations may not be that valid anymore.",
      "createdAt": "2021-08-31T08:21:37Z",
      "updatedAt": "2021-10-12T05:51:09Z",
      "closedAt": "2021-10-12T05:51:09Z",
      "comments": [
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@lisongxu, any update?",
          "createdAt": "2021-09-16T14:00:31Z",
          "updatedAt": "2021-09-16T14:00:31Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, Markku! I agree with you that the AIMD model presented in [FHP00] and adopted by Cubic is only an approximate model (e.g., assumption of packet loss). Cubic chooses this model to calculate alpha_cubic, because it is simple and thus easier to implement and captures some basic behaviors of AIMD algorithms. If there are other more accurate and easy-to-implement AIMD models, Cubic should be updated to adopt these models.\r\n\r\n[FHP00] Floyd, S., Handley, M., and J. Padhye, \"A Comparison of Equation-Based and AIMD Congestion Control\", May 2000, <https://www.icir.org/tfrc/aimd.pdf>.\r\n\r\nThanks again",
          "createdAt": "2021-09-29T15:37:22Z",
          "updatedAt": "2021-09-29T15:37:22Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@lisongxu so will there be a PR to address this issue, or do we close with no action?",
          "createdAt": "2021-10-11T07:30:14Z",
          "updatedAt": "2021-10-11T07:30:14Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Close with no action. Thanks",
          "createdAt": "2021-10-12T02:49:29Z",
          "updatedAt": "2021-10-12T02:49:29Z"
        }
      ]
    },
    {
      "number": 89,
      "id": "MDU6SXNzdWU5ODM1ODQ1ODM=",
      "title": "Contribution to buffer bloat and slower convergence due to   larger decrease factor",
      "url": "https://github.com/NTAP/rfc8312bis/issues/89",
      "state": "CLOSED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "lisongxu"
      ],
      "labels": [],
      "body": "Markku Kojo said,\r\n>This draft uses a larger cwnd decrease factor, resulting in larger\r\n  average cwnd and buffer occupation. This means that it is\r\n  likely to contribute significantly to buffer bloat, particularly\r\n  when considering also the use of concave increase function in the\r\n  beginning of the congestion avoidance that keeps the cwnd close\r\n  to maximum most of the time as carefully explained in the draft.\r\n  This means that CUBIC keeps also buffer bloated router queues\r\n  very efficiently full at all times.\r\n>\r\n>  Currently the draft does mention the slower convergence speed\r\n  as the only side effect for the larger decrease factor and does\r\n  not discuss the contribution to buffer bloat. It would be\r\n  important to assess this together with measurement data to\r\n  back up any observations.\r\n>\r\n>  Do we have data in different environments, including buffer-bloated\r\n  environments that show how much effect CUBIC has compared to\r\n  AIMD TCP?\r\n  And, how does larger decrease function impact convergence speed,\r\n  particularly in buffer-bloated environments.\r\n  Many people have complained that window-based (TCP) congestion\r\n  control drives buffer bloat. Of course, also the current standard\r\n  AIMD TCP tends to fill in the buffer-bloated queues but it\r\n  unlikely does it as effectively as CUBIC? This would be good to\r\n  understand better.",
      "createdAt": "2021-08-31T08:23:34Z",
      "updatedAt": "2021-10-22T13:01:45Z",
      "closedAt": "2021-10-22T13:01:45Z",
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@markkukojo,\r\n@bbriscoe pointed me to this paper https://www.simula.no/sites/default/files/publications/Simula.simula.618.pdf. If you look at Figure 7, CUBIC has a much lower `queuing delay variation` than New Reno which means that CUBIC has a shallower saw-teeth than New Reno. But as you said, due to higher \u03b2 (0.7) and concave increase function, CUBIC can reach W_max faster. This means that although in this paper, CUBIC shows a higher queuing delay than New Reno, this can be easily solved by configuring a lower threshold/interval for loss / ECN at the bottleneck AQM which would make CUBIC perform decreases more often without losing link utilization as significantly (as compared to New Reno). This would also help to solve buffer bloat better than New Reno.",
          "createdAt": "2021-09-14T07:31:20Z",
          "updatedAt": "2021-09-14T07:32:28Z"
        },
        {
          "author": "bbriscoe",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would add to Vidhi's comment by explaining that network operators are not expected to 'solve' this issue by setting a lower AQM threshold wherever Cubic is used (which is clearly impractical, but might be how someone awkward could interpret Vidhi's words). Nonetheless, widespread deployment of Cubic (2006+ timeframe) gives more scope for setting AQM thresholds lower for the same utilization. Indeed, the subsequent round of AQM implementations (2012+ timeframe) could set AQM thresholds to a lower default than if Reno had still been widely deployed.\r\n\r\nI don't think 'bufferbloat' is even the right word for an AQM that is set for the amplitude of Reno's sawteeth rather than Cubic's. Bloat implies excessively large, not just a little too large.\r\n\r\nThe lesson here is that we need to be careful attributing blame. Once AQMs are deployed to address real bufferbloat, the root cause of the residual 'bufferbloat' is not in the buffer, it's in the large variations of congestion control sawteeth (in slow-start as well as congestion avoidance). It is inappropriate to blame Cubic for squeezing the sawteeth up nearer to the threshold - the blame for the threshold needing to be that high in the first place falls on the predecessor to Cubic (Reno).\r\n\r\nShould the draft say something about this? I think it should (briefly - to counter any future criticism similar to Markku's). But that would require a new section. It doesn't fit under any of the headings in the existing 'Discussion' section, which follows the structure suggested by RFC5033. But not saying anything would also be OK for me.\r\n\r\n",
          "createdAt": "2021-09-15T10:21:04Z",
          "updatedAt": "2021-09-15T10:21:04Z"
        },
        {
          "author": "bbriscoe",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Regarding slower convergence, the same section could also say that the smaller reduction per round (larger \u03b2) means that it takes more rounds to reduce in response to continuing congestion or another flow trying to push in. Nonetheless, convergence speed prior to Cubic was primarily limited by the slow additive increase of Reno, which can be faster once Cubic gets into true Cubic mode.\r\n",
          "createdAt": "2021-09-15T10:26:32Z",
          "updatedAt": "2021-09-15T10:26:32Z"
        },
        {
          "author": "bbriscoe",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Any new text about slower convergence obviously ought to mention Cubic's optional fast convergence mechanism. \r\n\r\nA good paper that is mostly an evaluation of Cubic's convergence (with fast convergence mechanism enabled) is:\r\n`Leith, D. J.; Shorten, R. N. & McCullagh, G. Experimental evaluation of Cubic-TCP Proc. Int'l Wkshp on Protocols for Future, Large-scale & Diverse Network Transports (PFLDNeT'07), 2007`\r\nIt's not particularly complementary about Cubic's convergence.\r\n\r\nOn that subject, this text in the fast convergence section is infeasible to comply with:\r\n> Fast Convergence is designed for network environments with multiple CUBIC flows. In network \r\n> environments with only a single CUBIC flow and without any other traffic, Fast Convergence SHOULD \r\n> be disabled.\r\n\r\nThis ought to say whether fast convergence is recommended for use over the public Internet, or not (given the public Internet is designed for both single flows and multiple flows). I believe fast convergence is generally enabled, so this is the sort of thing that ought to be recommended in an RFC that wraps up more than a decade of experience using Cubic.\r\n",
          "createdAt": "2021-09-23T16:56:03Z",
          "updatedAt": "2021-09-23T16:56:03Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@lisongxu since you self-assigned this some time ago, would you please prepare a PR to close this issue?",
          "createdAt": "2021-10-11T07:29:39Z",
          "updatedAt": "2021-10-11T07:29:39Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @larseggert . I will ",
          "createdAt": "2021-10-12T02:48:04Z",
          "updatedAt": "2021-10-12T02:48:04Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert This issue overlaps mainly with two other issues. The buffer bloat part overlaps with issue #94, and the convergence part overlaps with issue #96. ",
          "createdAt": "2021-10-17T22:05:21Z",
          "updatedAt": "2021-10-17T22:05:21Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@lisongxu do you think anything more needs to be done here after those issues are closed?",
          "createdAt": "2021-10-18T10:16:43Z",
          "updatedAt": "2021-10-18T10:16:43Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert No, thank you",
          "createdAt": "2021-10-18T14:03:19Z",
          "updatedAt": "2021-10-18T14:03:19Z"
        }
      ]
    },
    {
      "number": 90,
      "id": "MDU6SXNzdWU5ODM1ODU0NTM=",
      "title": "Citing Experimental RFCs as if being a part of CUBIC",
      "url": "https://github.com/NTAP/rfc8312bis/issues/90",
      "state": "OPEN",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "larseggert"
      ],
      "labels": [
        "WG LC"
      ],
      "body": "Markku Kojo said,\r\n> The draft says that CUBIC MAY implement DSACK [RFC3708], limited slow\r\n  start [RFC 3742], [RFC7661] and hybrid slow start [cites a paper].\r\n  Aren't the first three down references? Not sure if it is appropriate\r\n  for a Stds Track document to cite experimental work or a paper like\r\n  this even though it's a MAY.",
      "createdAt": "2021-08-31T08:24:27Z",
      "updatedAt": "2021-12-14T07:02:00Z",
      "closedAt": null,
      "comments": [
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "These references are all **informational**, which means they are not DOWNREFs by definition (see [RFC3967)](https://datatracker.ietf.org/doc/html/rfc3967).\r\n\r\nPropose to close with no action. Markku?",
          "createdAt": "2021-08-31T12:34:07Z",
          "updatedAt": "2021-08-31T12:34:07Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "No word from @markkukojo, closing this. @markkukojo, please reopen if you disagree.",
          "createdAt": "2021-09-15T14:48:46Z",
          "updatedAt": "2021-09-15T14:48:46Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, the references are currently informal but I think the issue is more subtle and how some of the experimental RFCs are now cited puts them into a \"grey area\" .\r\n\r\nSec 4.10:\r\nIn sec 4.10 the draft says \"CUBIC MUST employ slow-start\" and then continues by allowing  CUBIC to use RFC 3742 or [HR08] as the slow start algorithm for fast and long-distance networks by`using the keyword MAY. So, an implementer MUST implement slow- start and if he/she selects to implement RFC 3742 he/she must read and understand RFC 3742 in order to implement it. In my view it would require RFC 3742 to become a normative reference and thereby a down ref, or at least puts it in a grey area.\r\n\r\nA solution to this could be simply to say:    \"CUBIC MUST employ a slow-start algorithm [RFC 5681].\"\r\nAnd it does not need to say anything like \"MAY use x\" because RFC 3742 (and [HR08]) is less aggressive than regular slow start so use of it is allowed as any other experimental RFC (for experimental purposes). \r\n\r\nI understand that the problem here is that if one decides to use [HR08], one needs to take that into account when setting _W_max_ , etc. as described in the draft. However, I'm not sure whether it's reasonable to allow (by using MAY) employing an algorithm in a research paper (or in an Exp RFC) as part of a Stds Track RFC? My interpretation of using MAY in this way is that it sends a message that \"while the cited algorithm is experimental (or research) only and should not be used in the public Internet other than for experimental purposes, it is, however,  ALL OK to deploy it when used with CUBIC\".\r\n \r\nSo, instead of using MAY, the draft could simply say that \"if CUBIC uses [HR08], it may exit ...\"\r\nThis suggests dropping the second sentence (starting: \"Among ...\") of the first para as unnecessary and potentially confusing. \r\n\r\nSec 4.9:\r\n\r\nHere also the use of MAY is quite unnecessary and potentially results in similar confusion about the status of RFC 3708.\r\nThere is no reason to separately allow (by using MAY) CUBIC to employ RFC 5682 or RFC 3522 as they are Stds Track, nor to separately allow employing RFC 3708 as it can be employed with same provisions as any Experimental algorithm.  \r\n\r\nAgain, it would be just enough to note that if any of these are used, the mentioned CUBIC variables need to be restored as described. However, the authors should carefully consider what RFC 4015 says and what limitations there are for a congestion control response when a spurious RTO is detected. RFC 4015 is currently the only Stds Track CC response algorithm for spurious RTOs. There is no Stds Track CC response algorithm for false Fast Retransmits; this topic was studied around two decades ago and there was no consensus  on whether restoring CC state is a good idea in all scenarios. E.g., in mobile networks, a make-before-break handoff from a high RTT path to a low RTT path may result in packet reordering when the available network capacity actually decreases and restoring the old state in such a case is not a sane action.  Therefore, I think that this draft is not in position to provide a reasonable suggestion to unconditionally restore CC state after spurious congestion events nor to provide evidence that it is always the correct action. Moreover, handling spurious retransmissions is not a key part of CUBIC but it is a more general issue where other CCs have the same challenges as CUBIC and therefore I think the CC response for spurious rexmits should be handled separately and should follow common principles for all CCs. \r\n\r\nSec 4.6:\r\n\r\nThe draft allows using RFC 7661 as described in the RFC. However, if I recall it correctly, the equations in RFC 7661 assume that cwnd increase and decrease uses standard methods i.e., alfa=1 and beta=0.5. If the equations in RFC  7661 are directly applied with CUBIC, the outcome might not be expected nor correct. I didn't have time to check this, so I might be wrong, but this is good to double-check with Gorry and/or other authors of RFC 7661 who have better insight to the details of RFC 7661.",
          "createdAt": "2021-09-16T11:22:52Z",
          "updatedAt": "2021-09-16T11:22:52Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Please check #90, which intends to address your first two comments.\r\n\r\nAbout RFC7661, would @gorryfair please chime in?",
          "createdAt": "2021-09-16T12:00:47Z",
          "updatedAt": "2021-09-16T12:00:47Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@markkukojo \r\n> Therefore, I think that this draft is not in position to provide a reasonable suggestion to unconditionally restore CC state after spurious congestion events nor to provide evidence that it is always the correct action. Moreover, handling spurious retransmissions is not a key part of CUBIC but it is a more general issue where other CCs have the same challenges as CUBIC and therefore I think the CC response for spurious rexmits should be handled separately and should follow common principles for all CCs.\r\n\r\nResponse to spurious events due to Fast retransmits was added newly to 8312-bis draft as it made sense to cover this scenario which is likely more common than spurious RTOs and folks who implemented QUIC noticed a great throughput improvement when implementing this. I agree that this is common to all CCs but at as of today, I don't think any RFC covers it. For completeness, it made sense to add it to CUBIC.\r\n\r\n> There is no Stds Track CC response algorithm for false Fast Retransmits; this topic was studied around two decades ago and there was no consensus on whether restoring CC state is a good idea in all scenarios. E.g., in mobile networks, a make-before-break handoff from a high RTT path to a low RTT path may result in packet reordering when the available network capacity actually decreases and restoring the old state in such a case is not a sane action.\r\n\r\nHow common is the scenario you are describing above? And if we are switching to low RTT, then the sender will soon-after reduce the congestion window if restoring to old state was a mistake. (i.e. if the old state cwnd > capacity for low RTT path)",
          "createdAt": "2021-09-21T07:49:54Z",
          "updatedAt": "2021-09-21T07:49:54Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": ">The draft allows using RFC 7661 as described in the RFC. However, if I recall it correctly, the equations in RFC 7661 assume that cwnd increase and decrease uses standard methods i.e., alfa=1 and beta=0.5. If the equations in RFC 7661 are directly applied with CUBIC, the outcome might not be expected nor correct. I didn't have time to check this, so I might be wrong, but this is good to double-check with Gorry and/or other authors of RFC 7661 who have better insight to the details of RFC 7661.\r\n\r\nRegarding RFC 7661, there are two things to consider,\r\n1. Threshold for validated vs non-validated phase - this threshold has been set by 7661 based on slow-start increase and is valid for CUBIC too.\r\n> A standard TCP sender in slow-\r\n   start is permitted to double its FlightSize from one RTT to the next.\r\n   This motivated the choice of a threshold value of 1/2. This threshold ensures a\r\n    sender does not further increase the cwnd as long\r\n   as the FlightSize is less than (1/2*cwnd)\r\n\r\n2. Congestion response - RFC 7661 uses 1/2 as the reduction factor which is probably taken from New Reno. I think this is what we need to update in CUBIC. Something like this,\r\n\r\n```\r\nCUBIC updates the response to congestion when RFC 7661 is used to validate the congestion window.\r\nIt updates the congestion window for loss recovery as below,\r\n\r\ncwnd = (Max(pipeACK,LossFlightSize)) * Beta_cubic\r\n\r\nIt also updates the congestion window at the end of the recovery phase to,\r\ncwnd = (Max(pipeACK,LossFlightSize) - R) * Beta_cubic\r\n```\r\n\r\nI don't know how to best document this, should we re-write these equations and explain all the variables or is there a way to reference RFC 7661 and just say, If you use RFC 7661, CUBIC updates Section 4.4.1 of RFC 7661 to replace the 0.5 reduction factor by Beta_cubic?",
          "createdAt": "2021-09-21T08:21:54Z",
          "updatedAt": "2021-09-21T08:22:55Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "The latter seems easier to me, but I don't have a strong preference. Waiting to hear from @markkukojo and/or @gorryfair.",
          "createdAt": "2021-09-21T08:48:12Z",
          "updatedAt": "2021-09-21T08:48:12Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "I'd like to merge #111 soon. Is there anything that needs to be changes in it to address this issue?",
          "createdAt": "2021-09-29T08:08:09Z",
          "updatedAt": "2021-09-29T08:08:09Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "I'll take a look at it later today.",
          "createdAt": "2021-09-29T08:17:09Z",
          "updatedAt": "2021-09-29T08:17:09Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "> @markkukojo\r\n> \r\n> > Therefore, I think that this draft is not in position to provide a reasonable suggestion to unconditionally restore CC state after spurious congestion events nor to provide evidence that it is always the correct action. Moreover, handling spurious retransmissions is not a key part of CUBIC but it is a more general issue where other CCs have the same challenges as CUBIC and therefore I think the CC response for spurious rexmits should be handled separately and should follow common principles for all CCs.\r\n> \r\n> Response to spurious events due to Fast retransmits was added newly to 8312-bis draft as it made sense to cover this scenario which is likely more common than spurious RTOs and folks who implemented QUIC noticed a great throughput improvement when implementing this. I agree that this is common to all CCs but at as of today, I don't think any RFC covers it. For completeness, it made sense to add it to CUBIC.\r\n> \r\n\r\nLet me try again. There are several reasons why the existence of the current text is problematic:\r\n1) Spurious rexmits are not part of CUBIC nor specific to CUBIC. I think this draft should focus on CUBIC and not include various features present in Linux or any other stack, no matter how useful they are particularly when the problem space is orthogonal to CUBIC.  UNDO of congestion control state was there in Linux well before CUBIC was introduced and before the cited RFCs were published.\r\n2) As I said, such an UNDO comes with caveats. Certainly it provides benefits in certain scenarios, but may also be harmful in some other scenarios, particularly if various safeguards are not implemented. 3) Why there is no RFC to cover response for false fast retransmits? Because there are cases when one should not revert the CC state as it would result in undesired behaviour, such as incorrectly bursting uncontrolled data in case one should actually reduce cwnd. This is also the reason why all these detection algorithms (RFC 5682, RFC 3522, and RFC 3708) were separated from the response. \r\n4) The way that current text proposes for reverting the congestion control state in case of a spurious RTO is in conflict with RFC 4015 which is Stds Track. What's wrong in the steps specified in RFC 4015 such that one should not follow it but instead follow this draft which in turn would require an update to  RFC 4015? \r\nIf this draft is in need to say anything, it should cite RFC 4015 for response to detected spurious RTOs and indicate the additional state information to store and restore in case of CUBIC.\r\n\r\n> > There is no Stds Track CC response algorithm for false Fast Retransmits; this topic was studied around two decades ago and there was no consensus on whether restoring CC state is a good idea in all scenarios. E.g., in mobile networks, a make-before-break handoff from a high RTT path to a low RTT path may result in packet reordering when the available network capacity actually decreases and restoring the old state in such a case is not a sane action.\r\n> \r\n> How common is the scenario you are describing above? And if we are switching to low RTT, then the sender will soon-after reduce the congestion window if restoring to old state was a mistake. (i.e. if the old state cwnd > capacity for low RTT path)\r\n\r\nThe scenario above is just one example. I don't have an answer how common it might be today. AFAIK at least cellular networks used to attempt delivering data in order up until 3G. Don't know that well what is the exact situation with 4G and 5G (or 6G).  But if one would like to propose reverting CC state in case of false fast retransmits one should provide evidence that such scenarios are non-existing today and unlikely to (re)appear in the near future. E.g., is there evidence that route fluttering does not exist anymore? Moreover, there have recently been proposals which suggest that link layers should not anymore deliver data in order. E.g. Bob has been advocating it. How about if it gets realised anytime soon with some technologies?\r\n\r\nSure the sender will reduce the congestion window if restoring to old state was a mistake, but the new available capacity might be only a small fraction of the old and it would possibly require reducing cwnd a notable number of times before cwnd decreases enough. And such a sender behaviour would be detrimental to other flows from which it would steal the bandwidth unfairly.",
          "createdAt": "2021-09-30T01:41:39Z",
          "updatedAt": "2021-09-30T01:41:39Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> 1. Congestion response - RFC 7661 uses 1/2 as the reduction factor which is probably taken from New Reno. I think this is what we need to update in CUBIC. Something like this,\r\n> \r\n> ```\r\n> CUBIC updates the response to congestion when RFC 7661 is used to validate the congestion window.\r\n> It updates the congestion window for loss recovery as below,\r\n> \r\n> cwnd = (Max(pipeACK,LossFlightSize)) * Beta_cubic\r\n> \r\n> It also updates the congestion window at the end of the recovery phase to,\r\n> cwnd = (Max(pipeACK,LossFlightSize) - R) * Beta_cubic\r\n> ```\r\n\r\nHas this been implemented for CUBIC and experimented with so we know it works properly? And do we have data to show this is the case?\r\n\r\nIn other words, would this be mature enough to become Stds Track and just for CUBIC, while RFC 7661 is experimental and the problem space once again is not specific to CUBIC but common for all CCs?\r\n\r\nAnyway, I'd like to hear from those who have worked with RFC 7661 and do have a lot of experience on it. And would definitely have much better insight in any potential caveats that might be buried in there.\r\n\r\n> I don't know how to best document this, should we re-write these equations and explain all the variables or is there a way to reference RFC 7661 and just say, If you use RFC 7661, CUBIC updates Section 4.4.1 of RFC 7661 to replace the 0.5 reduction factor by Beta_cubic?\r\n\r\nIMO this problem space is common to all CCs and still experimental, so the proposal is not mature enough and best handled in a separate document, either RFC7661bis or a draft of its own that may potentially be incorporated in RFC7661bis later.",
          "createdAt": "2021-09-30T02:03:32Z",
          "updatedAt": "2021-09-30T02:03:32Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema @nealcardwell In this issue #23, we discussed and added a new section for Spurious detection and response for CUBIC but @markkukojo doesn't think we should do that due to any adverse effects of reverting to old_cwnd in case there is route change that has much lower capacity than old_cwnd state.\r\n\r\nDo you think citing RFC 4015 for spurious RTOs is enough? This would mean we wouldn't provide any guidance for spurious detection of false fast retransmits.",
          "createdAt": "2021-09-30T23:42:48Z",
          "updatedAt": "2021-09-30T23:43:02Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "It has been experimented -- was the default option for using cubic in picoquic, before switching the default to BBR. No negative feedback. There were also extensive simulations done by the MS Quic team, as part of their systematic unit tests. We should ask them, but I believe these simulations are based on scenarios they have encountered in real deployments. Implementing spurious loss recovery in QUIC-Cubic was key to achieving parity with TCP-Cubic in these scenarios.\r\n\r\nLinks are not perfect, spurious reordering do happen -- that's quite visible on Wi-Fi and LTE links. I also saw some networks aggressively bundling the small UDP packets that carry QUIC ACK. Some networks will send small and large packets with different priorities. All that means that the standard recovery algorithm sometimes results in spurious loss detection. Cubic is not performing well in practice without spurious loss recovery. If this is not specified, implementations will probably just move to use BBR instead of Cubic. There is a perverse bad angel whispering to me that this would be a good thing, since BBR does result in smaller queues all over the Internet. Which means I am a bit conflicted...\r\n\r\nIf you are concerned about standardization status, one possibility would be to move that text to a non normative appendix. \r\n\r\n",
          "createdAt": "2021-10-01T02:26:28Z",
          "updatedAt": "2021-10-01T02:40:07Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "body": "> @huitema @nealcardwell In this issue #23, we discussed and added a new section for Spurious detection and response for CUBIC but @markkukojo doesn't think we should do that due to any adverse effects of reverting to old_cwnd in case there is route change that has much lower capacity than old_cwnd state.\r\n>\r\n\r\nI would strongly urge the draft to keep the \"Spurious Congestion Events\" section, since reordering and spurious retransmits are common and getting more common, so undo of CC reductions is critical and becoming more so. \r\n\r\nIn the scenario mentioned that has a route change that causes a reordering event and reduction in available bandwidth, it's still fine to undo based on detecting the spurious retransmits. If there are real losses at any point, those will be detected and the CC will react. The likely order in this scenario would be:\r\n\r\n- route change to path with lower RTT and bandwidth\r\n- RTT decreases, sender receives SACKs for reordered packets\r\n- enter spurious fast recovery -> spurious retransmit and CUBIC reduces ssthresh and cwnd\r\n- spurious retransmit detected -> CUBIC undo, restoring parameters from before spurious recovery\r\n- real packet losses happen due to lower bandwidth   -> enter well-founded fast recovery -> CUBIC reduces ssthresh and cwnd\r\n\r\n> Do you think citing RFC 4015 for spurious RTOs is enough? This would mean we wouldn't provide any guidance for spurious detection of false fast retransmits.\r\n\r\nI would suggest citing all the major mechanisms that major TCP stacks use in the real world to detect spurious retransmits, namely something like: \"CUBIC implementations MAY use any of the following documented mechanisms for detecting spurious congestion events:  Eifel [rfc3522] [rfc4015], F-RTO [rfc5682], DSACK [rfc3708].\"\r\n \r\nI believe their statuses are:\r\n- Eifel rfc3522 (exp), rfc4015 (std)\r\n- F-RTO: rfc5682 (std)\r\n- DSACK: rfc3708 (exp)\r\n \r\nReally TCP stacks SHOULD use these, but if there's a problem with a stds track doc saying a stack SHOULD use an experimental RFC then perhaps MAY is OK?\r\n",
          "createdAt": "2021-10-01T16:11:45Z",
          "updatedAt": "2021-10-01T16:11:45Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "If we want to say \"MUST implement\" for something that is not on the standards track, maybe that's a reason to republish that document as a PS. Which documents specifically would this be the case for?",
          "createdAt": "2021-10-02T05:43:00Z",
          "updatedAt": "2021-10-02T05:43:00Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "I was wondering why is Eifel detection (RFC 3522) experimental while the response on detection (RFC 4015) a stds track. \r\nF-RTO is stds track detection of spurious RTO which does not require timestamps to be enabled (unlike RFC 3522)\r\n\r\nShould we say,\r\n`MUST implement F-RTO detection and RFC 4015 response algorithm. MAY implement other algorithms for detection, i.e. RFC 3522 and RFC 3708`",
          "createdAt": "2021-10-02T08:13:14Z",
          "updatedAt": "2021-10-02T08:13:26Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "IIRC, RFC3522 has an IPR disclosure that makes it difficult to implement in open source or otherwise. RFC4015 has no such IPR. The community at the time felt strongly that the IPR meant RFC3522 shouldn't be standards track. Pasi developed F-RTO in part because of the IPR in RFC3522.",
          "createdAt": "2021-10-04T06:25:03Z",
          "updatedAt": "2021-10-04T06:25:03Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "Note that as far as QUIC is concerned, detecting spurious RTO is completely straightforward. QUIC packets have unique numbers, any data that need to be repeated is carried in new packets, with numbers different from the initial transmission. The sender just has to record an ack of a packet that was considered lost, there is no requirement to implement F-RTO or other algorithms.",
          "createdAt": "2021-10-04T06:47:18Z",
          "updatedAt": "2021-10-04T06:47:18Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Heads up: I plan to merge #111 soon, unless I hear objections. If you do object, please make a concrete rephrasing proposal (on the PR).",
          "createdAt": "2021-10-11T07:28:52Z",
          "updatedAt": "2021-10-11T07:28:52Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "> It has been experimented -- was the default option for using cubic in picoquic, before switching the default to BBR. No negative feedback. There were also extensive simulations done by the MS Quic team, as part of their systematic unit tests. We should ask them, but I believe these simulations are based on scenarios they have encountered in real deployments. Implementing spurious loss recovery in QUIC-Cubic was key to achieving parity with TCP-Cubic in these scenarios.\r\n\r\nThanks Christian for the data point. Just wondering whether route fluttering was included in the test cases?\r\n \r\n> Links are not perfect, spurious reordering do happen -- that's quite visible on Wi-Fi and LTE links. I also saw some networks aggressively bundling the small UDP packets that carry QUIC ACK. Some networks will send small and large packets with different priorities. All that means that the standard recovery algorithm sometimes results in spurious loss detection. Cubic is not performing well in practice without spurious loss recovery. If this is not specified, implementations will probably just move to use BBR instead of Cubic. There is a perverse bad angel whispering to me that this would be a good thing, since BBR does result in smaller queues all over the Internet. Which means I am a bit conflicted...\r\n\r\nSure, links are not perfect. That's why these algos were brought to IETF some two decades ago. At that time maybe the hardest thing for us was to convince that spurious rexmits are a real problem ;) \r\n\r\nThere was quite a bit lessons learnt in that exercise on those days and it would be good to not ignore it all. Much is documented in those RFCs but not all, e.g., response to spurious fast rexmits never materialised. \r\nThat's why I think it is not the best option from the process point of view to embed a response to spurious rexmits in this CUBIC spec as the problem area and solution is common to all CCs. Having it in a specific response draft would also allow/invite those with expertise in this topic to join reviewing and contributing unlike it now pretty much went unnoticed by many because no one expected it to a part of CUBIC algo (me included).\r\n\r\nA correct response (UNDO) should not just simply restore previous state but consider various issues like adjusting DupThresh (or RACK reorder wnd) to avoid further spurious rexmits, control possible bursts due to UNDO, and other safeguards (see more in a latter comment). In addition, all this requires experiments in a range of environments to make it an experimental RFC, not to mention Stds Track. \r\n",
          "createdAt": "2021-10-14T19:13:14Z",
          "updatedAt": "2021-10-14T19:13:14Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Do you think citing RFC 4015 for spurious RTOs is enough? This would mean we wouldn't provide any guidance for spurious detection of false fast retransmits.\r\n> \r\n> I would suggest citing all the major mechanisms that major TCP stacks use in the real world to detect spurious retransmits, namely something like: \"CUBIC implementations MAY use any of the following documented mechanisms for detecting spurious congestion events: Eifel [rfc3522] [rfc4015], F-RTO [rfc5682], DSACK [rfc3708].\"\r\n> \r\n> I believe their statuses are:\r\n> \r\n> * Eifel rfc3522 (exp), rfc4015 (std)\r\n> * F-RTO: rfc5682 (std)\r\n> * DSACK: rfc3708 (exp)\r\n\r\nPlease note that RFC 4015 is a stds track *response* algorithm for spurious RTOs. The question was why the advise in RFC 4015 is wrong and why this draft would need to modify it as the current text does and thereby maybe requires to update RFC 4015, instead of pointing to RFC 4015 as the response algo for spurious RTOs and just giving the extra state that needs to be stored/restored?\r\n",
          "createdAt": "2021-10-14T19:16:23Z",
          "updatedAt": "2021-10-14T19:16:23Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@markkukojo could you explain what changes you would like to see in #111 or what is missing from it?",
          "createdAt": "2021-10-14T19:31:40Z",
          "updatedAt": "2021-10-14T19:31:40Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "> IIRC, RFC3522 has an IPR disclosure that makes it difficult to implement in open source or otherwise. RFC4015 has no such IPR. The community at the time felt strongly that the IPR meant RFC3522 shouldn't be standards track. Pasi developed F-RTO in part because of the IPR in RFC3522.\r\n\r\nYes, I think IPR issue is one reason but not the only one. There is much in those RFCs so my apologies for not opening it all when I said there are caveats. AFAIK, another reason why RFC 3522 (and RFC 3708) is not Std Track is that it is vulnerable to lying receivers that can easily make a fast rexmit to appear as a spurious rexmit. There is a mitigation proposed for Eifel detection but it calls for experimentation that we do not have AFAIK. As Ack supression is deemed to be quite common today, such experimentation would be even more crucial to show that it works appropriately. Without a safe detection for fast rexmits it is hard to propose a response.\r\n\r\nAs Christian noted, QUIC is much more straightforward in detecting spurious rexmits, so should not suffer from similar problems. ",
          "createdAt": "2021-10-14T19:50:23Z",
          "updatedAt": "2021-10-14T19:50:23Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "> @markkukojo could you explain what changes you would like to see in #111 or what is missing from it?\r\n\r\nText for Slow Start section:\r\n\r\n    CUBIC MUST employ a slow-start algorithm, when *cwnd* is no more than\r\n   *ssthresh* {{!RFC5681}}.\r\n\r\n    If CUBIC uses HyStart++ {{!I-D.ietf-tcpm-hystartplusplus}} for early\r\n    exit from the initial slow start, it may exit the slow start without\r\n    incurring any packet loss  ...\r\n\r\nReasoning:\r\n- HyStart++ is only for the initial slow start. Slow start is used elsewhere as well and HyStart++ is not applicable then. That is, HyStart++ cannot be a general alternative for the std slow start; in particular, \"in the rare cases when HyStart++ is not suitable\" does not make much sense.\r\n- HyStart++ is essentially the same as the initial slow start in RFC 5681. It essentially specifies an additional algorithm to decide on an early exit from slow start. (That would be good to be reflected in the Title of HyStart draft as well: HyStart++: An algorithm for Early Exit from TCP Initial Slow Start)\r\n- I asked but did not get answer why CUBIC would be dependent on HyStart++ (use  SHOULD), i.e., what are the full implications that must be understood and carefully weighted before choosing not to implement HyStart++ with CUBIC? I don't see any such reasons, maybe I am missing something?\r\n\r\n\r\nFor spurious rexmits:\r\n\r\nI cannot provide text as I have expressed my strong opinion: \r\n-this draft must not provide an alternative stds track specification for response from spurious RTOs; we already have it in RFC 4015. There is no discussion in tcpm wg, no data provided, nor justification provided to change RFC 4015. \r\n-this draft is not mature enough to provide a new stds track specification for response from spurious fast rexmits. There is no discussion in tcpm wg on the such algorithm considerations, no experiments nor data provided. There are two experimental algorithms for detecting false fast rexmits but they both have security implications which have not been considered for the proposed response. \r\n- A response to false fast rexmits should be a draft of its own because the solution is common to all congestion control algorithms, not in anyway specific to CUBIC, and the solution deserves much more attention and more careful design than what this draft currently provides.\r\n\r\nI'd suggest to move the text in sec 4.9 to sec 5.3 (Difficult Environments):\r\nThe first para extended with a brief intro for environments where and why spurious RTOs and false rexmits may occur. Pointers to results where the implications are shown. And pointing to detection algos and RFC 4015 for response to spurious RTOs + list what additional state in addition to  ssthresh to store/restore.",
          "createdAt": "2021-10-14T22:45:48Z",
          "updatedAt": "2021-10-14T22:45:48Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "body": "Re: \"Much is documented in those RFCs but not all, e.g., response to spurious fast rexmits never materialised.\"...\r\n\r\nEven if RFCs for responding to spurious fast retransmits never happened, the code to do that has been widely deployed and used in the Internet with good results, including at least in Linux TCP for over a decade. Since implementations are doing it, we may as well tell them how to do it well. :-)\r\n\r\nRe: \"That's why I think it is not the best option from the process point of view to embed a response to spurious rexmits in this CUBIC spec as the problem area and solution is common to all CCs.\"... \r\n\r\nThe solution is not common to all CCs, because the state variables for each CC are different. It is important for the CC spec to specify which variables need to be saved and restored if there is an undo event. That's why it's great that 8312bis covers those details.\r\n\r\nI agree the question of whether/when to undo a fast recovery is a separate question. But that's why this 8312bis is referencing other docs to cover that.\r\n\r\n",
          "createdAt": "2021-10-15T02:17:00Z",
          "updatedAt": "2021-10-15T02:17:00Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "> Text for Slow Start section:\r\n\r\n...\r\n\r\n@markkukojo, so that entire paragraph should look like the following?\r\n```\r\nCUBIC MUST employ a slow-start algorithm, when *cwnd* is no more than\r\n*ssthresh* {{!RFC5681}}. If CUBIC uses HyStart++\r\n{{!I-D.ietf-tcpm-hystartplusplus}} for early exit from the initial\r\nslow start, it may exit the slow start without incurring any packet\r\nloss. Experimental alternatives to HyStart++ include hybrid slow\r\nstart {{HR08}}, a predecessor to HyStart++ that some CUBIC\r\nimplementations have used as the default for the last decade, and\r\nlimited slow start {{?RFC3742}}.\r\n```\r\n\r\n> * I asked but did not get answer why CUBIC would be dependent on HyStart++ (use  SHOULD), i.e., what are the full implications that must be understood and carefully weighted before choosing not to implement HyStart++ with CUBIC? I don't see any such reasons, maybe I am missing something?\r\n\r\nIIRC one pragmatic reason is that there is no other standards-track mechanism.\r\n\r\n> I cannot provide text as I have expressed my strong opinion: -this draft must not provide an alternative stds track specification for response from spurious RTOs; we already have it in RFC 4015.\r\n\r\nThis sounds like you are arguing that text should be taken out of the document - which bits?\r\n\r\n> * A response to false fast rexmits should be a draft of its own because the solution is common to all congestion control algorithms, not in anyway specific to CUBIC, and the solution deserves much more attention and more careful design than what this draft currently provides.\r\n\r\nAgain, this sounds like you are arguing that text should be taken out of the document - which bits?\r\n\r\n> I'd suggest to move the text in sec 4.9 to sec 5.3 (Difficult Environments): The first para extended with a brief intro for environments where and why spurious RTOs and false rexmits may occur. Pointers to results where the implications are shown. And pointing to detection algos and RFC 4015 for response to spurious RTOs + list what additional state in addition to ssthresh to store/restore.\r\n\r\nFirst, I thought spurious RTOs and fals RTXs are not uncommon on general Internet paths. So I'm not sure that moving that text into a section called \"difficult environments\" is appropriate.\r\n\r\nSecond, it sounds like you don't just want to move the existing text, you are outlining an complete rewrite of what we have. It would be more actionable if you could propose a draft of the concrete text you think should be there (ideally, as a PR.)\r\n",
          "createdAt": "2021-10-15T06:48:16Z",
          "updatedAt": "2021-10-15T06:48:45Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Text for Slow Start section:\r\n> \r\n> ...\r\n> \r\n> @markkukojo, so that entire paragraph should look like the following?\r\n> \r\n> ```\r\n> CUBIC MUST employ a slow-start algorithm, when *cwnd* is no more than\r\n> *ssthresh* {{!RFC5681}}. If CUBIC uses HyStart++\r\n> {{!I-D.ietf-tcpm-hystartplusplus}} for early exit from the initial\r\n> slow start, it may exit the slow start without incurring any packet\r\n> loss. Experimental alternatives to HyStart++ include hybrid slow\r\n> start {{HR08}}, a predecessor to HyStart++ that some CUBIC\r\n> implementations have used as the default for the last decade, and\r\n> limited slow start {{?RFC3742}}.\r\n> ```\r\n\r\nNo. Sorry, I meant with the three dots (...) that I modified the beginning of that para and the rest of the para may remain untouched. Please, see below for the full text. \r\n\r\n  CUBIC MUST employ a slow-start algorithm, when *cwnd* is no more than\r\n  *ssthresh* {{!RFC5681}}.\r\n\r\n  If CUBIC uses HyStart++ {{!I-D.ietf-tcpm-hystartplusplus}} for early \r\n  exit from the initial slow start, it may exit the slow start without\r\n  incurring any packet loss and thus *W<sub>max</sub>* is undefined.\r\n  I  n this special case, CUBIC\r\n  switches to congestion avoidance and increases its congestion window\r\n  size using {{eq1}}, where *t* is the elapsed time since the beginning\r\n  of the current congestion avoidance, *K* is set to 0,\r\n  and *W<sub>max</sub>* is set to the congestion window size at the\r\n  beginning of the current congestion avoidance stage.\r\n\r\nI also tried to explain why the draft cannot say \"in general SHOULD use HyStart++ ...\". HyStart++ is specified for the initial slow start only! You cannot require it to be used e.g., after a timeout when CUBIC like any other TCP CC algo must use RFC 5681 slow start as there is no other slow start specified for that purpose. Same holds for the other cases where cwnd < ssthresh. \r\n\r\nFurthermore, the current text effectively says (claims):  \r\n\"... MAY use the Reno TCP slow start algorithm {{!RFC5681}} in the rare cases (of RTO) when\r\nHyStart++ is not suitable.\"\r\n\r\n> > * I asked but did not get answer why CUBIC would be dependent on HyStart++ (use  SHOULD), i.e., what are the full implications that must be understood and carefully weighted before choosing not to implement HyStart++ with CUBIC? I don't see any such reasons, maybe I am missing something?\r\n\r\n> \r\n> IIRC one pragmatic reason is that there is no other standards-track mechanism.\r\n\r\nMy apologies but I don't understand this reasoning. If something is stds track, it is not a reason to make it automatically a SHOULD. For SHOULD (and MUST) there needs to be a reason why it is required and it needs to be explained.  What beaks if CUBIC does not use HyStart++?\r\nThere is currently no justification provided to SHOULD in the draft.\r\n\r\n> > I cannot provide text as I have expressed my strong opinion: -this draft must not provide an alternative stds track specification for response from spurious RTOs; we already have it in RFC 4015.\r\n> \r\n> This sounds like you are arguing that text should be taken out of the document - which bits?\r\n> \r\n> > * A response to false fast rexmits should be a draft of its own because the solution is common to all congestion control algorithms, not in anyway specific to CUBIC, and the solution deserves much more attention and more careful design than what this draft currently provides.\r\n> \r\n> Again, this sounds like you are arguing that text should be taken out of the document - which bits?\r\n> \r\n> > I'd suggest to move the text in sec 4.9 to sec 5.3 (Difficult Environments): The first para extended with a brief intro for environments where and why spurious RTOs and false rexmits may occur. Pointers to results where the implications are shown. And pointing to detection algos and RFC 4015 for response to spurious RTOs + list what additional state in addition to ssthresh to store/restore.\r\n> \r\n> First, I thought spurious RTOs and fals RTXs are not uncommon on general Internet paths. So I'm not sure that moving that text into a section called \"difficult environments\" is appropriate.\r\n\r\nSure, spurious RTOs and false RTXs occur. But how often, in what conditions, what are the reasons, what else may happen at the same time? We need evidence (well analysed measurement results) that it is common and that we understand the reasons for such behaviour and hence are able to justify a correct way to do the response. Currently there is nothing in this draft about these. Moreover, what could be done to avoid such spurious rexmits, what actions the IETF has taken/should take to advise how to avoid them. Is the transport protocol the only actor that should be prepared and react? What we need to take into account if we undo cc state and how the state is safely restored? All these questions are specific to the problem area of spurious rexmits but not specific to CUBIC. Undo involves a congestion control decision and as far as I remember IETF has never accepted a Stds Track RFC for congestion control actions without any evidence that demonstrates that the proposed cc actions are safe and correct. Why should this draft make an exception? Please see my reply to Neal concerning whether cc actions as currently proposed are safe and correct.\r\n\r\nIf the problem is shown to be common, then the text may better belong to sec 5.4 (Investigating a Range of Environments) than a section about difficult environments.\r\n \r\n> Second, it sounds like you don't just want to move the existing text, you are outlining an complete rewrite of what we have. It would be more actionable if you could propose a draft of the concrete text you think should be there (ideally, as a PR.)\r\n\r\nYes, it requires much more consideration and analysis than the current piece of text in this draft. In particular, if one wants to specify a new mechanisms to restore state or a mechanism that deviates from the one for which we have a stds track specification (RFC 4015). \r\nI may help in writing the text for sec 5.3/5.4 but I don't have any measurement results that demonstrate the problem and how common the problem is. ",
          "createdAt": "2021-10-18T12:38:05Z",
          "updatedAt": "2021-10-18T12:38:05Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "> Re: \"Much is documented in those RFCs but not all, e.g., response to spurious fast rexmits never materialised.\"...\r\n> \r\n> Even if RFCs for responding to spurious fast retransmits never happened, the code to do that has been widely deployed and used in the Internet with good results, including at least in Linux TCP for over a decade. Since implementations are doing it, we may as well tell them how to do it well. :-)\r\n\r\nYes, UNDO has been there in Linux well be before CUBIC was invented. But UNDO being implemented in Linux does not alone provide any evidence that doing UNDO like rfc8312bis proposes is the right way to do it. ;)\r\n\r\nI fully agree that it is important to tell how to restore cc state \"well\" but the problem is exactly that this draft does not do it now. In other words, you are saying and supporting that it is all ok to   \r\nrestore cc state such that after a detection algo figures that it was false fast rexmit the TCP sender,    \r\n\r\na) blasts a full cwnd worth data at line speed,\r\nb) does not consider adjusting dupack treshold to avoid further false rexmits,\r\nc) does not need to be prepared for a lying receiver that can easily make a fast rexmit to appear as a spurious rexmit, i.e., it is fine make it easy to fool the sender not to react to congestion at all?\r\n\r\n> Re: \"That's why I think it is not the best option from the process point of view to embed a response to spurious rexmits in this CUBIC spec as the problem area and solution is common to all CCs.\"...\r\n> \r\n> The solution is not common to all CCs, because the state variables for each CC are different. It is important for the CC spec to specify which variables need to be saved and restored if there is an undo event. That's why it's great that 8312bis covers those details.\r\n\r\nSure, I am not objecting to specifying which variables need to be saved and restored *in addition* to those that the existing RFCs already do and what is common to all CCs. But what I try to say is that this is the quite trivial part of the cc response to spurious rexmit.\r\n\r\nI'm objecting that this draft modifies RFC 4015 response to spurious RTOs such that after the undo\r\n\r\na) the TCP sender blasts a full restored cwnd worth of *unnecessary rexmits* at the bottleneck\r\n    line speed,\r\nb) does not adjust RTO and RTO calculation to avoid further spurious RTOs,\r\nc) executes UNDO even if it received the acceptable Ack with ECE,\r\nd) and more ...\r\n\r\nIt would be helpful for the discussion if everyone would read RFC 4015 and the related RFCs and compare what they say to what RFC8312bis says.\r\nI'm not saying that the existing RFCs are perfect but they contain useful advise that this draft rfc8312bis totally misses .",
          "createdAt": "2021-10-18T12:50:40Z",
          "updatedAt": "2021-10-18T12:50:40Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Could you propose a PR that would address your concerns? I think we'll keep missing things otherwise.",
          "createdAt": "2021-10-18T13:52:49Z",
          "updatedAt": "2021-10-18T13:52:49Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "body": "> a) blasts a full cwnd worth data at line speed,\r\n\r\nThat's a separate problem. Restart from idle does that as well. TCP implementations should use pacing to solve this problem of blasting full cwnds. Pacing is the only complete and general solution to blasting full cwnds, and it's orthogonal to CUBIC.\r\n\r\n> b) does not consider adjusting dupack treshold to avoid further false rexmits,\r\n\r\nThat's an orthogonal loss recovery issue, and belongs in a separate document focused on loss recovery. For example, the RACK RFC covers this kind of issue. It doesn't make sense to put this in a CUBIC document, because the CUBIC document doesn't know whether \r\n\r\n> c) does not need to be prepared for a lying receiver that can easily make a fast rexmit to appear as a spurious rexmit, i.e., it is fine make it easy to fool the sender not to react to congestion at all?\r\n\r\nInteractions between lying receivers and the detection of spurious loss recovery episodes are a loss recovery issue, not a congestion control issue, and belong in a loss recovery document.\r\n\r\n\r\n> Sure, I am not objecting to specifying which variables need to be saved and\r\n>  restored in addition to those that the existing RFCs already do and what\r\n> is common to all CCs. But what I try to say is that this is the quite\r\n> trivial part of the cc response to spurious rexmit.\r\n\r\nMost of the issues you are bringing up are loss recovery issues, not congestion control issues, and should be in a separate document, IMHO. IMHO the 8312bis is a CC document, and should effectively say something like: \"if your loss detection algorithm detects that a previous loss inference was spurious, then the CUBIC CC response is X\".\r\n\r\n\r\n> a) the TCP sender blasts a full restored cwnd worth of unnecessary rexmits\r\n> at the bottleneck line speed,\r\n\r\nIf the loss recovery has been undone, the sender is not in a loss recovery state, and thus would not retransmit anything.\r\n\r\n> b) does not adjust RTO and RTO calculation to avoid further spurious RTOs,\r\n\r\nThat's an orthogonal loss recovery issue about how to adjust the RTO calculation based on an undo even, and belongs in a separate document focused on loss recovery. \r\n\r\n> c) executes UNDO even if it received the acceptable Ack with ECE,\r\n\r\nThat's an orthogonal loss recovery issue about whether undo should happen, and belongs in a separate document focused on loss recovery. \r\n\r\n\r\n",
          "createdAt": "2021-10-18T14:03:02Z",
          "updatedAt": "2021-10-18T14:03:02Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "I read RFC 4015 and agree that it does cover all the safety requirements for restoring / undoing the congestion control state and how to update the RTO to further avoid spurious timeouts. So, it covers both updates to loss recovery and congestion control.\r\n\r\nAs a developer for QUIC spurious retransmit detection, congestion window restoring and changing the packet (dup ACK) and time threshold for loss detection, handling of special ACKs (CE counts), I do agree if all the responses to a spurious retransmit were in a single document, it would have made my life a bit easier.\r\n\r\n So, it might be a better idea to remove this section (section 4.9) completely. ",
          "createdAt": "2021-10-19T08:06:32Z",
          "updatedAt": "2021-10-19T08:06:32Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "If we do this,\r\n1. would this address @markkukojo's issues and\r\n2. would we need to cite RFC4015 and say something about it?",
          "createdAt": "2021-10-19T08:09:25Z",
          "updatedAt": "2021-10-19T08:09:46Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "No, I don't think we need to cite anything. Folks who would want to implement Eifel response would follow RFC 4015",
          "createdAt": "2021-10-19T08:25:27Z",
          "updatedAt": "2021-10-19T08:25:27Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "We added that section in response to #23, and there was quite a bit of discussion and support for it. It seems odd to go back on this now?",
          "createdAt": "2021-10-19T09:04:23Z",
          "updatedAt": "2021-10-19T09:04:23Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "I know but what we added is trivial (reset the state to previous state).\r\nIt needs more work and probably can be better placed in a new RFC that tackles spurious retransmits. Reverting the state to previous needs to be more methodical than what we proposed. Esp, as the link condition could have changed from previously restored state to current state.",
          "createdAt": "2021-10-28T06:23:28Z",
          "updatedAt": "2021-10-28T06:23:28Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "OK. Could we get some others to chime on on removing this section? If there is consensus, I'll do a PR.",
          "createdAt": "2021-10-28T09:22:42Z",
          "updatedAt": "2021-10-28T09:22:42Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "body": "I strongly advocate to keep Section 4.9, \"Spurious Congestion Events\".\r\n\r\nSome responses to Vidhi's comments:\r\n\r\n> I know but what we added is trivial (reset the state to previous state).\r\n\r\nIt seems trivial once you write it down, but it's not obvious to implementors. The Linux TCP CUBIC code has had undo for a decade, but the undo of CUBIC is still incomplete and buggy because it only restores cwnd and ssthresh, not the CUBIC-specific values. Yuchung and I noticed this years ago, but didn't have development resources to fix it given that our team had moved on to a different congestion control algorithm. So one of the widest-used CUBIC implementation is still getting undo wrong. Yuchung and I were planning to resurrect and finish our in-progress patch to fix this to match 8312bis when 8312bis settled down. But if 8312bis omits this then Linux CUBIC undo and other implementations will lose momentum and/or fail to get it right.\r\n\r\nEven just specifying the set of variables to restore is hugely valuable, and will save the world from having more buggy implementations like Linux TCP CUBIC.\r\n\r\n> It needs more work and probably can be better placed in a new RFC that tackles spurious retransmits.\r\n\r\nThe 8312bis section on undo doesn't need more work, IMHO, because this draft doesn't need to specify everything that a TCP stack needs to do to handle undo events; it only needs to cover what CUBIC's response to an undo event should be.\r\n\r\nEven if someone later writes a new RFC that tackles spurious retransmits, it doesn't make sense for that future spurious retransmit RFC to specify all the variables settings that every IETF-documented CC algorithm (Reno, CUBIC, DCTCP, etc) should make upon undo events.\r\n\r\nFrom a protocol specification and software engineering standpoint, we should try to strictly separate loss detection/recovery (including detecting spurious retransmission events) from congestion control (including how to undo a congestion response, if the loss detection module decides to undo). In software engineering terms,  loss recovery drafts should cover whether to call cc->handle_loss() and cc->handle_undo_loss(), and this rfc8312bis should cover what cc->handle_loss() and cc->handl_undo_loss() do.\r\n\r\n> Reverting the state to previous needs to be more methodical than what we proposed.\r\n\r\nWhat is proposed is quite methodical and sufficient as far as CUBIC CC goes. Loss detection/recovery should make its own specification for what the loss detection/recovery algorithm need to do upon detection spurious recovery events, which the RACK RFC already does (spurious loss recovery events raise the reordering window).\r\n\r\n> Esp, as the link condition could have changed from previously restored state to current state.\r\n\r\nAll the existing algorithms or detecting spurious loss recoveries (FRTO, DSACKs, Eifel TS-based undo) detect spurious loss recoveries in 1-2 round trips, so in practice the link conditions change very little. Just restoring the CC algorithm state to what it was before the spurious loss episode is excellent in practice, in our experience looking at real-world traces on YouTube, google.com, and internal RPC traffic: it's simple and robust, and far better than not undoing at all, given that reordering is not rare, and will likely become more common over time.\r\n\r\nIf link conditions have changed and available bandwidth has decreased, then in practice the flow will see loss/ECN soon, and slow down. But in practice when there are undo events this is usually due to radio layer delay fluctuations or reordering, not due to sustained reductions in available bandwidth.\r\n",
          "createdAt": "2021-10-28T13:11:08Z",
          "updatedAt": "2021-10-28T13:11:08Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with @nealcardwell that it is better to keep this subsection, as we have noticed that several issues/bugs (not just cubic) are/were related to the undo component. We do not need to specify when to undo, but instead specify which variables to undo. ",
          "createdAt": "2021-10-28T13:50:20Z",
          "updatedAt": "2021-10-28T13:50:20Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Thanks. Then @markkukojo needs to be a bit more specific about what changes he would want to see in the section to address his issue.",
          "createdAt": "2021-10-28T17:08:32Z",
          "updatedAt": "2021-10-28T17:08:32Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "My sincere apologies again not being able to respond earlier (unfortunate force major for me).\r\n\r\nAbout slow start start text in Sec 4.10:\r\n\r\nI've already suggested text to replace the current one and explained the rationale. \r\nI try to repeat briefly. The current text is impossible; CUBIC or any other CC cannot replace RFC 5681 slow start by HyStart++ in general because HyStart++ is applicable to initial slow start only. It cannot be used during the slow start in RTO recovery! \r\n\r\nPlease see draft-ietf-tcpm-hystartplusplus, Sec 4.3:\r\n   An implementation SHOULD use HyStart++ only for the initial slow\r\n   start (when ssthresh is at its initial value of arbitrarily high per\r\n   [RFC5681]) and fall back to using traditional slow start for the\r\n   remainder of the connection lifetime.\r\n\r\nThe problem with overshoot and the MD factor to use is present in the RTO recovery as well because a pkt loss may be detected before cwnd reaches ssthresh (even though HyStart++ suggest differently).\r\n \r\nPlease see shortly my reply to Bob in #85 where I clarify this further.",
          "createdAt": "2021-11-11T09:00:31Z",
          "updatedAt": "2021-11-11T09:00:31Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "About spurious retransmissions and response to such events (Sec 4.9):\r\n\r\nI agree with Vidhi that the issues and the response to spurious rexmits is not that trivial. I also agree with Neal that the issues related to response I listed belong to another document.\r\n\r\nHowever, Neal suggests for some reason that those issues are loss recovery issues which sounds very weird to me. We are discussing spurious rexmit detection and response when such event is detected; when a spurious rexmit is detected there is no loss recovery by definition because detecting a spurious rexmit avoids/terminates loss recovery. \r\n\r\nInstead, this topic was extensively studied and considered at the time  of writing RFC 3522, RFC 5682, RFC 3708, and RFC 4015. The IETF decided to handle spurious rexmits by separating the detection and response in separate documents and it is the current IETF consensus as documented in these RFCs. The decision was to not include any response actions in the detection documents but to put all actions related to response in the response documents. These actions include congestion control actions and any other actions that were considered important for a sender to take.  This of course is not the only possibly way to organize RFCs for handling the issues, but it is what IETF  currently has agreed on. We may change this but it requires someone to volunteer rewriting all these documents.\r\n\r\nThe response actions are currently documented in RFC 4015 for detected spurious RTOs. AFAIK IETF has never accepted a standards track RFC that modifies existing congestion control and/or related important actions without appropriate experimental data to support such a change. AFAIK nobody has presented any data for discussion in TCPM wg that would support ignoring/modifying RFC 4015 response. Maybe chairs can clarify whether this is the case? \r\n\r\nIMO the only thing that this draft is subject to present w.r.t. response to a spurious RTO is the additional congestion control variables that needs to be stored/restored for CUBIC, that is,  W_max, K, epoch_start, and W_est.\r\n\r\nI am happy to suggest text for this, if we can agree on this.\r\n\r\nFor spurious fast rexmits we do not have a response RFC for various reasons that I have tried to explain and do try to clarify here further.\r\n\r\nFirst of all, again, it is not that trivial as this draft suggests and Neal seems to think. When a false rexmit is detected there are various different scenarios that require different handling and the response also depends on the detection method used. I believe that Neal mainly considers using DSACK-based detection? If DSACK is used, the fast recovery is over and all related ACKs have been received when the decision is made, i.e., there should not be any data segments in flight that were injected during the fast recovery. In this case the response is much more trivial and more closer to what this draft suggests. However,  using RFC 3708 to detect false rexmits and applying an UNDO CC response to *is not* ready for standard track for security reasons! There is no working solution for RFC 3708 algorithm against lying receivers, meaning that it is very easy to device a TCP receiver that avoids cwnd reductions in case of pkt loss! TCPM chairs would need to address this in their writeup and I would be suprised if such draft would pass SECDIR review or actually I would expect TCPM not to decide forwarding such proposal for publication.\r\n\r\nIf Eifel (RFC 3522) is used to detect false rexmits, the response must be more complex, because there might be a half a window worth spuriously rexmitted data segments in flight when Eifel detects the spurious false rexmit. That is, a trivial case where the reordering extent (distance) is small (just enough to trigger a false fast rexmit) and maybe one or a few segments only got reordered (delayed). In such a case, a new ACK arrives only almost immediately after the false fast  rexmit and maybe it is the only segment unnecessarily rexmitted. However, if segments are delayed such that they arrive at the receiver as the last segments in the current window and there is a relatively large chunk of segments reordered (maybe half of the window) and SACK is in use, the sender unnecessarily rexmits half a window of segments before Eifel detects that the fast rexmit was spurious. And, when Eifel detects it, it does not know what has \r\nhappened to the rest of the window, i.e., whether it was unnecessarily rxmitted or if actually those segments were lost (or some of them). Therefore, the response algorithm must take this into account and it must not blindly restore the old value of cwnd. Unfortunately, the original Eifel paper did not properly cover different possible reordering cases (nor did we when Eifel RFCs were prepared if I recall it correctly). So, we do not have a proper response   algorithm for Eifel-detected false fast rexmits nor has anyone presented any data on how UNDO works with Eifel detection in various different scenarios.\r\nMoreover, AFAIK there is no data ever gathered and presented on how the safe version of Eifel performs. Therefore, IMHO a response for spurious false rexmits is definitely not ready for standards track.\r\n\r\nI think we all agree that the problem of spurious rexmits is important to solve and it should be properly. Therefore, IMO we should handle these in separate documents common to all CCs as we already did for spurious RTOs (which actually needs an update), not in this draft without any evidence presented to the wg for making the decision.",
          "createdAt": "2021-11-11T10:39:00Z",
          "updatedAt": "2021-11-11T10:39:00Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@markkukojo I presented your objections on this topic at the TCPM IETF meeting today (still Nov 11th in PST) and I see two problems that are a bit tricky to solve.\r\n\r\n1. The response described in RFC 4015 for setting cwnd is very conservative. It sets cwnd to flight size + min(IW, bytes_acked), which could be very low if the spurious detection happens at the tail of the window.\r\n2. Spurious RTOs are less common than spurious fast retransmits in TCP. For QUIC, there are no spurious RTOs as the only way to detect losses is after receiving an ACK, which is equivalent to fast retransmits. So, QUIC implementations wouldn't be able to take advantage of spurious detection.\r\n\r\n> AFAIK IETF has never accepted a standards track RFC that modifies existing congestion control and/or related important actions without appropriate experimental data to support such a change. \r\n\r\nI have not attended all IETF meetings in the past, so I can't say what data may or may not have been presented. But I can say for sure that there are many QUIC implementations (including ours) that are doing UNDO on detection of spurious retransmits and the improvement in throughput was significant for us to keep using it. If you'd like I can get an exact number of how many implementations that are widely deployed are doing this.\r\n\r\nSo, I am starting to lean towards this approach. How about we document how CUBIC should respond to spurious events due to, a. RTOs and\r\nb. fast retransmits.\r\n\r\nWe can use RFC 4015's response for  a. and we can do the UNDO method for b. (backed by multiple QUIC deployments)\r\n",
          "createdAt": "2021-11-12T07:07:35Z",
          "updatedAt": "2021-11-12T07:08:47Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "body": "@goelvidhi \r\n> How about we document how CUBIC should respond to spurious events due to,\r\n> a. RTOs and\r\n> b. fast retransmits.\r\n\r\nThis sounds good to me. Thanks, Vidhi!\r\n\r\n@markkukojo said:\r\n>  I believe that Neal mainly considers using DSACK-based detection?\r\n\r\nAs I noted,I'm referring to several different detection mechanisms:\r\n\"(FRTO, DSACKs, Eifel TS-based undo)\". :-)\r\n\r\n> There is no working solution for RFC 3708 algorithm against lying receivers\r\n\r\nIf we're going to stop work based on lying receivers, this is going to hold\r\nup all TCP congestion control and loss recovery work unreasonably. As\r\nhas been clear since at least 1999 (\"TCP Congestion Control with a\r\nMisbehaving Receiver\"), TCP has no crypto/nonce mechanism for\r\nreceivers to prove what they have received, so receivers can always\r\nlie and claim they have received all packets, and thus cause the\r\nsender to send as fast as the sender hardware and application will\r\nallow, defeating just about any existing TCP congestion control or loss\r\nrecovery mechanism.\r\n\r\n> So, we do not have a proper response algorithm for Eifel-detected false fast rexmits\r\n\r\nI believe we do have such an algorithm, even if it's not documented\r\nyet in an IETF document: Linux TCP has a proper response algorithm for\r\nEifel-detected false fast rexmits, which properly handles the case you\r\nmention since 2013 (patch was by @yuchungcheng):\r\n\r\nhttps://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git/commit/?id=7026b912f97d912476dff5465ed9a127be094208\r\n\r\n> I think we all agree that the problem of spurious rexmits is important\r\n> to solve and it should be properly. Therefore, IMO we should handle\r\n> these in separate documents common to all CCs as we already did for\r\n> spurious RTOs (which actually needs an update), not in this draft\r\n> without any evidence presented to the wg for making the decision.\r\n\r\nI think this passage is missing a key distinction. I think it is\r\nuseful to make a distinction between:\r\n\r\n(a) How the TCP connection as a whole, and loss detection, and\r\ndetection of spurious retransmits should decide when to undo a\r\nspurious loss detection event.\r\n\r\n(b) What the congestion control module should do when the logic in (a)\r\ndecides that a loss detection event was spurious.\r\n\r\nI continue to argue that it is useful and best for 8312bis to document\r\nthe (b) aspect of CUBIC. Partly because integrating the (b) aspect of\r\nCUBIC into some future draft about (a) would be something of a\r\nmodularity violation, in that it would needlessly drag the details of\r\nCUBIC state variables into what ideally should be a largely\r\ncongestion-control-agnostic document about (a).\r\n",
          "createdAt": "2021-11-12T19:00:41Z",
          "updatedAt": "2021-11-12T19:00:41Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Could we drive this issue to closure, please?",
          "createdAt": "2021-12-13T16:24:17Z",
          "updatedAt": "2021-12-13T16:24:17Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "I will send out a PR in a day or two.",
          "createdAt": "2021-12-14T07:02:00Z",
          "updatedAt": "2021-12-14T07:02:00Z"
        }
      ]
    },
    {
      "number": 91,
      "id": "MDU6SXNzdWU5ODM3MTgzOTk=",
      "title": "Discussion in Sec 5. brings up surprisingly little data",
      "url": "https://github.com/NTAP/rfc8312bis/issues/91",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "lisongxu"
      ],
      "labels": [],
      "body": "[Markku Kojo said](https://mailarchive.ietf.org/arch/msg/tcpm/nd4Af8QRQMDkp_R_9ZQMkI4yGAc):\r\n> I regret to say that the discussion in Sec 5. brings up surprisingly little data to back up the claims that are made. Given the long deployment experience that is emphasised in the draft, there, however, is little evidence (measurement data) summarised and cited to back up the claims. \"There is a long deployment experience\" does not provide any evidence as such. There should be a lot of studies with measurement data accumulated over the years that would support the assertions in the doc. Or, is there?",
      "createdAt": "2021-08-31T10:48:59Z",
      "updatedAt": "2021-11-09T06:15:13Z",
      "closedAt": "2021-11-09T06:15:13Z",
      "comments": [
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@lisongxu, any update?",
          "createdAt": "2021-09-16T14:00:04Z",
          "updatedAt": "2021-09-16T14:00:04Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@lisongxu ping",
          "createdAt": "2021-10-11T07:26:17Z",
          "updatedAt": "2021-10-11T07:26:17Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert @lisongxu We have maintained a website for more than 10 years (2005 - 2016) showing the performance of CUBIC over many different networks. That site is gone now. I will try to find a comprehensive measurement study instead.",
          "createdAt": "2021-10-16T06:55:36Z",
          "updatedAt": "2021-10-16T06:55:36Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "@lisongxu We have a COMNET paper that evaluates CUBIC along with the other protocols w/ and w/o background traffic. Our INFOCOM convex ordering paper shows evidence of its stability.  Another COMNET paper \"Taming the elephant..\" also has real-world results as well. Adding a few experimental study papers after that may be enough.",
          "createdAt": "2021-10-16T07:09:17Z",
          "updatedAt": "2021-10-16T07:09:17Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "If the site is on archive.org, we might be able to link to that?",
          "createdAt": "2021-10-16T08:19:30Z",
          "updatedAt": "2021-10-16T08:19:30Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert Indeed, I found those. While I read Markku's comment about \"There is a long deployment experience,\" I am not sure if there is better evidence than the fact CUBIC has been used in Linux for more than a decade and later Windows and macOS. While I am searching the measurement studies, there are too many papers to cite, which is not feasible, so I am adding a few references of mine and also a few recent studies.\r\n\r\n@lisongxu There are a lot of measurement studies including ours and we may cite a few of them if needed. \r\n\r\n- NS2 evaluation results, Dummynet testbed results, and internet evaluations\r\nhttps://web.archive.org/web/20161118125842/http://netsrv.csc.ncsu.edu/wiki/index.php/TCP_Testing\r\n\r\n- Dummet experiments w/ and w/o background traffic\r\nhttps://web.archive.org/web/20161103143537/http://netsrv.csc.ncsu.edu/highspeed/\r\n\r\n- CUBIC's stability experiments\r\nhttps://web.archive.org/web/20160122052654/http://netsrv.csc.ncsu.edu/convex-ordering/\r\n\r\n- Technical Report on evaluating TCP congestion control protocols \r\nhttps://netstech.org/asteppaper.htm\r\n\r\n- Internet evaluation of HyStart\r\nSangtae Ha and Injong Rhee, \u201cTaming the Elephants: New TCP Slow Start,\u201d Elsevier Computer Networks, vol. 55, no. 9, pp. 2092\u20132110, 2011.\r\n\r\n- Impact of background traffic to CUBIC and the other TCP congestion control protocols.\r\nSangtae Ha, Long Le, Injong Rhee, and Lisong Xu, \u201cImpact of Background Trac on Performance of High-Speed TCP Variant Protocols,\u201d Elsevier Computer Networks, vol. 15, no. 4, pp. 852\u2013865, 2007.\r\n\r\n- Stability analysis of CUBIC\r\nHan Cai, Do Young Eun, Sangtae Ha, Injong Rhee, and Lisong Xu, \u201cStochastic Convex Ordering for Multiplicative Decrease Internet Congestion Control,\u201d Elsevier Computer Networks, vol. 53, no. 3, pp. 365\u2013381, 2009. \r\n\r\n- Two recent measurement papers among many\r\nSalman Muhammad, Touseef Javed Chaudhery, Youngtae Noh, \"Study on Performance of AQM schemes over TCP Variants in Different Network Environments,\", IET Communications, Vol. 1(19), 2021.\r\nJ. Gomez, E. Kfoury, J. Crichigno, E. Bou-Harb and G. Srivastava, \"A Performance Evaluation of TCP BBRv2 Alpha,\" 2020 43rd International Conference on Telecommunications and Signal Processing (TSP), 2020, pp. 309-312",
          "createdAt": "2021-10-18T16:39:42Z",
          "updatedAt": "2021-10-18T16:39:42Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Let's add some text about and references to some (or all) of those and assume the issue is addressed.",
          "createdAt": "2021-10-18T17:40:07Z",
          "updatedAt": "2021-10-18T17:40:07Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@lisongxu/@sangtaeha  could we get a PR for this, please?",
          "createdAt": "2021-11-01T09:47:44Z",
          "updatedAt": "2021-11-01T09:47:44Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert I will get a PR this weekend. Thanks",
          "createdAt": "2021-11-03T13:38:46Z",
          "updatedAt": "2021-11-03T13:38:46Z"
        }
      ]
    },
    {
      "number": 92,
      "id": "MDU6SXNzdWU5ODM3MTg4OTM=",
      "title": "Sec 5.1",
      "url": "https://github.com/NTAP/rfc8312bis/issues/92",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "lisongxu"
      ],
      "labels": [],
      "body": "[Markku Kojo said](https://mailarchive.ietf.org/arch/msg/tcpm/nd4Af8QRQMDkp_R_9ZQMkI4yGAc):\r\n>Sec 5.1\r\n>\r\n>In this subsection, one should show the impact of CUBIC when competing with AIMD TCP. The numbers in tables are derived from\r\nanalytical models that give average window size with fixed random loss probabilities and unlimited bandwidth. That is not the same as when flows are combeting in the same congested bottleneck that builds a queue.\r\nLoss probabilities for different flows are likely to be different especially at lower levels of statistical multiplexing.\r\n>\r\n>The first para of sec 5.1 does not sound like true. Simply looking at the original CUBIC paper [HRX08] reveals that CUBIC dominates AIMD TCP (SACK TCP) in the regions where SACK TCP alone is able to fully utilize the available bandwidth (Figure 10 c up until 200 Mbps, and to some extent in Fig 10 a with 40 ms delay). And \u00edn all cases where SACK TCP alone is not able to utilize all available b/w, CUBIC steals multiple times more b/w from SACK TCP than what SACK TCP is not able to utilize. Figures 5 and 6 tell the same story. Has something changed and/or is there possibly data that provides alternative evidence.\r\n>\r\n>In addition, the recommended value for constant C and the two alternative values presented in the draft are the same as in the original paper. It would be interesting to see if there has been any experimentation with different values and what might be the outcome?",
      "createdAt": "2021-08-31T10:49:35Z",
      "updatedAt": "2021-11-01T09:47:14Z",
      "closedAt": "2021-11-01T09:47:14Z",
      "comments": [
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@lisongxu, any update?",
          "createdAt": "2021-09-16T13:59:54Z",
          "updatedAt": "2021-09-16T13:59:54Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert sorry for the delay, will catch up soon",
          "createdAt": "2021-09-17T02:43:16Z",
          "updatedAt": "2021-09-17T02:43:16Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @markkukojo \r\n\r\nYou are right that the analytical model \"gives average window size with fixed random loss probabilities and unlimited bandwidth.\" This demonstrates to some extent the AIMD friendliness (now referred to as Reno Friendliness in the document). \r\n\r\nThe original Cubic paper [HRX08] shows the experiment results when Cubic is competing with AIMD/Sack. Figure 10 shows that Cubic is friendly to Sack in low bandwidth or low RTT networks (although not exactly fair share). For example, in Fig 10(a), bandwidth=400Mbps, RTT=10 or 20ms; also in in Fig 10(b), bandwidth=10 -- 400 Mbps, RTT=10ms; Cubic is friendly to AIMD/Sack.\r\n\r\n\r\n\r\n",
          "createdAt": "2021-09-28T15:28:07Z",
          "updatedAt": "2021-09-28T15:28:07Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@markkukojo, please comment on the above?",
          "createdAt": "2021-10-11T07:26:02Z",
          "updatedAt": "2021-10-11T07:26:02Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "No response from @markkukojo in three weeks, closing.",
          "createdAt": "2021-11-01T09:47:13Z",
          "updatedAt": "2021-11-01T09:47:13Z"
        }
      ]
    },
    {
      "number": 93,
      "id": "MDU6SXNzdWU5ODM3MTkxOTc=",
      "title": "Sec 5.3",
      "url": "https://github.com/NTAP/rfc8312bis/issues/93",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "lisongxu"
      ],
      "labels": [],
      "body": "[Markku Kojo said](https://mailarchive.ietf.org/arch/msg/tcpm/nd4Af8QRQMDkp_R_9ZQMkI4yGAc):\r\n>Sec 5.3\r\n>\r\n>Any experimental data to summarize and cite?",
      "createdAt": "2021-08-31T10:49:58Z",
      "updatedAt": "2021-10-18T10:17:02Z",
      "closedAt": "2021-10-18T10:17:02Z",
      "comments": [
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@lisongxu, any update?",
          "createdAt": "2021-09-16T13:59:23Z",
          "updatedAt": "2021-09-16T13:59:23Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@lisongxu ping",
          "createdAt": "2021-10-11T07:25:43Z",
          "updatedAt": "2021-10-11T07:25:43Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@markkukojo, sorry for the late response. This section/sentence \"\"CUBIC is designed to remedy the poor performance of Reno in fast and long-distance network\" is actually a summary of this document itself. \r\n\r\n@larseggert I would suggest closing this issue without any action. \r\n\r\nThanks",
          "createdAt": "2021-10-17T21:58:43Z",
          "updatedAt": "2021-10-17T21:58:43Z"
        }
      ]
    },
    {
      "number": 94,
      "id": "MDU6SXNzdWU5ODM3MTk1MzU=",
      "title": "Sec 5.4",
      "url": "https://github.com/NTAP/rfc8312bis/issues/94",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "lisongxu"
      ],
      "labels": [],
      "body": "[Markku Kojo said](https://mailarchive.ietf.org/arch/msg/tcpm/nd4Af8QRQMDkp_R_9ZQMkI4yGAc):\r\n>Sec 5.4\r\n>\r\n>The text correctly states that CUBIC fills queues faster than AIMD TCP and increases the risk of standing queues. Then it proposes queue sizing and AQM as a solution, which is odd. Applying AQM to keep the queues shorter of course decreases the RTT (delay) seen but it does not help with standing queues (they remain standing but are just shorter).",
      "createdAt": "2021-08-31T10:50:22Z",
      "updatedAt": "2021-10-22T13:01:45Z",
      "closedAt": "2021-10-22T13:01:45Z",
      "comments": [
        {
          "author": "bbriscoe",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The discussion under issue #89 is relevant here.\r\n\r\nAQMs help to reduce and in some cases remove the standing queue. An AQM target has to allow for different amplitude sawteeth for different RTTs. In true cubic mode, the brief downward excursions mean that utilization is less sensitive to an AQM target that is lower than the amplitude of the whole sawtooth - it only causes minor underutilization. So the combination of AQMs and true Cubic mode really does help _remove_ standing queues, not just reduce them.\r\n\r\nAnyway, the draft doesn't say that AQMs remove standing queues. \r\n\r\nSo, I think the draft is correct to point to AQM as a solution to the case of large buffers under 'difficult environments', and the authors might want to add something about the lower sensitivity to under-configured AQM targets, as above.\r\n\r\nNonetheless, I would criticize this section for not really addressing the 'difficult environments' that RFC5033 was talking about: \r\n\r\n- Radio: Cubic is pretty poor on fast adaptation, but still better than Reno. So I don't think we're going to find a reference that praises Cubic in this respect. Therefore, I suggest a sentence admitting Cubic isn't much better than Reno over radio links would be appropriate here. Slides [2](https://bobbriscoe.net/presents/1707ietf/1707tcp-prague-scaling-tensions.pdf#page=2) & [3](https://bobbriscoe.net/presents/1707ietf/1707tcp-prague-scaling-tensions.pdf#page=3) of an iccrg presentation we did summarize the wider problem of the slow adaptation of Cubic in radio environments, but again, other CCs are little better - the next slide moves on to Compound TCP for instance. A reference to [Liu16] would be worthwhile - it's the best paper I've read on the problems TCP CCs have over mobile (and Cubic specifically), and it identifies one major contributor to the problems (receive-window related so not specific to Cubic). \r\n- Multipath: No issue here relative to Reno AFAICT. No need to mention.\r\n- Tunnels, L2 AQMs, etc: No issue here for a loss-based CC. And any issues with ECN would be no different for Cubic relative to Reno. No need to mention.\r\n- High BDP: Surely this would be the place to call out Cubic's main strength.\r\n- Significantly slow links: No issue here relative to Reno AFAICT (assuming issue #83 is resolved).\r\n\r\n[Liu16] K. Liu and J. Y. B. Lee, \"On Improving TCP Performance over Mobile Data Networks,\" IEEE Transactions on Mobile Computing, 2016.",
          "createdAt": "2021-09-15T11:26:55Z",
          "updatedAt": "2021-09-15T11:26:55Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@bbriscoe: would you want to propose a PR that captures your considerations?",
          "createdAt": "2021-09-15T14:11:46Z",
          "updatedAt": "2021-09-15T14:11:46Z"
        },
        {
          "author": "bbriscoe",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No, not really. I've given some pointers above that should help. But I need to draw a line between helping vs turning rfc8312bis into my day job (and now becoming my evening job too). ",
          "createdAt": "2021-09-23T19:45:28Z",
          "updatedAt": "2021-09-23T19:45:28Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Understood. @lisongxu self-assigned this a while ago, so I'll let him do a PR based on your input.",
          "createdAt": "2021-09-24T06:23:52Z",
          "updatedAt": "2021-09-24T06:23:52Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@lisongxu would you prepare a resolution?",
          "createdAt": "2021-10-11T07:25:30Z",
          "updatedAt": "2021-10-11T07:25:30Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes. Thanks, @larseggert ",
          "createdAt": "2021-10-12T02:48:36Z",
          "updatedAt": "2021-10-12T02:48:36Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you all for the discussion.  @markkukojo @bbriscoe @vidhigoel-apple @larseggert  How about the following revised Section 5.4? The revised parts are indicated by the bold font.\r\n\r\n> There is decade-long deployment experience with CUBIC on the Internet. CUBIC has also been extensively studied by using both NS-2 simulation and testbed experiments, covering a wide range of network environments. More information can be found in [HKLRX06].\r\n> \r\n> Same as Reno, CUBIC is a loss-based congestion control algorithm. Because CUBIC is designed to be more aggressive (due to a faster window increase function and bigger multiplicative decrease factor) than Reno in fast and long-distance networks, it can fill large drop-tail buffers more quickly than Reno and increases the risk of a standing queue [RFC8511]. In this case, proper queue sizing and management [RFC7567] could be used to **mitigate the risk to some extent** and reduce the packet queuing delay.\r\n> \r\n> **Similar to Reno, the performance of CUBIC as a loss-based congestion control algorithm suffers in networks where a packet loss is not a good indication of bandwidth utilization, such as wireless or mobile networks [Liu16].** \r\n> \r\n> [Liu16] K. Liu and J. Y. B. Lee, \"On Improving TCP Performance over Mobile Data Networks,\" IEEE Transactions on Mobile Computing, 2016.\r\n> ",
          "createdAt": "2021-10-12T22:09:38Z",
          "updatedAt": "2021-10-12T22:12:05Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@lisongxu, thanks for the proposal - I made PR #123 for it.",
          "createdAt": "2021-10-13T13:52:53Z",
          "updatedAt": "2021-10-13T13:52:53Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@markkukojo, please review #123. I would like to close this issue.",
          "createdAt": "2021-10-15T06:52:16Z",
          "updatedAt": "2021-10-15T06:52:16Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "I'll try to review and answer this and the other pending issues ASAP. Unfortunately, I have very limited cycles for this right now so my apologies for the delay. After this week I hopefully could allocate more cycles.",
          "createdAt": "2021-10-19T10:20:23Z",
          "updatedAt": "2021-10-19T10:20:23Z"
        },
        {
          "author": "bbriscoe",
          "authorAssociation": "CONTRIBUTOR",
          "body": "WFM",
          "createdAt": "2021-10-19T10:51:59Z",
          "updatedAt": "2021-10-19T10:51:59Z"
        }
      ]
    },
    {
      "number": 95,
      "id": "MDU6SXNzdWU5ODM3MTk3OTM=",
      "title": "Sec 5.5",
      "url": "https://github.com/NTAP/rfc8312bis/issues/95",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Markku Kojo said](https://mailarchive.ietf.org/arch/msg/tcpm/nd4Af8QRQMDkp_R_9ZQMkI4yGAc):\r\n>Sec 5.5\r\n>\r\n>Setting lower bound of 2 MSS for cwnd with ECN may result in symptoms of congestion collapse with certain specific conditions, e.g., if the actual (physical) queue size is very large and there is a mix of ECN-capable (ECT) and not ECN-capable flows. When the number of ECN capable flows increase the start starving the not ECN-capable flows as ECT flows stop responding to congestion and start increasing the queue such that AQM has to drop almost all not ECT packets.",
      "createdAt": "2021-08-31T10:50:43Z",
      "updatedAt": "2021-09-02T05:38:01Z",
      "closedAt": "2021-09-02T05:38:01Z",
      "comments": [
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert @goelvidhi Is this one the same as or very similar to [issue #83](https://github.com/NTAP/rfc8312bis/issues/83) ?",
          "createdAt": "2021-09-01T14:21:11Z",
          "updatedAt": "2021-09-01T14:21:11Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes. Dup of #83.",
          "createdAt": "2021-09-02T05:38:01Z",
          "updatedAt": "2021-09-02T05:38:01Z"
        }
      ]
    },
    {
      "number": 96,
      "id": "MDU6SXNzdWU5ODM3MjAxMTA=",
      "title": "Sec 5.6",
      "url": "https://github.com/NTAP/rfc8312bis/issues/96",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "lisongxu"
      ],
      "labels": [],
      "body": "[Markku Kojo said](https://mailarchive.ietf.org/arch/msg/tcpm/nd4Af8QRQMDkp_R_9ZQMkI4yGAc):\r\n>Sec 5.6\r\n>\r\n>Competing CUBIC flows will converge but it happens very slowly and requires a large amount of data to send, i.e., short flows are more unlikely to live long enough to converge. This seems to be case at least according to the results in original paper [HRX08, Fig 4 b].\r\nSummary and citing some performance data would be very useful and much more convincing.",
      "createdAt": "2021-08-31T10:51:06Z",
      "updatedAt": "2021-11-03T11:43:13Z",
      "closedAt": "2021-11-03T11:43:13Z",
      "comments": [
        {
          "author": "bbriscoe",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See [my comment](https://github.com/NTAP/rfc8312bis/issues/89#issuecomment-919896820) under #89, part of which duplicates this issue.",
          "createdAt": "2021-09-15T11:31:55Z",
          "updatedAt": "2021-09-15T11:31:55Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@lisongxu, any update?",
          "createdAt": "2021-09-16T13:59:08Z",
          "updatedAt": "2021-09-16T13:59:08Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, Markku! How about the following revised paragraphs?\r\n\r\nCUBIC ensures convergence of competing CUBIC flows with the same RTT in the same bottleneck links to an equal throughput. When competing flows have different RTT values, their throughput ratio is linearly proportional to the inverse of their RTT ratios. This is true independently of the level of statistical multiplexing on the link. The convergence time depends on the network environments (e.g., bandwidth, RTT) and the level of statistical multiplexing, as mentioned in Section 3.4. Generally, Cubic converges faster than Reno in fast and long-distance networks mainly due to its faster window increase function. \r\n\r\n",
          "createdAt": "2021-09-29T16:02:39Z",
          "updatedAt": "2021-09-29T16:02:39Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@markkukojo, please comment on the above?",
          "createdAt": "2021-10-11T07:25:04Z",
          "updatedAt": "2021-10-11T07:25:04Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the update and apologies for the delay (not now able to do this as a day job :(\r\n\r\nThere is a number of claims in this para. Each of them calls for evidence, i.e., performance data to summarise and cite that shows this really is the case. Otherwise, these claims do not have much value.\r\n\r\nThe last sentence starting \"Generally\" is not quite true. Convergence happens in two directions: 1) for acquiring more capacity when such capacity becomes available, and 2) for relinquishing capacity when congestion is encountered (e.g., more flows join to share the common bottleneck.\r\nIn the latter case (case 2), CUBIC is significantly slower due to larger beta and therefore CUBIC actually is unfair against Reno. But, the last sentence discusses CUBIC vs. Reno which actually is not in scope in Sec 5.6. ",
          "createdAt": "2021-10-12T00:00:48Z",
          "updatedAt": "2021-10-12T00:00:48Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @markkukojo. We will add some citations related to the convergence of cubic. ",
          "createdAt": "2021-10-17T22:09:50Z",
          "updatedAt": "2021-10-17T22:09:50Z"
        },
        {
          "author": "bbriscoe",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The best ref I know is below. Altho' it's a general Cubic evaluation, it focuses a lot on convergence, including insightful critique.\r\n\r\nLeith, D. J.; Shorten, R. N. & McCullagh, G. \"Experimental evaluation of Cubic-TCP\" Proc. Int'l Wkshp on Protocols for Future, Large-scale & Diverse Network Transports (PFLDNeT'07), 2007\r\n\r\nHere's my BiBTeX in case useful:\r\n\r\n@InProceedings{Leith07:Cubic_Eval,\r\n  author      = {Douglas J. Leith and Robert N. Shorten and G. McCullagh},\r\n  title       = {{Experimental evaluation of Cubic-TCP}{}},\r\n  booktitle   = {Proc. Int'l Wkshp on Protocols for Future, Large-scale \\& Diverse Network Transports (PFLDNeT'07)},\r\n  year        = {2007},\r\n  url         = {https://www.hamilton.ie/net/pfldnet2007_cubic_final.pdf},\r\n  affiliation = {Hamilton Inst.},\r\n  keywords    = {Data Communication, Networks, Internet, Quality of Service, QoS, Congestion Control, Rate Control, Algorithms, Protocols, Probing, Convergence},\r\n  owner       = {RJB},\r\n  timestamp   = {2010.10.07},\r\n}",
          "createdAt": "2021-10-19T11:02:12Z",
          "updatedAt": "2021-10-19T11:02:12Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@lisongxu could we get a PR for this, please?",
          "createdAt": "2021-11-01T09:46:41Z",
          "updatedAt": "2021-11-01T09:46:41Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, Bob! @bbriscoe That paper evaluated an earlier version of Cubic. The latest Cubic (since around 2008) has removed the window clamping for both the concave and convex regions, and thus improved the convergence for high BDP networks. ",
          "createdAt": "2021-11-01T16:09:12Z",
          "updatedAt": "2021-11-01T16:09:12Z"
        }
      ]
    },
    {
      "number": 97,
      "id": "MDU6SXNzdWU5ODM3MjA0NTM=",
      "title": "Sec 5.8",
      "url": "https://github.com/NTAP/rfc8312bis/issues/97",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "lisongxu"
      ],
      "labels": [],
      "body": "[Markku Kojo said](https://mailarchive.ietf.org/arch/msg/tcpm/nd4Af8QRQMDkp_R_9ZQMkI4yGAc):\r\n>Sec 5.8\r\n>\r\n>The MUST NOT requirement would be much better placed with other specifications in Sec 4 and would benefit from more accurate description.",
      "createdAt": "2021-08-31T10:51:32Z",
      "updatedAt": "2021-10-02T07:44:00Z",
      "closedAt": "2021-10-02T07:44:00Z",
      "comments": [
        {
          "author": "bbriscoe",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with Markku, that it would be best to move this 'MUST NOT' out of the discussion section to where it will be noticed by implementers.",
          "createdAt": "2021-09-15T11:34:15Z",
          "updatedAt": "2021-09-15T11:34:15Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@bbriscoe @markkukojo: would one of you want to propose a PR?",
          "createdAt": "2021-09-15T14:11:02Z",
          "updatedAt": "2021-09-15T14:11:02Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Or @lisongxu, since he self-assigned this issue?",
          "createdAt": "2021-09-16T13:58:51Z",
          "updatedAt": "2021-09-16T13:58:51Z"
        },
        {
          "author": "bbriscoe",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have proposed changes in a local topic branch, but I don't have permission to push it. Is this what you were expecting me to do?\r\n\r\nI've att'd a patch instead, in case it's useful.\r\n[app-limited.patch.txt](https://github.com/NTAP/rfc8312bis/files/7217609/app-limited.patch.txt)\r\n",
          "createdAt": "2021-09-23T12:47:56Z",
          "updatedAt": "2021-09-23T12:47:56Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@bbriscoe you create a PR by pushing your branch to a fork or this repo on GitHub, and then click the PR button.",
          "createdAt": "2021-09-23T14:05:53Z",
          "updatedAt": "2021-09-23T14:05:53Z"
        }
      ]
    },
    {
      "number": 98,
      "id": "MDU6SXNzdWU5ODM3MjA3NDA=",
      "title": "Sec 5.9",
      "url": "https://github.com/NTAP/rfc8312bis/issues/98",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "lisongxu"
      ],
      "labels": [],
      "body": "[Markku Kojo said](https://mailarchive.ietf.org/arch/msg/tcpm/nd4Af8QRQMDkp_R_9ZQMkI4yGAc):\r\n>Sec 5.9\r\n>\r\n>The statement made here is not convincing and is likely to be incorrect. E.g., CUBIC with larger decrease factor would most likely release capacity notably slower than AIMD TCP if there is sudden congestion.\r\n\r\n",
      "createdAt": "2021-08-31T10:51:53Z",
      "updatedAt": "2021-09-24T09:38:41Z",
      "closedAt": "2021-09-24T09:38:41Z",
      "comments": [
        {
          "author": "bbriscoe",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with Markku that the claim in the draft seems incorrect. Even with fast convergence, each reduction is a little less than Reno. It just needs to admit the difference, rather than saying there is no difference.",
          "createdAt": "2021-09-15T11:43:12Z",
          "updatedAt": "2021-09-15T11:43:12Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@bbriscoe @markkukojo: would one of you want to propose a PR?",
          "createdAt": "2021-09-15T14:10:48Z",
          "updatedAt": "2021-09-15T14:10:48Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Or @lisongxu, since he self-assigned this issue?",
          "createdAt": "2021-09-16T13:58:38Z",
          "updatedAt": "2021-09-16T13:58:38Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Is it better to just remove congestion from this statement? We already covered congestion events in the rest of the draft.\r\nSuggestion,\r\n\r\n```\r\nIf there is a sudden routing change or a mobility event, CUBIC behaves the same as AIMD TCP.\r\n",
          "createdAt": "2021-09-21T08:27:33Z",
          "updatedAt": "2021-09-21T08:27:33Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Fine with me. Thank, @goelvidhi ",
          "createdAt": "2021-09-21T14:20:55Z",
          "updatedAt": "2021-09-21T14:20:55Z"
        },
        {
          "author": "bbriscoe",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A section on sudden and transient events is meant to discuss\r\n`transient events such as sudden congestion, a routing change, or a mobility event.`\r\nThese are all still about congestion (after all its a congestion control algorithm), so it cannot not discuss congestion. The difference here is the suddenness.\r\n\r\nI'll post a PR, as Lars suggests, and see what you think. I'll briefly the difference after a sudden increase and a sudden decrease in capacity, relative to Reno.",
          "createdAt": "2021-09-23T18:04:28Z",
          "updatedAt": "2021-09-23T18:04:28Z"
        }
      ]
    },
    {
      "number": 99,
      "id": "MDU6SXNzdWU5ODM3MjEzMDA=",
      "title": "Section 8",
      "url": "https://github.com/NTAP/rfc8312bis/issues/99",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "larseggert"
      ],
      "labels": [],
      "body": "[Markku Kojo said](https://mailarchive.ietf.org/arch/msg/tcpm/nd4Af8QRQMDkp_R_9ZQMkI4yGAc):\r\n> The draft says in the intro that CUBIC is to be regarded as *current standard* for TCP congestion control. It sounds a bit like it would obsolete RFC 5681 which is not the intent. RFC 5681 still has its specific role as the document that gives the baseline and generic guidelines for TCP (and other) congestion control.\r\nInstead, I think this document should articulate very carefully its role among the congestion control algorithms. How, I am not sure. Maybe simply as an alternative for RFC5681 congestion avoidance and multiplicative decrease.\r\n>\r\n>Please note also that when specifying these algorithms this document is\r\nin direct conflict with a MUST in RFC5681 which says: \"however, a TCP MUST NOT be more aggressive than the following algorithms allow (that is, MUST NOT send data when the value of cwnd computed by the following algorithms would not allow the data to be sent).\"\r\nTherefore, the draft should make this differentation very clear maybe already in the abstract and justify the deviations much better than it currently does (accompanied with evidence = data). This is very important i order to make a convincing case why it is ok for this doc to deviate from the current Standards Track TCP normative statements.",
      "createdAt": "2021-08-31T10:52:36Z",
      "updatedAt": "2021-09-15T14:46:16Z",
      "closedAt": "2021-09-15T14:46:16Z",
      "comments": [
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "The first part is hopefully addressed by #104.\r\n\r\nThe second part sounds like we would need to formally update 5681, to allow for CUBIC's behavior? I have a proposal for this in #105.",
          "createdAt": "2021-08-31T12:46:28Z",
          "updatedAt": "2021-08-31T13:17:07Z"
        }
      ]
    },
    {
      "number": 100,
      "id": "MDU6SXNzdWU5ODM3MjE3MDA=",
      "title": "epoch_start",
      "url": "https://github.com/NTAP/rfc8312bis/issues/100",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [],
      "body": "[Markku Kojo said](https://mailarchive.ietf.org/arch/msg/tcpm/nd4Af8QRQMDkp_R_9ZQMkI4yGAc):\r\n>_epoch_start_: needs more accurate and consistent definition when the exactly the epoch starts. Is it when congestion event occurs or when TSP sender enters congestion avoidance first time after an congestion event. If it is  different in different scenarios that would be good to present systematically.\r\n",
      "createdAt": "2021-08-31T10:53:06Z",
      "updatedAt": "2021-09-27T13:52:30Z",
      "closedAt": "2021-09-27T13:52:30Z",
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@markkukojo, from the draft,\r\n>  _epoch_start_: The time in seconds at which the current congestion\r\n   avoidance stage started.\r\n\r\nSo, it is when the sender enters the congestion avoidance first. ",
          "createdAt": "2021-09-01T07:06:52Z",
          "updatedAt": "2021-09-08T04:27:40Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Markku, OK to close with no action?",
          "createdAt": "2021-09-01T12:09:44Z",
          "updatedAt": "2021-09-01T12:09:44Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@markkukojo, could you please let us know?",
          "createdAt": "2021-09-08T04:27:55Z",
          "updatedAt": "2021-09-08T04:27:55Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "No word from @markkukojo, closing this. @markkukojo, please reopen if you disagree.",
          "createdAt": "2021-09-15T14:47:45Z",
          "updatedAt": "2021-09-15T14:47:45Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "I made this note to myself in the early phase of reading the draft and it looks like that I was not very clear what seemed to be the problem. The definition of epoch_start in its brevity seems fine. However, now I see that it was more of its relation to _cwnd_start_ what confused me and in particular what the draft says in Sec 4.2: \r\n\"where _cwnd_start_ is the congestion window at the beginning of the\r\n current congestion avoidance stage.  For example, right after a\r\n congestion event, _cwnd_start_ is equal to the new cwnd calculated as\r\n described in Section 4.6.\"\r\n\r\nThe latter sentence starting \"For example, ...\" is confusing and unnecessary. It kind of hints that _cwnd_start_ would have the same value immediately after a congestion event and in the beginning of the congestion avoidance stage that follows. This is true when a TCP sender receives ECE, for example. I have noticed that some people think that cwnd would also have the same value in the beginning of loss recovery (i.e., after 3 DupAcks triggered Fast Retransmit) and after Fast Recovery completes (i.e., when a TCP sender enters congestion avoidance). Maybe it is because this true for TCP Reno loss recovery. However, it often is not the true with NewReno (RFC 6582) and SACK-based loss recovery (RFC 6675).\r\n\r\nI'd suggest deleting the sentence: \r\n\r\n\"For example, right after a congestion event, _cwnd_start_ is equal to the new cwnd calculated as described in Section 4.6.\"\r\n\r\nbecause it is unnecessary and more misleading than clarifying.",
          "createdAt": "2021-09-24T11:34:20Z",
          "updatedAt": "2021-09-24T11:34:20Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "ok, IIUC, this is unrelated to the original issue which talk about proper definition of epoch_start.\r\n\r\nI can create a PR to delete this line.",
          "createdAt": "2021-09-25T07:10:27Z",
          "updatedAt": "2021-09-25T07:10:27Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Closing this one in favor of #119.",
          "createdAt": "2021-09-27T11:53:39Z",
          "updatedAt": "2021-09-27T11:53:39Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Sorry, thought #119 was an issue, but it's a PR.",
          "createdAt": "2021-09-27T11:54:17Z",
          "updatedAt": "2021-09-27T11:54:26Z"
        }
      ]
    },
    {
      "number": 101,
      "id": "MDU6SXNzdWU5ODM3MjIwNTY=",
      "title": "(upon receiving) an ACK",
      "url": "https://github.com/NTAP/rfc8312bis/issues/101",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "larseggert"
      ],
      "labels": [],
      "body": "[Markku Kojo said](https://mailarchive.ietf.org/arch/msg/tcpm/nd4Af8QRQMDkp_R_9ZQMkI4yGAc):\r\n>In many occassions:\r\n>\r\n>\"(upon receiving) an ACK\" -> \"(upon receiving) a new ACK\"",
      "createdAt": "2021-08-31T10:53:32Z",
      "updatedAt": "2021-09-21T07:25:58Z",
      "closedAt": "2021-09-21T07:25:58Z",
      "comments": [
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Markku, #103 only fixes the one spot where the text said \"Upon receiving an ACK\". There are **many* more places where we use \"an ACK\" - which of those do you think need to be changed? ",
          "createdAt": "2021-08-31T12:41:03Z",
          "updatedAt": "2021-08-31T12:41:03Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "I didn't pass through all occurrences because this was a generic comment to be precise. So, throughout the document any occurrence of \"an/every/each ACK\" that is intended to refer only to an ACK that cumulatively acknowledges new data would be good to indicate exactly (to not leave any doubt that the actions must not be taken on arriving dupAcks or window updates).",
          "createdAt": "2021-09-15T16:26:39Z",
          "updatedAt": "2021-09-15T16:26:39Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Please take a look at #110. I think I found all the places now, but maybe there are some where the old phrasing was OK?",
          "createdAt": "2021-09-16T11:41:45Z",
          "updatedAt": "2021-09-16T11:41:45Z"
        }
      ]
    },
    {
      "number": 102,
      "id": "MDU6SXNzdWU5ODM3MjI2MzM=",
      "title": "On page 13",
      "url": "https://github.com/NTAP/rfc8312bis/issues/102",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [],
      "body": "[Markku Kojo said](https://mailarchive.ietf.org/arch/msg/tcpm/nd4Af8QRQMDkp_R_9ZQMkI4yGAc):\r\n>On page 13:\r\n>\r\n> \" the sender MAY employ a Fast\r\n   Recovery algorithm to gradually adjust the congestion window to its\r\n   new reduced _ssthresh_ value.\"\r\n>\r\n>I assume this is aiming at saying that something similar to PRR MAY be used to reduce cwnd. This, however, is somewhat vaguely said and using fasr recovery is misleading. We need to remember also that it might not be trivial to have it right. So, dunno whether it would be useful to drop this.",
      "createdAt": "2021-08-31T10:54:13Z",
      "updatedAt": "2021-10-13T06:28:23Z",
      "closedAt": "2021-10-13T06:28:23Z",
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@markkukojo, Not necessarily. RFC3782 describes an updated Fast Recovery for new Reno which can be used for CUBIC as well. RFC 6675 provides better loss recovery using SACK scoreboard. Or as you said, one can use PRR for better adjustments to congestion window. We should refrain from specifying what an implementation should use.",
          "createdAt": "2021-09-01T07:22:37Z",
          "updatedAt": "2021-09-08T04:27:22Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "Mayby I was not clear in my comment. Sure RFC 3782 and  RFC 6675 (and RFC 5681) Fast Recovery algorithms are applicable with CUBIC, but none of these Fast Recovery algorithms \"gradually adjust the congestion window to its new reduced ssthresh value.\"  As the name \"Fast Recovery\" indicates, these algorithms include loss recovery in addition to the intertwined congestion control actions. And, when ECN is used the ECN congestion response to ECE involves no Fast Recovery actions. So, it is unclear what this statement means and what an implementer could possibly do different from the actions listed in Sec 4.6?\r\n\r\nMore importantly. The draft says in Sec. 4.2: \r\n  \"It does not make any changes to the TCP Fast Recovery and Fast\r\n   Retransmit algorithms [RFC6582][RFC6675].\"\r\n\r\nBut it does modify  RFC6582, RFC 6675, and RFC 5681 Fast Retransmit&Fast Recovery by applying beta_cubic to cwnd, not FlightSize. This is incorrect and would bring back an old design&implementation bug that was corrected more than two decades ago when RFC 2581 was published (and subsequently corrected also for RFC 6582 and RFC 6675). Please see the implementation note attached to Equation (4) of RFC 5681: \"An easy mistake to make is to simply use cwnd, rather than FlightSize, which in some implementations may incidentally increase well beyond rwnd.\"\r\n\r\nUsing cwnd in the equation will also result in incorrect outcome in some other cases as well, for example, if the sender is application limited.\r\n\r\nPlease open a new issue to address this latter problem.",
          "createdAt": "2021-09-20T10:38:39Z",
          "updatedAt": "2021-09-20T10:38:39Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "For the first part, we can fix it by separating the losses from ECE,\r\nSomething like,\r\n```\r\nOn detecting a packet loss, the sender MAY employ a Fast Recovery algorithm to update\r\nthe congestion window to its new reduced ssthresh value at the end of loss recovery.\r\n```\r\n@markkukojo  Is this change enough for your first comment?\r\n\r\nI have filed a separate issue #114 for using FlightSize instead of cwnd.",
          "createdAt": "2021-09-21T09:12:55Z",
          "updatedAt": "2021-09-21T09:13:09Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "> For the first part, we can fix it by separating the losses from ECE,\r\n> Something like,\r\n> \r\n> ```\r\n> On detecting a packet loss, the sender MAY employ a Fast Recovery algorithm to update\r\n> the congestion window to its new reduced ssthresh value at the end of loss recovery.\r\n> ```\r\n> \r\n> @markkukojo Is this change enough for your first comment?\r\n\r\nNo, I don't think it is. It does not give any algorithm nor advise how to do it, and particularly, how to do it correctly. So, an implementer has no idea based on this text what to do as there is no *Fast Recovery* algorithm in the RFC series that would give a correct algorithm nor is there any reference to such an algorithm.\r\n\r\nI'm also still a bit unsure whether my assumption was correct in that this text would like to point to something like PRR (or rate-halving assuming that rate-halving could be adapted to a decrease factor other than 0.5)? Could you confirm, so we know that we are talking about the same thing. If it does, I think this document simply need not to say anything because the use of such an rate reduction algorithm during loss recovery is totally orthogonal to CUBIC and an implementer of CUBIC may select to use such an algorithm likewise an implementer of RFC 6675 or RFC 6582. E.g., PRR already has a placeholder for an MD factor other than 0.5, so it is all applicable with CUBIC. \r\n\r\nSo, maybe the simplest solution is just to delete the sentence? Or, am I possibly missing something?\r\n\r\n> I have filed a separate issue #114 for using FlightSize instead of cwnd.\r\n\r\nGood, thanks.",
          "createdAt": "2021-09-24T15:08:38Z",
          "updatedAt": "2021-09-24T15:08:38Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@markkukojo I remember that we used to point to PRR as an option - either we removed it or I am remembering incorrectly. Either way, we intend to tell the implementor that you don't have to set cwnd = cwnd * Beta right away when you see loss and you can use PRR or 6675 etc to do fast recovery and then at the end of recovery, set cwnd = ssthresh (cwnd * Beta).\r\n\r\nWe can provide a reference algorithm as a recommendation.",
          "createdAt": "2021-09-24T21:07:13Z",
          "updatedAt": "2021-09-24T21:09:46Z"
        }
      ]
    },
    {
      "number": 106,
      "id": "MDU6SXNzdWU5ODkyNTg0MzI=",
      "title": "Math is wrong",
      "url": "https://github.com/NTAP/rfc8312bis/issues/106",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "larseggert"
      ],
      "labels": [],
      "body": "[Issue found by Neal.](https://mailarchive.ietf.org/arch/msg/tcpm/ObgshX5PWlM71GtTkzGPrlWYxUI)",
      "createdAt": "2021-09-06T15:02:41Z",
      "updatedAt": "2021-09-07T06:24:27Z",
      "closedAt": "2021-09-07T06:24:27Z",
      "comments": []
    },
    {
      "number": 108,
      "id": "I_kwDOEpK-U847cBix",
      "title": "AIMD -> Reno",
      "url": "https://github.com/NTAP/rfc8312bis/issues/108",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "larseggert"
      ],
      "labels": [],
      "body": "Based on @bbriscoe's [email](https://mailarchive.ietf.org/arch/msg/tcpm/AYcFztqVPqZHj5s4UNIZmC-uAUI)",
      "createdAt": "2021-09-15T15:11:25Z",
      "updatedAt": "2021-09-28T07:24:48Z",
      "closedAt": "2021-09-28T07:24:48Z",
      "comments": []
    },
    {
      "number": 114,
      "id": "I_kwDOEpK-U847umUk",
      "title": "Use FlightSize instead of cwnd",
      "url": "https://github.com/NTAP/rfc8312bis/issues/114",
      "state": "CLOSED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [],
      "body": "@markkukojo said,\r\n> More importantly. The draft says in Sec. 4.2:\r\n\"It does not make any changes to the TCP Fast Recovery and Fast\r\nRetransmit algorithms [RFC6582][RFC6675].\"\r\n\r\n> But it does modify RFC6582, RFC 6675, and RFC 5681 Fast Retransmit&Fast Recovery by applying beta_cubic to cwnd, not FlightSize. This is incorrect and would bring back an old design&implementation bug that was corrected more than two decades ago when RFC 2581 was published (and subsequently corrected also for RFC 6582 and RFC 6675). Please see the implementation note attached to Equation (4) of RFC 5681: \"An easy mistake to make is to simply use cwnd, rather than FlightSize, which in some implementations may incidentally increase well beyond rwnd.\"\r\n\r\n> Using cwnd in the equation will also result in incorrect outcome in some other cases as well, for example, if the sender is application limited.",
      "createdAt": "2021-09-21T08:52:56Z",
      "updatedAt": "2021-10-25T11:49:42Z",
      "closedAt": "2021-10-25T11:49:42Z",
      "comments": [
        {
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "body": "Applying beta_cubic to cwnd describes correctly what Linux TCP CUBIC does, and IIRC what Windows TCP CUBIC does as well (from discussions with the MS TCP team). The Linux and Windows CUBIC behavior is very much intentional, since reducing cwnd based on FlightSize is not robust; it causes very poor performance in the very common application-limited case.\r\n\r\nI would suggest keeping the  text here as-is (cwnd = cwnd * beta_cubic), since this reflects the long-deployed behavior, and the more robust of the two options.\r\n\r\n",
          "createdAt": "2021-09-24T17:09:32Z",
          "updatedAt": "2021-09-24T17:09:32Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@nealcardwell thanks Neal and I agree with you.\r\n\r\n@markkukojo do you agree with Neal's comment?",
          "createdAt": "2021-09-24T20:55:15Z",
          "updatedAt": "2021-09-24T20:55:15Z"
        },
        {
          "author": "juhamatk",
          "authorAssociation": "NONE",
          "body": "If you leave the formula as it is, you'll need to change the claim: \"It does not make any changes to the TCP Fast Recovery and Fast Retransmit algorithms [RFC6582][RFC6675].\" to more descriptive of Cubic behaviour, right?",
          "createdAt": "2021-09-27T08:24:15Z",
          "updatedAt": "2021-09-27T08:24:15Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "In my understanding, Equation (4) of RFC 5681 is meant for the cases where rto expire. But, it seems to me these cases don't need to be covered in cubic draft. Or, am I missing something?",
          "createdAt": "2021-09-27T09:12:29Z",
          "updatedAt": "2021-09-27T09:12:29Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "body": "Equation (4) of RFC 5681 is meant for RTO cases, but it is also meant for Fast Recovery. See section 3.2, \"Fast Retransmit/Fast Recovery\":\r\n  https://datatracker.ietf.org/doc/html/rfc5681#section-3.2\r\nwhich says:\r\n      When the third duplicate ACK is received, a TCP MUST set ssthresh\r\n       to no more than the value given in equation (4)\r\n",
          "createdAt": "2021-09-27T14:17:09Z",
          "updatedAt": "2021-09-27T14:17:09Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "I'll reply to all comments in this.\r\n\r\nYoshi: \r\nEquation (4) in RFC 5681 is used both when RTO expires and when 3rd DupAck arrives: see Sec 3.2, Step 2. \r\nEquation (4) is represented only once in RFC 5681 and together with RTO just because of representational reasons as Slow Start & RTO are discussed first in Sec 3.1 and discussion on Fast Rxmit & Fast Recovery follows later in Sec 3.2. \r\n\r\nThis is also consistent with NewReno and SACK-based Fast Rexmit&Fast Recovery, see RFC 6582, Sec 3.2, Step 2 that points to step 2 of Section 3.2 of RFC 5681 and \r\nRFC 6675, Sec 5, Step 4.2. Please see more in my reply to Neal below. \r\n\r\nJuha-Matti: you are right, but it is more than that. Please see my reply to Neal below.\r\n\r\nNeal, all:\r\nThe use of FlightSize is intentional and consistently used in all current Stds Track RFC mentioned above. It is based on the IETF consensus for more than two decades and intended to prevent a TCP sender from not responding to congestion at all when the TCP sender is rwnd limited (or application limited) and it has increased its cwnd to a (very) high value beyond actual flight size. AFAIK, this is one of the major reasons why FlightSize was introduced in RFC 2581 and later adopted in all above mentioned RFCs.  It protects the network from (re)transmission of uncontrolled data in various scenarios.\r\n\r\nThis said, admittedly the use of FlightSize has its shortcomings because in some scenarios it may result in a very small cwnd after a congestion signal. I believe that's what Neal refers to by saying it is not robust? In addition, FlightSize does not provide any protection in cases where an application-limited or rwnd-limited TCP sender stops being limited and ends up transmitting at (notably) higher rate. \r\n\r\nHowever, if we leave the text as is, it results in bringing back the decades old problem because there are no safeguards. In addition, it would result in this draft text being in conflict with the current Standards Track RFCs. Such conflicting information clearly is not ideal as it would create inconsistency and confusion in the RFC series. \r\n\r\nSo, what would be the best way forward? These problems with application or rwnd limited TCP senders are not specific to CUBIC but the same regardless of which congestion control mechanism we are using. We need an update to the existing RFCs at some point as well. Therefore, I think a proper way to solve the problems is to solve them for all involved RFCs at once in a consistent way. We have RFC 7661 as experimental. Aren't the algos there appropriate enough to all known application-limited scenarios (assuming the equations are adjusted to apply to CUBIC as well)?\r\n\r\n",
          "createdAt": "2021-09-27T16:39:19Z",
          "updatedAt": "2021-09-27T16:39:19Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you for the discussions on this important issue! I agree that we need to change \"\"It does not make any changes to the TCP Fast Recovery and Fast Retransmit algorithms [RFC6582][RFC6675]\", which is not correct/accurate.\r\n\r\nBased on the comments of @markkukojo, it seems that it is safer to update ssthresh using FlightSize. \r\n\r\nIn addition to how ssthresh is calculated, a related issue is that currently Cubic cwnd is not updated according to the fast retransmit/recovery in RFC 5681/6582.  For example, [Step 6 in Serction 3.2 of RFC 5681:](https://datatracker.ietf.org/doc/html/rfc5681#section-3.2) \"When the next ACK arrives that acknowledges previously unacknowledged data, a TCP MUST set cwnd to ssthresh (the value set in step 2)\". However, currently Linux Cubic sets cwnd to ssthresh at the beginning of fast recovery instead of the end of fast recovery. @nealcardwell, right? thanks \r\n\r\n",
          "createdAt": "2021-09-27T18:36:57Z",
          "updatedAt": "2021-09-27T18:36:57Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "body": "Linux TCP CUBIC follows PRR and sets cwnd to ssthresh at the end of fast recovery (see tcp_end_cwnd_reduction() where it sets cwnd=ssthresh).\r\n\r\nFWIW it sounds good to me to have rfc8312bis document setting   ssthresh using FlightSize, given that this issue is mostly orthogonal to CUBIC (both Reno and CUBIC have the same question about setting ssthresh using FlightSize vs cwnd).\r\n",
          "createdAt": "2021-09-27T20:21:23Z",
          "updatedAt": "2021-09-27T20:21:23Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "neal, are you suggesting that we might need to update 5681? just curious.",
          "createdAt": "2021-09-27T22:05:13Z",
          "updatedAt": "2021-09-27T22:05:13Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "FWIW, the current editor's copy already updates 5681: https://tools.ietf.org/rfcdiff?url1=https://tools.ietf.org/id/draft-ietf-tcpm-rfc8312bis.txt&url2=https://NTAP.github.io/rfc8312bis/draft-ietf-tcpm-rfc8312bis.txt\r\n\r\nSo if we need to add other reasons for doing so, that is not an issue.",
          "createdAt": "2021-09-28T07:03:21Z",
          "updatedAt": "2021-09-28T07:03:21Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "body": "Personally I think the Reno and CUBIC RFCs  should use:\r\n   ssthresh = beta * cwnd\r\n(This is what Linux TCP has done since 2013).\r\n\r\nOr if the receiver window case mentioned by @markkukojo is a big concern, then perhaps something like:\r\n   ssthresh = beta * min(cwnd, rwnd)\r\n\r\nBut I don't think we need to hold up rfc8312bis if this is a controversial point, since it is somewhat orthogonal to CUBIC.\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2021-09-28T13:10:11Z",
          "updatedAt": "2021-09-28T13:10:11Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @nealcardwell . You are right that Linux Cubic sets cwnds to ssthresh at the end of fast recovery. \r\n\r\nBecause Reno(RFC5681)/NewReno(RFC6582)/Sack(RFC6675) all set ssthresh using FlightSize, and because Cubic does not intend to modify the fast retransmit and fast recovery algorithms of Reno/NewReno/Sack except the multiplicative decrease parameter, it would be better/consistent for this rfc8312bis to set ssthresh using FlightSize. \r\n\r\nWe may describe what is implemented in Linux/Window and why (\"since reducing cwnd based on FlightSize is not robust; it causes very poor performance in the very common application-limited case\").\r\n\r\n",
          "createdAt": "2021-09-28T14:55:41Z",
          "updatedAt": "2021-09-28T14:55:41Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good to me. Thanks!\r\n",
          "createdAt": "2021-09-28T15:12:30Z",
          "updatedAt": "2021-09-28T15:12:30Z"
        },
        {
          "author": "yuchungcheng",
          "authorAssociation": "NONE",
          "body": "I completely disagree the compromise to use FlightSize.\r\n\r\nUsing FlightSize has the detrimental performance effect when losses are encountered in application-limited case, which is prevalent in today's structured Internet application traffic. Consider a simple case where the application bursts and a drop occurs toward the end of the burst. At that time FlightSize is likely very small. Cubic is reducing the window based on an underestimated amount of volume during the congestion.\r\n\r\nEver since Cubic was invented, it has been using cwnd. Shouldn't this RFC reflect the Internet-wide decades long running implementation w better algorithm?\r\n\r\nNow on the \"Implementation Note: An easy mistake to make is to simply use cwnd, rather than FlightSize, which in some implementations may incidentally increase well beyond rwnd.\" in RFC5681. First why is cwnd going beyond rwnd an issue when the effective window is the min of the two? second can someone come up an example to illustrate such incident b/c I can't tell.\r\n\r\nI have indicated the same exact issue to Jana so I am glad RFC9002 QUIC does not repeat the mistake to use FlightSize\r\n(https://www.rfc-editor.org/rfc/rfc9002.html#name-recovery). I really want to stress the point using FlightSize simply makes TCP spec worse and out-sync'd of modern TCP implementations. It's really a mistake.",
          "createdAt": "2021-09-29T23:56:40Z",
          "updatedAt": "2021-09-29T23:56:40Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@yuchungcheng thank you for chiming in. We have been going back and forth about using `cwnd` vs `flight size` for ssthresh and therefore cwnd (at the end of recovery). There are two alternatives from this discussion:\r\n1. Continue to use `cwnd` and then update the text with,\r\n`Cubic updates the fast retransmit and fast recovery algorithms of Reno/NewReno/Sack to use cwnd to do multiplicative decrease after a congestion event as described in Section 4.6. This has proven to be more robust and provides better throughput and link utilization as seen with most modern implementations that have been deployed globally.`\r\n2. Change to using `flightsize` in Section 4.6 and add a caveat for lower throughput,\r\n`Since reducing congestion window based on FlightSize is not robust and can cause low throughput in the very common application-limited scenarios, most modern implementations use cwnd instead for better link utilization.`\r\n\r\nTo keep it more conservative and aligned with previous stds track RFCs, I am fine with option 2. We need to converge on this soon to unblock CUBIC from this orthogonal problem.\r\n",
          "createdAt": "2021-10-01T06:36:45Z",
          "updatedAt": "2021-10-01T06:36:45Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Which option do the major stacks use? IMO that is what the spec should recommend. We can discuss the implications of that choice and mention the other alternative, too.",
          "createdAt": "2021-10-01T06:38:44Z",
          "updatedAt": "2021-10-01T06:38:44Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> Which option do the major stacks use? IMO that is what the spec should recommend. We can discuss the implications of that choice and mention the other alternative, too.\r\n\r\nI don't know if this is the right question, I think for a stds RFC, a more important question is which option should the stacks use? Because the current implementations optimize for better throughput and that may or mayn't be the right recommendation. ",
          "createdAt": "2021-10-01T06:49:04Z",
          "updatedAt": "2021-10-01T06:49:04Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "In my mind, a main reason for doing 8312 and now 8312bis was to describe what the currently deployed CUBIC looks like, because the versions described in the papers and used in various simulators were really different.\r\n\r\nI'd therefore really like to describe what variant of CUBIC is currently deployed - it seems to work well enough with few enough downsides, right? If that is the case, why would we want to recommend something else for the spec?",
          "createdAt": "2021-10-01T07:39:02Z",
          "updatedAt": "2021-10-01T07:39:13Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "body": "] Which option do the major stacks use? \r\n\r\nLinux TCP CUBIC calculates ssthresh based on cwnd. Not sure about the other major stacks.\r\n\r\nI agree with Lars that it's far preferable to describe the CUBIC behavior that is currently deployed. Hopefully MS/Apple/Linux stacks agree on this point and we can have the RFC match that.\r\n\r\nI support something like Vidhi's option number 1 above (\"Continue to use cwnd and then update the text...\" ).\r\n",
          "createdAt": "2021-10-01T15:51:47Z",
          "updatedAt": "2021-10-01T15:51:47Z"
        },
        {
          "author": "yuchungcheng",
          "authorAssociation": "NONE",
          "body": "+1 what Neal and Lars said and option 1. Adding Parveen from Microsoft to\nhelp answer Lars' question on major Cubic implementation.\n\n\nVidhi: I agree that it is more important to publish an RFC based on what\n\"should\" TCP do, not just what \"are\" TCP stack doing. But that's the exact\nrationale we used to change Linux to use cwnd instead of inflight. What we\nhad observed with FlightSize is that loss usually happened toward the end\nof the flight (fifo queuing). Let's say inflight at the beginning of a\nround-trip is 100. The lost packet occurs at packet 90. the subsequent 3\nDUPACKs by packet 91,92,93 trigger fast recovery. at this moment FlightSize\nis down to 10 (number of unacked). Cubic will apply the beta and adjust\ncwnd to 10*0.7 = 7.\n\nAs you can tell, using FlightSize makes cwnd highly dominated by the\nlocation of the loss under application-limited scenario, not it's original\nreal flightsize that experienced the congestion.\n\n\nOn Fri, Oct 1, 2021 at 8:51 AM Neal Cardwell ***@***.***>\nwrote:\n\n> ] Which option do the major stacks use?\n>\n> Linux TCP CUBIC calculates ssthresh based on cwnd. Not sure about the\n> other major stacks.\n>\n> I agree with Lars that it's far preferable to describe the CUBIC behavior\n> that is currently deployed. Hopefully MS/Apple/Linux stacks agree on this\n> point and we can have the RFC match that.\n>\n> I support something like Vidhi's option number 1 above (\"Continue to use\n> cwnd and then update the text...\" ).\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/NTAP/rfc8312bis/issues/114#issuecomment-932347797>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AM5EPYFGQJZXTF7N4VYQ2KTUEXKJ7ANCNFSM5EN3H3UA>\n> .\n> Triage notifications on the go with GitHub Mobile for iOS\n> <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>\n> or Android\n> <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.\n>\n>\n",
          "createdAt": "2021-10-01T20:27:20Z",
          "updatedAt": "2021-10-01T20:27:20Z"
        },
        {
          "author": "pravb",
          "authorAssociation": "NONE",
          "body": "Both Windows TCP and MsQuic apply beta_cubic to cwnd and not FlightSize. We have had intense internal debates on this but we are erring towards higher performance in app limited cases. We also had briefly default enabled restarting cwnd upon idle for datacenter connections but had to revert due to application regressions. \r\n\r\nAdditionally, Windows TCP limits cwnd growth to not exceed the largest receive window advertised by the peer during connection lifetime. And MsQuic limits cwnd growth to not exceed 2*MaxFlightSize i.e. twice the maximum in flight during connection lifetime.",
          "createdAt": "2021-10-01T21:03:27Z",
          "updatedAt": "2021-10-01T21:03:27Z"
        },
        {
          "author": "pravb",
          "authorAssociation": "NONE",
          "body": "I too think Option 1 is better and add justification for deviation from prior standards track RFCs. ",
          "createdAt": "2021-10-01T21:11:14Z",
          "updatedAt": "2021-10-01T21:11:14Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Apple's stacks implement RFC 7661 and applies beta_cubic to `Max(pipeACK, LossFlightSize)` which is like option 2. \r\n\r\nI am happy to recommend option 1 considering the widespread deployment of Linux on the servers but I am sure there are some folks who will object that. Hoping to hear from them soon.\r\n",
          "createdAt": "2021-10-01T23:04:16Z",
          "updatedAt": "2021-10-01T23:08:05Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "I want to note that using FlightSize is good for persistent congestion (as we would be acting quickly to reduce sending rate based on congestion experienced on bytes in the network),\r\nwhereas,\r\nUsing CWND is good for transient congestion and drops unrelated to congestion, because we might recover without significantly reducing congestion window based on bytes in the network and instead continue to use a higher CWND assuming that the drop was not due to persistent congestion.",
          "createdAt": "2021-10-01T23:25:11Z",
          "updatedAt": "2021-10-01T23:25:51Z"
        },
        {
          "author": "yuchungcheng",
          "authorAssociation": "NONE",
          "body": "Vidhi: very interesting to hear Apple's approach which uses max(PipeAck,\nLossFlightSize)\n\nWhile it's not clear how exactly PipeACK is computed, I believe RFC7661 is\ntrying to mitigate the problem I raised. I would argue that Apple's\napproach is much closer to option 1 than option 2. In my previous email's\ntoy example, pipeACK would actually be around 100 instead of 10 because\nPipeACK is recording the maximum inflight in the most recent round-trip.\nWould that be the case in Apple's implementation?\n\nNeal and I have discussed this before. Our conclusion is the most precise\napproach is to record the flightsize on a per data packet basis. So in my\ntoy case, the starting loss packet would have a flightsize of 90.\nCongestion control should use this flight-size to reduce cwnd. But that has\na steep per-packet storage requirement.\n\nI would propose to capture our discussions in the RFC of pros & cons, and\nalso reflect the fact that some implementations use max(PipeAck,\nLossFlightSize), instead of the recommended cwnd. These insights and\nexamples would be valuable for future implementers, since congestion\ncontrol is often about trade-offs :-)\n\n\nOn Fri, Oct 1, 2021 at 4:25 PM Vidhi Goel ***@***.***> wrote:\n\n> I want to note that using FlightSize is good for persistent congestion (as\n> we would be acting quickly to reduce sending rate based on congestion\n> experienced on bytes in the network),\n> whereas,\n> Using CWND is good for transient congestion and drops unrelated to\n> congestion, because we might recover without significantly reducing\n> congestion window based on bytes in the network and instead continue to use\n> a higher CWND knowing that the drop was not due to persistent congestion.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/NTAP/rfc8312bis/issues/114#issuecomment-932631517>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AM5EPYBFDQKWNMT3D2BU7A3UEY7OFANCNFSM5EN3H3UA>\n> .\n> Triage notifications on the go with GitHub Mobile for iOS\n> <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>\n> or Android\n> <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.\n>\n>\n",
          "createdAt": "2021-10-02T00:18:24Z",
          "updatedAt": "2021-10-02T00:18:24Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "IMO what Apple stack does is the right thing to do. If I understood it correctly, it simply follows what we currently have in the RFC series:\r\nit applies FlightSize (=LossFlightSize) but implements also RFC 7661 that is meant to mitigate exactly the problem scenario which Yuchung described. RFC 7661 even mentions such a scenario explicitly.\r\nThat's why I asked whether RFC 7661 would be enough.\r\nIn the Yuchung's toy example pipeACK would be at least 89 (or 92 if SACK is in use), so the effect would be quite close to what it would be if FlightSize is recorded on per pkt basis (but without high storage requirements).\r\n\r\nThe problems with application-limited traffic are not new. It is a well-known issue and RFC 2861, the predecessor of RFC 7661, provides a nice overview of the problem space in its Intro (Sec 2). The FlightSize was selected to be the way to protect against use of invalid cwnd values for MD in the RFC series. It is not ideal, but it is the current way.\r\n\r\nI hope we are not selecting simply between the two options because neither of those is ideal.\r\n\r\nOption 1 is simply wrong as it would bring back an old, well-known problem currently avoided as documented in Stds Track RFCs. If the problem is not addressed, it easily results in behaviour where a rwnd or application-limited TCP sender does not react to congestion, because cwnd does not correctly reflect the currently available capacity but may have an arbitrarily high value. That is obviously bad for the Internet and not safe nor robust.\r\nLimiting cwnd growth like Windows TCP does help but cwnd may still be badly off in some usage scenarios.\r\n\r\nOption 2 is safe although it is known to be suboptimal for the performance of application-limited traffic. However, if RFC 7661 is adapted for CUBIC, we should have the same working solution for CUBIC as we have for the other CCs in the RFC series, right?\r\n\r\nI'd suggest the following way forward:\r\nUse option 2 and add a caveat, maybe something along the following lines:\r\n\r\nNote that a rate-limited application with idle periods or periods when unable to send at the full rate permitted by the congestion window may easily encounter notable variations in the volume of data sent from one RTT to another, resulting in FlightSize that is significantly less than congestion window on a congestion event. This may result in decreasing congestion window to a much lower value than necessary. To avoid suboptimal performance with such applications, mechanisms described in RFC 7661 [RFC7661] can be adapted to be employed with CUBIC. Appendix X provides guidelines for necessary modifications to the mechanisms in RFC 7661 when used with CUBIC.\r\n\r\nAs RFC 7661 is experimental it might be time to advance it to the Standards Track. Particularly, when it seems that application-limited scenarios are important to address and it seems to be possible to collect a good amount of experimental data to verify whether it works as intended and/or to provide data to tweak it as seen necessary.",
          "createdAt": "2021-10-05T23:30:40Z",
          "updatedAt": "2021-10-05T23:30:40Z"
        },
        {
          "author": "stewrtrs",
          "authorAssociation": "NONE",
          "body": "FreeBSD/NewReno uses cwin not flightsize. I have not looked at the other congestion control modules just newReno so Cubic or others may use something else. I do think that cwin is the right thing to use here. I can go look at the other modules if there is interest.. a quick look at cc_cubic shows it too uses cwin. So thats 2 out of 6 ;)",
          "createdAt": "2021-10-06T20:50:31Z",
          "updatedAt": "2021-10-06T20:50:31Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "body": "IMHO saying that basing sshtresh on cwnd \"easily results in behaviour where a rwnd or application-limited TCP sender does not react to congestion\" overstates the issue. Basing ssthresh on cwnd still reacts to congestion; it's just that it will take longer for the cwnd to converge down to the available capacity of the path.\r\n\r\nBut basing ssthresh on FlightSize can have the same issue (slow convergence down to the available capacity of the path); just to a different degree.\r\n\r\nIf we base ssthresh on cwnd, the connection will tend to take log_2(original_cwnd / available_volume) to converge to match the current available_volume.\r\n\r\nIf we base ssthresh on FlightSize, the connection will tend to take log_2(original_flightsize / available_volume) to converge to match the current available_volume.\r\n\r\nBecause log_2 turns multiplicative ratios into linear differences, there may not be much difference between the two approaches, depending on how far apart original_cwnd and original_flightsize and available_volume are.\r\n\r\nGiven that both approaches are only guaranteed to converge eventually, IMHO we should carefully weigh the costs and benefits of over-reaction vs under-reaction, and also weight the benefits of having the RFC document \"rough consensus and  running code\".",
          "createdAt": "2021-10-07T13:45:30Z",
          "updatedAt": "2021-10-07T13:45:30Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "> FreeBSD/NewReno uses cwin not flightsize. I have not looked at the other congestion control modules just newReno so Cubic or others may use something else. I do think that cwin is the right thing to use here. I can go look at the other modules if there is interest.. a quick look at cc_cubic shows it too uses cwin. So thats 2 out of 6 ;)\r\n\r\nThanks for the data point.\r\n\r\n@stewrtrs  does this mean that FreeBSD/NewReno does not anymore have any safeguards preventing cwnd from increasing to an arbitrarily high value beyond rwnd or above actually used capacity (FlightSize)? \r\nAFAIK at least safeguards to not increase cwnd beyond rwnd were earlier implemented around the time when RFC 5681 was published. Note also that I pointed to RFC 2861 for the problem space description, not as solution (CWV as per RFC 2861). RFC 2861 is known to not perform well and RFC 7661 has obsoleted RFC 2861 providing a more appropriate method for application (rate) limited traffic.",
          "createdAt": "2021-10-11T01:25:12Z",
          "updatedAt": "2021-10-11T01:25:12Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "I'd like to come to a conclusion on this - what should the draft say?",
          "createdAt": "2021-10-11T06:41:25Z",
          "updatedAt": "2021-10-11T06:41:25Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "My take here is that we have an interesting point. I'm keen to see documentation for what is being deployed, and it's clear to me that something other than flight size is needed for an app-limited flow for  performance. I am really not keen on publishing a standards track RFC that reintroduces a well-known problem and that sitrs poorly with other RFCs. \r\n\r\nFrom a standards track document, I'd expect the text not to be related to cwnd, given what RFC7661 says about cwnd with data-limited cases. Alebit, I would also expect that any text to also note that when flightsize<<cwnd you might do something else, which is where RFC 7661 is relevant. (or it's bis if we decide to do that).\r\n\r\nRFC 7661 was published as EXP a little while ago now!  When published, there was limited deployment experience, and no real experience of including this in stacks, but I understood there was support for the problem it sought to address. If experience has changed, a change in RFC status seems helpful (with whatever that now means for calculating a \"safe\" operating point between flightsize and cwnd), and I\u2019d love to see a co-editor (or two) to bring this up to date and make it a standard.\r\n\r\n\r\n",
          "createdAt": "2021-10-11T11:33:05Z",
          "updatedAt": "2021-10-11T11:33:05Z"
        },
        {
          "author": "mattmathis",
          "authorAssociation": "NONE",
          "body": "Sorry I am late to the conversation.  I was present when the concept of setting ssthresh from flight_size was first introduced in  RFC2581  Specifically draft-ietf-tcpimpl-cong-control-01.txt, 33 years ago.  I failed to kill it then.   Today I understand the problem better, and can explain why it was wrong then and is still wrong everywhere that language has been carried forward.\r\n\r\nFirst let me define some terms:\r\nRTTscale: things that happen on about the same timescale as the RTT.  For example, traditional slowstart often causes RTTscale \"lunpyness\" in the data.\r\n\r\nCCscale: things that happen on about the same time scale as the Congestion Control sawtooth (more generally the reciprocal of the CC's natural frequency.) \r\n\r\nSEGscale: Things like TSO, that happen at scales similar to inter-segment times.\r\n\r\nAt about the time RFC 2581 was in draft, I happened to be working on a project to copy a large quantity of data over the vBNS from Pittsburgh Supercomputing Center to mag tape at the San Diego Supercomputer Center,   The path was approximately 70 mS x 125 Mb/s (I have forgotten the precise numbers).   Due to the details of the tape system, the flow control (rwin) introduced application stalls that had dimensions similar to the network.  The tape buffer was a bit larger than the network BDP and the pauses between socket reads were about one RTT. By default this system had pathologically bad performance.  The read at the far end triggered a full window burst at the sender (750+ segments).  If cwnd was large enough the very end of the burst would overflow a queue.  At the point where the sender detected the loss, the TCP had already nearly filled the receiver's socket buffer so TCP was announcing a tiny rwin, and the flight_size had to be tiny as well.  Given that this was classic Reno, setting cwnd to flightsize/2 would result in it taking nearly a minute for cwnd to recover (CCscale for Reno on this path was more than 20 seconds).\r\n\r\nThe point: if the application is bursty on a scale that is similar to the network dimensions, the flight size will be large when the segments at ends of the bursts are sent, but small when the ACKs for the same segments are received.    A loss indicates that the flight size at the time of transmission was too large, But the flight size at the time the ACK was received tells you nothing except that the application stopped keeping the network full after the lost segment was initially sent.\r\n\r\nHypothetically you could record flight size at the time segments were sent, and use it in the CC computation, and we did look at that idea a bit 30 years ago.\r\n\r\nToday, we have a better approach: Use pacing to recover the self clock after application pauses, and don't ever pull down cwnd or ssthresh because the application failed to fill the network (also don't raise cwnd except following RTTs in which the application successfully kept the network full).    More specifically avoid setting cwnd from flight_size (even indirectly), under nearly all conditions.\r\n\r\nAlgorithms that violate this principle are likely to fail industrial scale regression testing, because some specific application traffic pattern will trigger pathological behaviors over some network paths.\r\n\r\nI make a stronger (unproven) conjecture: for every patch introducing such an algorithm, and for every bursty application, there exists some path which will exhibit persistent pathological behavior, and extreme performance regressions.   To the extent this is true, such a patch will never pass code review.\r\n\r\nAn easier experiment: For a real physical path with CCscale > 1sec, and RTTscale << CCscale, design a bursty application that triggers queue overflows near the ends of the bursts.\r\n\r\nWhen you survey what the various OS's do, consider weighing the results by the deployed population.   \r\n",
          "createdAt": "2021-10-11T18:13:15Z",
          "updatedAt": "2021-10-11T18:13:15Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Adding Markku's comment about relocating RFC 7661 when we do a PR for this.\r\nhttps://github.com/NTAP/rfc8312bis/pull/122#discussion_r727487563\r\n",
          "createdAt": "2021-10-12T20:49:48Z",
          "updatedAt": "2021-10-12T20:49:48Z"
        },
        {
          "author": "stewrtrs",
          "authorAssociation": "NONE",
          "body": "Matt:\n\nInteresting thoughts.. and it actually corresponds to some work I am doing\non our rack stack to add hystart+ to newreno.. and what i just got\nthrough adding was a fas (flight at send) for each of the entries in\nmy send map.. I was contemplating using it as the ssthresh for hystart+ \nwhen we decided to switch to CA.. I may even plumb it in and use it\nfor normal loss based detection\u2026 at least I was contemplating it.. your\nresponse here makes me think even harder about doing so :)\n\nR\n\n> On Oct 11, 2021, at 2:13 PM, Matt Mathis ***@***.***> wrote:\n> \n> \n> Sorry I am late to the conversation. I was present when the concept of setting ssthresh from flight_size was first introduced in RFC2581 Specifically draft-ietf-tcpimpl-cong-control-01.txt, 33 years ago. I failed to kill it then. Today I understand the problem better, and can explain why it was wrong then and is still wrong everywhere that language has been carried forward.\n> \n> First let me define some terms:\n> RTTscale: things that happen on about the same timescale as the RTT. For example, traditional slowstart often causes RTTscale \"lunpyness\" in the data.\n> \n> CCscale: things that happen on about the same time scale as the Congestion Control sawtooth (more generally the reciprocal of the CC's natural frequency.)\n> \n> SEGscale: Things like TSO, that happen at scales similar to inter-segment times.\n> \n> At about the time RFC 2581 was in draft, I happened to be working on a project to copy a large quantity of data over the vBNS from Pittsburgh Supercomputing Center to mag tape at the San Diego Supercomputer Center, The path was approximately 70 mS x 125 Mb/s (I have forgotten the precise numbers). Due to the details of the tape system, the flow control (rwin) introduced application stalls that had dimensions similar to the network. The tape buffer was a bit larger than the network BDP and the pauses between socket reads were about one RTT. By default this system had pathologically bad performance. The read at the far end triggered a full window burst at the sender (750+ segments). If cwnd was large enough the very end of the burst would overflow a queue. At the point where the sender detected the loss, the TCP had already nearly filled the receiver's socket buffer so TCP was announcing a tiny rwin, and the flight_size had to be tiny as well. Given that this was classic Reno, setting cwnd to flightsize/2 would result in it taking nearly a minute for cwnd to recover (CCscale for Reno on this path was more than 20 seconds).\n> \n> The point: if the application is bursty on a scale that is similar to the network dimensions, the flight size will be large when the segments at ends of the bursts are sent, but small when the ACKs for the same segments are received. A loss indicates that the flight size at the time of transmission was too large, But the flight size at the time the ACK was received tells you nothing except that the application stopped keeping the network full after the lost segment was initially sent.\n> \n> Hypothetically you could record flight size at the time segments were sent, and use it in the CC computation, and we did look at that idea a bit 30 years ago.\n> \n> Today, we have a better approach: Use pacing to recover the self clock after application pauses, and don't ever pull down cwnd or ssthresh because the application failed to fill the network (also don't raise cwnd except following RTTs in which the application successfully kept the network full). More specifically avoid setting cwnd from flight_size (even indirectly), under nearly all conditions.\n> \n> Algorithms that violate this principle are likely to fail industrial scale regression testing, because some specific application traffic pattern will trigger pathological behaviors over some network paths.\n> \n> I make a stronger (unproven) conjecture: for every patch introducing such an algorithm, and for every bursty application, there exists some path which will exhibit persistent pathological behavior, and extreme performance regressions. To the extent this is true, such a patch will never pass code review.\n> \n> An easier experiment: For a real physical path with CCscale > 1sec, and RTTscale << CCscale, design a bursty application that triggers queue overflows near the ends of the bursts.\n> \n> When you survey what the various OS's do, consider weighing the results by the deployed population.\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n> Triage notifications on the go with GitHub Mobile for iOS or Android. \n> \n\n------\nRandall Stewart\n***@***.***\n\n\n\n",
          "createdAt": "2021-10-12T21:00:47Z",
          "updatedAt": "2021-10-12T21:00:47Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "I merged #122. What is left to close this issue?",
          "createdAt": "2021-10-13T13:56:38Z",
          "updatedAt": "2021-10-13T13:56:38Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "> IMHO saying that basing sshtresh on cwnd \"easily results in behaviour where a rwnd or application-limited TCP sender does not react to congestion\" overstates the issue. Basing ssthresh on cwnd still reacts to congestion; it's just that it will take longer for the cwnd to converge down to the available capacity of the path.\r\n\r\nMy bad to be inaccurate. It should have read:\r\n \"easily results in behaviour where a rwnd or application-limited TCP sender does not react to \r\n  a congestion event or a significant number of consecutive congestion events\"\r\n\r\nSure the cwnd will at some point converge down. Otherwise it would result in congestion collapse which is not the issue here. The issue is negative impact to other flows and being unfair.\r\n\r\nIf an application-limited sender is sending (or receiver receiving) at more or less constant rate for a long period of time (alone on the bottleneck), the cwnd may after a while be arbitrarily high, meaning that the sender does not react to congestion for a notably long period of time if new flows join (this is against one of the major cc principles saying \"must react to congestion event immediately\" that we just agreed on). Note that if we have a relatively stable path with tail-drop bottleneck, according to the packet conservation principle a sender sending at constant rate is not subject to regular losses because it does not seek for more capacity; other flows need to \"push\" a bit with good timing or enough variation in packet delivery is needed cause a drop. So, it may take much longer than some linear number of CA epochs per your log scale equations before such a sender encounters enough drops to get cwnd to level of its FlightSize.",
          "createdAt": "2021-10-15T00:06:45Z",
          "updatedAt": "2021-10-15T00:06:45Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> When you survey what the various OS's do, consider weighing the results by the deployed population.\r\n\r\nMatt, thanks for participating.\r\n\r\nThe deployed major stacks do it all differently. One uses FlightSize together with RFC 7661 to address app & rwnd limited case.  Others use cwnd with no or varying measures to prevent cwnd from growing on RTTs when the network is not kept full.\r\n\r\nOTOH, a significant number of RFCs in the RFC series use FlightSize and we should come up with an RFC that is compatible (and readable) with the other RFCs. And no one is proposing a resolution which just uses FlightSize alone like RFC 5681.\r\n\r\nBut the actual point wrt to your interesting mag tape example or other experiments and the \"better approach\". The mag tape example seems to have essentially the same behaviour as Yuchung's application-limited toy example  (but just just caused by receiver via rwnd). \r\nWe have RFC7661 with a simple algo that tracks of the amount of data Acked during recent RTTs (at least 3 most recent RTTs) and maintains a variable PipeACK to store the highest per RTT value among the recent RTTs in PipeACK. When entering loss recovery it uses max(PipeACK, FlightSize) to calculate new reduced value for cwnd. Doesn't that essentially provide the same outcome? \r\n\r\nRFC7661 differs from your \"better approach\" though in that sense it doesn't keep the non-validated cwnd forever but is required to adjust cwnd after 5 mins (as currently specified). Is there any reason why one should keep the non-validated cwnd for longer than that? \r\nDoes not sound like feasible to allow a sender that has first been alone on the path with buffer bloated bottleneck and acquired a huge cwnd (much more than the bottleneck link capacity) and then gone idle for hours to restart with the same cwnd although it would pace the cwnd worth of data over one RTT; things may have changed and only a tiny fraction of the capacity is anymore available. Even with pacing these packets are uncontrolled data with no ack clock, causing significant negative impact on other flows, i.e., it is like allowing an enormous init wnd with pacing.",
          "createdAt": "2021-10-15T01:10:49Z",
          "updatedAt": "2021-10-15T01:10:49Z"
        },
        {
          "author": "mattmathis",
          "authorAssociation": "NONE",
          "body": "> the cwnd may after a while be arbitrarily high\r\n\r\nNo this is a different bug.  Don't raise cwnd unless flight size has reached cwnd at least once sometime since the last cwnd increment, so that you know that the path can actually deliver a cwnd sized window.   Then a multiplicative cwnd reduction does the right thing, even if it happens while inflight is tiny.   The case that you mention is not a problem: not only are there no reductions, there are no increases either, which is correct: we have zero new information and the estimate of the network capacity remains constant (and larger than in use by the application).\r\n\r\nI was prototyping this type of algorithm when 2581 came out: I dropped a whole pile of work in the dumpster and switched my focus to socket buffer autotuning and TCP instrumentation (web100/ESTATS-MIB).  I have to admit I stopped paying much attention to derivative RFCs.\r\n\r\nBTW Linux does this correctly - I know nothing about other stacks.\r\n\r\nI believe PipeACK is (nearly?) isomorphic to simply not raising cwnd when it isn't controlling the flight size.\r\n\r\nAs for decaying estimates: I have never been able to make sense of this idea.    It isn't the right model for the most common case, which is a bunch of low duty cycle on/off transactional applications sharing a fixed link.  Most of the time the old estimate is correct forever, however every so often transactions collide, and (assuming a paced restart and short queues) you get 50% or 66% loss.  My preference would be to make the collisions converge in one RTT, by reducing cwnd by the losses (or the pacing rate by losses/RTT).   This idea is present in PRR, but is not uniformly applied everywhere it could be.   I remain open minded about decaying estimates: I just have never seen an approach that seems right.\r\n\r\nAlthough backwards compatibility with existing standards is admirable,  standards that include persistent pathological behaviors under straightforward conditions are unlikely to be deployed at scale.   If you want standards to be relevant, you must not specify such behaviors.  If a strict implementation of a standard does not work well, then the standard will be doomed to be only partially implemented.",
          "createdAt": "2021-10-15T04:49:32Z",
          "updatedAt": "2021-10-15T04:49:57Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Does anyone believe anything else in the current text needs to change before this issue can be closed?",
          "createdAt": "2021-10-15T06:34:47Z",
          "updatedAt": "2021-10-15T06:34:47Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "RFC 5681 was clear:  ssthresh MUST be set to no more than the value given in equation (4):\r\n      ssthresh = max (FlightSize / 2, 2*SMSS)\r\n\r\nRFC 2581 is obsolete. RFC7661 provides some rationale and some limits to how a flow might use cwnd here. \r\n\r\nSince this is proposed as PS, the present text in this ID certainly appears to make a substantive change to the RFC series, and I think it does not yet provide a justification and analysis of how that would compete with RFC 5691 traffic. If the text remains in this form, I do think this needs to be discussed in a TCPM meeting.",
          "createdAt": "2021-10-15T11:20:35Z",
          "updatedAt": "2021-10-15T11:20:35Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Would a way forward be to use @gorryfair's phrasing but add a comment that Linux (and other stacks? which?) update based on cwnd?",
          "createdAt": "2021-10-19T17:58:20Z",
          "updatedAt": "2021-10-19T17:58:20Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Injong, Sangtae and I discussed this issue yesterday. We feel that this issue is orthogonal to CUBIC because CUBIC does not modify fast retransmit and recovery. Thus, we would like to follow the current RFCs (that is, set ssthresh using FlightSize). The discussion on using cwnd or FlightSize should be discussed in a different context which deals with the modification of fast retransmit and recovery. But we will add the following note (based on @markkukojo 's note): \"Note that a rate-limited application with idle periods or periods when unable to send at the full rate permitted by the congestion window may easily encounter notable variations in the volume of data sent from one RTT to another, resulting in FlightSize that is significantly less than congestion window on a congestion event. This may decrease the congestion window to a much lower value than necessary. To avoid suboptimal performance with such applications, some implementations of CUBIC use cwnd instead of FlightSize. Alternatively, the mechanisms described in RFC 7661 [RFC7661] may also be adopted to mitigate this issue. \" @Injongrhee @sangtaeha",
          "createdAt": "2021-10-19T18:42:12Z",
          "updatedAt": "2021-10-19T18:42:12Z"
        },
        {
          "author": "yuchungcheng",
          "authorAssociation": "NONE",
          "body": "I respect the inventors' perspectives even though I am disappointed. But\nmaybe that's fine -- RFC has been recommending FlightSize but stacks use\nsomething else b/c of performance implications. In the end the data is the\nbest guidance.\n\nOn Tue, Oct 19, 2021 at 11:42 AM Lisong Xu ***@***.***> wrote:\n\n> Injong, Sangtae and I discussed this issue yesterday. We feel that this\n> issue is orthogonal to CUBIC because CUBIC does not modify fast retransmit\n> and recovery. Thus, we would like to follow the current RFCs (that is, set\n> ssthresh using FlightSize). The discussion on using cwnd or FlightSize\n> should be discussed in a different context which deals with the\n> modification of fast retransmit and recovery. But we will add the following\n> note (based on @markkukojo <https://github.com/markkukojo> 's note):\n> \"Note that a rate-limited application with idle periods or periods when\n> unable to send at the full rate permitted by the congestion window may\n> easily encounter notable variations in the volume of data sent from one RTT\n> to another, resulting in FlightSize that is significantly less than\n> congestion window on a congestion event. This may decrease the congestion\n> window to a much lower value than necessary. To avoid suboptimal\n> performance with such applications, some implementations of CUBIC use cwnd\n> instead of FlightSize. Alternatively, the mechanisms described in RFC 7661\n> [RFC7661] may also be adopted to mitigate this issue. \" @Injongrhee\n> <https://github.com/Injongrhee> @sangtaeha <https://github.com/sangtaeha>\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/NTAP/rfc8312bis/issues/114#issuecomment-947006084>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AM5EPYEJFTZTYQVGGUUGZGTUHW3Y7ANCNFSM5EN3H3UA>\n> .\n> Triage notifications on the go with GitHub Mobile for iOS\n> <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>\n> or Android\n> <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.\n>\n>\n",
          "createdAt": "2021-10-19T19:05:06Z",
          "updatedAt": "2021-10-19T19:05:06Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with Yuchung's remark and feel that, overall, the text from \"the following note\" in \r\n   https://github.com/NTAP/rfc8312bis/issues/114#issuecomment-947006084\r\nsounds like the best compromise to allow a path forward.\r\n",
          "createdAt": "2021-10-19T20:18:23Z",
          "updatedAt": "2021-10-19T20:18:23Z"
        },
        {
          "author": "mattmathis",
          "authorAssociation": "NONE",
          "body": "Here is another possible way to fix the text.  In stead of flightsize, use \"any recent flight size that was successfully delivered without loss or congestion marks\".  I believe that this (or something like it) includes all implementation and prior RFCs.  BTW for true bulk transfers, this has no effects on fairness.  It only alters the penalty caused by application pauses.",
          "createdAt": "2021-10-19T21:10:35Z",
          "updatedAt": "2021-10-19T21:10:35Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@lisongxu the text in https://github.com/NTAP/rfc8312bis/issues/114#issuecomment-947006084 looks good to me. Do you want to write a PR? Thanks.",
          "createdAt": "2021-10-20T04:41:29Z",
          "updatedAt": "2021-10-20T04:41:29Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure, I will submit it soon. Thanks\r\n\r\n",
          "createdAt": "2021-10-20T13:56:27Z",
          "updatedAt": "2021-10-20T15:01:51Z"
        }
      ]
    },
    {
      "number": 118,
      "id": "I_kwDOEpK-U847-oPR",
      "title": "Acknowledge contributors",
      "url": "https://github.com/NTAP/rfc8312bis/issues/118",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "larseggert"
      ],
      "labels": [],
      "body": "We need to acknowledge the contributors to this bis document.",
      "createdAt": "2021-09-24T09:35:28Z",
      "updatedAt": "2021-09-29T08:03:50Z",
      "closedAt": "2021-09-29T08:03:50Z",
      "comments": []
    },
    {
      "number": 132,
      "id": "I_kwDOEpK-U84-JAm5",
      "title": "Suggestion to avoid long discussion on RFC7661 and cwnd v flight_size",
      "url": "https://github.com/NTAP/rfc8312bis/issues/132",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I have made a PR is intended to amend the text to align with my understanding of the RFC-series. This normatively  would require ssthresh to be set from flight_size; however, this is explicitly relaxed in RFC7661, so I suggest wording should be careful around this topic.",
      "createdAt": "2021-11-02T16:03:02Z",
      "updatedAt": "2021-11-11T08:08:07Z",
      "closedAt": "2021-11-11T08:08:07Z",
      "comments": []
    },
    {
      "number": 135,
      "id": "I_kwDOEpK-U84_PKRe",
      "title": "W_max",
      "url": "https://github.com/NTAP/rfc8312bis/issues/135",
      "state": "OPEN",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "lisongxu"
      ],
      "labels": [],
      "body": "From @markkukojo in #85:\r\n> Moreover, I didn't notice it earlier but this also means that setting W_max should be different if the sender is in slow start when a pkt loss (congestion) is detected and cwnd is reduced.\r\nIf CUBIC sets W_max to size of cwnd just before cwnd was reduced when in slow start alike when in CA, it results not only starting the first CA epoch after fast recovery with an overaggressive cwnd (using MD=0.7) above the actual saturation point but also starting the subsequent CA with the concave phase and continuing with the concave phase until cwnd reaches value that is double the saturation point. This makes CUBIC (when not in Reno-friendly region) much more aggressive than intended because it operates in the concave phase even though the cwnd size actually already exceeds the previous saturation point (which in the above example is 200 not 400).\r\n>\r\n>IMO this issue of which MD factor to use when in slow start is not resolved. Please also add the problem with setting W_max when in slow start to the set of open issues.",
      "createdAt": "2021-11-23T08:07:44Z",
      "updatedAt": "2022-01-15T01:50:45Z",
      "closedAt": null,
      "comments": [
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Any takers for this one?",
          "createdAt": "2021-12-13T16:24:56Z",
          "updatedAt": "2021-12-13T16:24:56Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is an interesting discussion point. My tentative thoughts on this are:\r\n* if hystart++ is used, the chances to get losses during slowstart will be reduced\r\n* if a certain pacing is used, the burstness in the first CA epoch is reduced which might help finding saturation point without large losses\r\n* using MD=0.5 upon the loss after SS may be one idea especially when the options above are not used.\r\n* But, I'm still thinking how bad concave growth in the first CA is. if cwnd at loss during SS is too far from the actual saturation point, both reno and cubic will hit saturation point quickly in the first CA. there might not be big differences. if the cwnd at loss during SS is close to the actual saturation point, cubic gain more bandwidth than reno especially under long RTTs, but this might be what cubic is. ",
          "createdAt": "2021-12-13T21:51:10Z",
          "updatedAt": "2021-12-13T21:53:28Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "I will work on this issue. Thanks",
          "createdAt": "2021-12-14T06:08:33Z",
          "updatedAt": "2021-12-14T06:08:33Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Quick update: still working on it, try to find a reasonable solution for both #135 and #85.  Thanks",
          "createdAt": "2021-12-21T21:16:33Z",
          "updatedAt": "2021-12-21T21:16:33Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Update: \r\n\r\nThank you all, @markkukojo  @nsdyoshi, for your comments and suggestions! \r\n\r\nWe agree that both MD and Wmax may be adjusted differently for slow start and congestion avoidance. As this could be a major change to CUBIC, we (thanks, @sangtaeha) plan to comprehensively test and evaluate this change in various network environments, which will take some time. \r\n\r\n",
          "createdAt": "2022-01-15T01:50:44Z",
          "updatedAt": "2022-01-15T01:50:44Z"
        }
      ]
    },
    {
      "number": 137,
      "id": "I_kwDOEpK-U85B0VY9",
      "title": "\"Application-Limited\" seems ambiguous",
      "url": "https://github.com/NTAP/rfc8312bis/issues/137",
      "state": "OPEN",
      "author": "maolson-msft",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It seems like usually \"app-limited\" refers only to the local app, but if the peer's receive window limits the connection's send rate then we have the same problem where CWnd can grow arbitrarily. So, is \"app-limited\" supposed to also refer to the peer's receive window? If so, then this should probably be spelled out.",
      "createdAt": "2022-01-15T00:33:38Z",
      "updatedAt": "2022-01-15T00:33:38Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 3,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIwOTcwNTQ1",
      "title": "redefine the K equation",
      "url": "https://github.com/NTAP/rfc8312bis/pull/3",
      "state": "MERGED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I have tried to address https://github.com/NTAP/rfc8312bis/issues/1. I have kept the Eq. 2 as is and added justification for further simplification / generalization to address the fast convergence issue with Eq. 2.\r\n\r\nI apologize in advance if I created this PR too soon (I thought this is a major issue as most Cubic implementation perform Fast Convergence).\r\n\r\nCloses #1 and https://github.com/NTAP/rfc8312bis/issues/14",
      "createdAt": "2020-11-14T06:55:10Z",
      "updatedAt": "2020-11-24T09:04:13Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "14c3ad8e5141acf1d65b1e1e00f5070ac52807a2",
      "headRepository": "goelvidhi/rfc8312bis",
      "headRefName": "updated-K",
      "headRefOid": "3093d02b3c5d23f0117440ed674f50fdd8343b78",
      "closedAt": "2020-11-24T09:04:13Z",
      "mergedAt": "2020-11-24T09:04:12Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "dd9e54a8a6b7a222188e13e33b86567d30b786b8"
      },
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@lisongxu @sangtaeha could you please review?\r\n(Is there a way I can add reviewers?)",
          "createdAt": "2020-11-18T06:14:57Z",
          "updatedAt": "2020-11-18T06:14:57Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "@goelvidhi Sorry for the confusion. I didn't mean to remove the left parenthesis. (W_max - cwnd)/C needs to be inside the cubic root. So it should be\r\n\r\n~~~\r\nK = cubic_root((W_max - cwnd) / C)\r\n~~",
          "createdAt": "2020-11-18T11:39:16Z",
          "updatedAt": "2020-11-18T11:39:16Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> @goelvidhi Sorry for the confusion. I didn't mean to remove the left parenthesis. (W_max - cwnd)/C needs to be inside the cubic root. So it should be\r\n> \r\n> ```\r\n> K = cubic_root((W_max - cwnd) / C)\r\n> ~~\r\n> ```\r\n\r\nMy bad. Fixed it",
          "createdAt": "2020-11-18T23:36:50Z",
          "updatedAt": "2020-11-18T23:36:50Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@goelvidhi should be able to add reviewers in the sidebar on the right (top item). Let me know if you don't see the option, might be a permissions things.",
          "createdAt": "2020-11-19T05:18:32Z",
          "updatedAt": "2020-11-19T05:18:32Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> Please also add a bullet about this PR to the changelog in the appendix.\r\n\r\ndone\r\n\r\n@lisongxu @larseggert @sangtaeha I have added the modifications recommended on the issue so far. Could you please review?",
          "createdAt": "2020-11-20T04:15:03Z",
          "updatedAt": "2020-11-20T04:15:03Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@lisongxu @sangtaeha could you please review? Thank you.",
          "createdAt": "2020-11-20T08:25:59Z",
          "updatedAt": "2020-11-20T08:25:59Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@vidhigoel-apple Please change the upper bound from 2*cwnd to 1.5*cwnd to be consistent with Linux and be more conservative (safer).  Thank you!",
          "createdAt": "2020-11-20T18:23:15Z",
          "updatedAt": "2020-11-20T18:23:15Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Added the changes for the review comments so far. Please review.",
          "createdAt": "2020-11-21T00:41:48Z",
          "updatedAt": "2020-11-21T00:41:48Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@lisongxu could you please review this change?",
          "createdAt": "2020-11-21T07:50:37Z",
          "updatedAt": "2020-11-21T07:50:37Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert could you merge this?",
          "createdAt": "2020-11-24T07:56:35Z",
          "updatedAt": "2020-11-24T07:56:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxMjEzOTMy",
          "commit": {
            "abbreviatedOid": "06d1ff7"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-11-16T10:56:32Z",
          "updatedAt": "2020-11-16T10:58:27Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Please add an anchor for this section and use it in this reference, instead of hardcoding the value. (Check how `mult-dec` is used in the current text for an example.)",
              "createdAt": "2020-11-16T10:56:32Z",
              "updatedAt": "2020-11-21T00:37:28Z"
            },
            {
              "originalPosition": 11,
              "body": "I think it would be clearer if Eq. 2 were modified to include a conditional, rather than defining a separate equation for this case. That way, we also wouldn't need to renumber all the following equations.",
              "createdAt": "2020-11-16T10:57:57Z",
              "updatedAt": "2020-11-21T00:37:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxOTc4NjYz",
          "commit": {
            "abbreviatedOid": "2283884"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T02:34:46Z",
          "updatedAt": "2020-11-17T02:34:47Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Removed this reference in the new text.",
              "createdAt": "2020-11-17T02:34:46Z",
              "updatedAt": "2020-11-21T00:37:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxOTc4ODM1",
          "commit": {
            "abbreviatedOid": "2283884"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T02:35:14Z",
          "updatedAt": "2020-11-17T02:35:15Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Done. Added the conditional based on the issue discussion with @lisongxu ",
              "createdAt": "2020-11-17T02:35:14Z",
              "updatedAt": "2020-11-21T00:37:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMTk5OTcw",
          "commit": {
            "abbreviatedOid": "ca6426d"
          },
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Left parenthesis is missing. K = cubic_root((W_max - cwnd) / C)\r\nI am okay without origin_point since it is much easier to understand. But Lisong may have his opinion. Other than that it is good to go. ",
          "createdAt": "2020-11-18T08:23:52Z",
          "updatedAt": "2020-11-18T08:23:52Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMzE4NTM4",
          "commit": {
            "abbreviatedOid": "6bfb51f"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-18T10:46:40Z",
          "updatedAt": "2020-11-18T10:46:41Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0MDg4OTk5",
          "commit": {
            "abbreviatedOid": "bd3a378"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Please also add a bullet about this PR to the changelog in the appendix.",
          "createdAt": "2020-11-19T05:19:42Z",
          "updatedAt": "2020-11-19T05:19:42Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1MTA5OTg3",
          "commit": {
            "abbreviatedOid": "c770536"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-11-20T05:14:12Z",
          "updatedAt": "2020-11-20T05:14:51Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "issue number missing",
              "createdAt": "2020-11-20T05:14:12Z",
              "updatedAt": "2020-11-21T00:37:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1MTMyMDIz",
          "commit": {
            "abbreviatedOid": "aed3ae5"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-20T05:51:21Z",
          "updatedAt": "2020-11-20T05:51:22Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "fixed",
              "createdAt": "2020-11-20T05:51:21Z",
              "updatedAt": "2020-11-21T00:37:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1MTMyMzUy",
          "commit": {
            "abbreviatedOid": "aed3ae5"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-20T05:52:22Z",
          "updatedAt": "2020-11-20T05:52:23Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Please point to the issue(s) and not the PR number",
              "createdAt": "2020-11-20T05:52:23Z",
              "updatedAt": "2020-11-21T00:37:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1MTQ5NDY4",
          "commit": {
            "abbreviatedOid": "aed3ae5"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-20T06:41:52Z",
          "updatedAt": "2020-11-20T06:41:52Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "oh... I thought the previous update logs were pointing to PR #. Do you want me to fix them all?",
              "createdAt": "2020-11-20T06:41:52Z",
              "updatedAt": "2020-11-21T00:37:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1MTU0Njk2",
          "commit": {
            "abbreviatedOid": "aed3ae5"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-20T06:54:07Z",
          "updatedAt": "2020-11-20T06:54:08Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Yes, please. (I thought I had checked that they were pointing at issues, but maybe I was wrong.)",
              "createdAt": "2020-11-20T06:54:07Z",
              "updatedAt": "2020-11-21T00:37:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1MTY1MDQz",
          "commit": {
            "abbreviatedOid": "be5adb4"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-20T07:16:29Z",
          "updatedAt": "2020-11-20T07:16:29Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "done",
              "createdAt": "2020-11-20T07:16:29Z",
              "updatedAt": "2020-11-21T00:37:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1MTY3MDEw",
          "commit": {
            "abbreviatedOid": "be5adb4"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-20T07:21:00Z",
          "updatedAt": "2020-11-20T07:21:00Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1MzAyNjA0",
          "commit": {
            "abbreviatedOid": "be5adb4"
          },
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "@goelvidhi This looks good. We may also add some explanation for why we have low and upper bounds for the target? The following sentence or slightly modified one could be added to the end of the sentence in Line #389.\r\n\"The lower and upper bounds ensure that CUBIC's window increase rate is non-decreasing but is less than the rate of slow start.\"",
          "createdAt": "2020-11-20T10:23:50Z",
          "updatedAt": "2020-11-20T10:28:53Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1ODc4NDI2",
          "commit": {
            "abbreviatedOid": "3093d02"
          },
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Great. Thanks.",
          "createdAt": "2020-11-21T03:15:42Z",
          "updatedAt": "2020-11-21T03:15:42Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1OTcxNjUz",
          "commit": {
            "abbreviatedOid": "3093d02"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you, Vidhi!",
          "createdAt": "2020-11-21T14:56:57Z",
          "updatedAt": "2020-11-21T14:56:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 8,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIxNzMyMjA0",
      "title": "Enable markdownlint",
      "url": "https://github.com/NTAP/rfc8312bis/pull/8",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-11-16T15:19:23Z",
      "updatedAt": "2020-11-17T06:41:04Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "89d9cda9fd5cb9ded734d4b380a5e933b00f0607",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "markdownlint",
      "headRefOid": "95749a2d7c1370115b6581b115916176c4c148d9",
      "closedAt": "2020-11-17T06:41:00Z",
      "mergedAt": "2020-11-17T06:41:00Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "5eb2a1fff23bb0d7dd28b32308fd8bbc6811e303"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 9,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIyMTAwMDQy",
      "title": "cwnd reduction on congestion event",
      "url": "https://github.com/NTAP/rfc8312bis/pull/9",
      "state": "MERGED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change ensures that cwnd can now be less than 2. Resolves https://github.com/NTAP/rfc8312bis/issues/7",
      "createdAt": "2020-11-17T02:45:47Z",
      "updatedAt": "2020-11-17T15:28:20Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "89d9cda9fd5cb9ded734d4b380a5e933b00f0607",
      "headRepository": "goelvidhi/rfc8312bis",
      "headRefName": "min-cwnd",
      "headRefOid": "f148f98b5f712ead13caf67d2fd3e4adc7692801",
      "closedAt": "2020-11-17T15:28:19Z",
      "mergedAt": "2020-11-17T15:28:19Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "d3b35ad56a2e66dd10316f5e762a522454793064"
      },
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@lisongxu @sangtaeha could you please review these changes?",
          "createdAt": "2020-11-17T07:31:01Z",
          "updatedAt": "2020-11-17T07:31:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMDYxNDI0",
          "commit": {
            "abbreviatedOid": "f148f98"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-17T06:48:55Z",
          "updatedAt": "2020-11-17T06:48:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMTAxNTM2",
          "commit": {
            "abbreviatedOid": "f148f98"
          },
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-17T08:01:10Z",
          "updatedAt": "2020-11-17T08:01:10Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNDc2Njkw",
          "commit": {
            "abbreviatedOid": "f148f98"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-17T15:20:55Z",
          "updatedAt": "2020-11-17T15:20:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 12,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIyMjU1NjA3",
      "title": "List of variables and constants",
      "url": "https://github.com/NTAP/rfc8312bis/pull/12",
      "state": "MERGED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I have tried to add a new section for definition of variables and constants with their respective units. I removed some of the redundant definitions. Resolves https://github.com/NTAP/rfc8312bis/issues/5 and https://github.com/NTAP/rfc8312bis/issues/6",
      "createdAt": "2020-11-17T09:10:30Z",
      "updatedAt": "2020-11-19T17:02:45Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "b8110cabbcf450aeff1a50e7aadc142aabba3ea2",
      "headRepository": "goelvidhi/rfc8312bis",
      "headRefName": "variables-definition",
      "headRefOid": "8166dfce62ce53832af8d13c83cf82970fe0698d",
      "closedAt": "2020-11-19T17:02:45Z",
      "mergedAt": "2020-11-19T17:02:45Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "a0d86c209eeb1fe9597beeca7f89b7d66cf41b98"
      },
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert @sangtaeha @lisongxu could you please review the changes in this PR?\r\nAs the changes here will conflict with https://github.com/NTAP/rfc8312bis/pull/3, I prefer to get this one merged before I start updating #3. Thanks.",
          "createdAt": "2020-11-19T03:25:35Z",
          "updatedAt": "2020-11-19T03:25:35Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> In addition to what I highlighted inline, please also add a bullet about this PR to the changelog in the appendix.\r\n\r\ndone.\r\nWaiting for @sangtaeha's review. :-)",
          "createdAt": "2020-11-19T06:43:32Z",
          "updatedAt": "2020-11-19T08:22:08Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMTYzMjE3",
          "commit": {
            "abbreviatedOid": "8b65755"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-11-17T09:19:28Z",
          "updatedAt": "2020-11-17T09:24:01Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Cite the RFC instead of saying \"Standard TCP\", which doesn't really exist?",
              "createdAt": "2020-11-17T09:19:28Z",
              "updatedAt": "2020-11-19T05:59:40Z"
            },
            {
              "originalPosition": 30,
              "body": "```suggestion\r\n: Current congestion window in segments.\r\n```",
              "createdAt": "2020-11-17T09:20:11Z",
              "updatedAt": "2020-11-19T05:59:40Z"
            },
            {
              "originalPosition": 35,
              "body": "Should this definition use `cwnd`?",
              "createdAt": "2020-11-17T09:22:49Z",
              "updatedAt": "2020-11-19T05:59:40Z"
            },
            {
              "originalPosition": 48,
              "body": "```suggestion\r\n  window if the TCP-NewReno congestion controller was used.\r\n```",
              "createdAt": "2020-11-17T09:23:41Z",
              "updatedAt": "2020-11-19T05:59:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMTY4NDQy",
          "commit": {
            "abbreviatedOid": "cfecaf9"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T09:25:10Z",
          "updatedAt": "2020-11-17T09:25:10Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "sure",
              "createdAt": "2020-11-17T09:25:10Z",
              "updatedAt": "2020-11-19T05:59:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMTUzOTYw",
          "commit": {
            "abbreviatedOid": "19dfd8d"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T07:09:48Z",
          "updatedAt": "2020-11-18T07:09:49Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Should this be smoothed RTT? I can cite 793 if we agree to call it smoothed RTT",
              "createdAt": "2020-11-18T07:09:49Z",
              "updatedAt": "2020-11-19T05:59:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMTU2OTk4",
          "commit": {
            "abbreviatedOid": "19dfd8d"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T07:15:51Z",
          "updatedAt": "2020-11-18T07:15:52Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Shouldn't it be RFC6298? And I think it should be SRTT.\r\n\r\nCC'ing @lisongxu @sangtaeha for their input.",
              "createdAt": "2020-11-18T07:15:51Z",
              "updatedAt": "2020-11-19T05:59:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMTczMDM1",
          "commit": {
            "abbreviatedOid": "19dfd8d"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T07:46:06Z",
          "updatedAt": "2020-11-18T07:46:06Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Yes, you are right that we should cite RFC6298. Waiting for other reviewers' input before I make this change.",
              "createdAt": "2020-11-18T07:46:06Z",
              "updatedAt": "2020-11-19T05:59:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMzE2NDc2",
          "commit": {
            "abbreviatedOid": "19dfd8d"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T10:44:14Z",
          "updatedAt": "2020-11-18T10:44:15Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "This should probably be a subsection?",
              "createdAt": "2020-11-18T10:44:14Z",
              "updatedAt": "2020-11-19T05:59:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTM2Njgw",
          "commit": {
            "abbreviatedOid": "19dfd8d"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T22:32:54Z",
          "updatedAt": "2020-11-18T22:32:55Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "ok, will do a subsection under CUBIC Congestion Control",
              "createdAt": "2020-11-18T22:32:54Z",
              "updatedAt": "2020-11-19T05:59:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTUzNDA4",
          "commit": {
            "abbreviatedOid": "19dfd8d"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T23:04:32Z",
          "updatedAt": "2020-11-18T23:04:32Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "done. How can I convert the text document to the html version to see how the sections look?",
              "createdAt": "2020-11-18T23:04:32Z",
              "updatedAt": "2020-11-19T05:59:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTYwODc3",
          "commit": {
            "abbreviatedOid": "19dfd8d"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T23:20:59Z",
          "updatedAt": "2020-11-18T23:21:00Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "For some reason, the PR is not getting updated with my new commits to goelvidhi/rfc8312bis. The repo shows the changes but the PR doesn't. What am I doing wrong?",
              "createdAt": "2020-11-18T23:20:59Z",
              "updatedAt": "2020-11-19T05:59:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTgzNTU2",
          "commit": {
            "abbreviatedOid": "75ba076"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-19T00:13:31Z",
          "updatedAt": "2020-11-19T00:13:32Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Ah, it got updated after some time.",
              "createdAt": "2020-11-19T00:13:32Z",
              "updatedAt": "2020-11-19T05:59:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0MDYzODc3",
          "commit": {
            "abbreviatedOid": "f03b088"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-19T03:55:11Z",
          "updatedAt": "2020-11-19T03:55:11Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0MDg3ODM2",
          "commit": {
            "abbreviatedOid": "f03b088"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "In addition to what I highlighted inline, please also add a bullet about this PR to the changelog in the appendix.",
          "createdAt": "2020-11-19T05:16:08Z",
          "updatedAt": "2020-11-19T05:16:49Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I don't think we need this third-layer subsection heading, since it is the only one in this section.",
              "createdAt": "2020-11-19T05:16:08Z",
              "updatedAt": "2020-11-19T05:59:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0MDk3NDMy",
          "commit": {
            "abbreviatedOid": "f03b088"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-19T05:44:53Z",
          "updatedAt": "2020-11-19T05:44:53Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "There are actually two:\r\n1. Constants\r\n2. Variables\r\n\r\nDo we want to combine them?",
              "createdAt": "2020-11-19T05:44:53Z",
              "updatedAt": "2020-11-19T05:59:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0MTE4ODEz",
          "commit": {
            "abbreviatedOid": "8166dfc"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-19T06:39:18Z",
          "updatedAt": "2020-11-19T06:39:18Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "No, I must have misread the diff. Nevermind :-)",
              "createdAt": "2020-11-19T06:39:18Z",
              "updatedAt": "2020-11-19T06:39:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0MTE4OTM1",
          "commit": {
            "abbreviatedOid": "8166dfc"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-19T06:39:36Z",
          "updatedAt": "2020-11-19T06:39:36Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0NjQ1MTQ3",
          "commit": {
            "abbreviatedOid": "8166dfc"
          },
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The changes look good to me. Thanks!",
          "createdAt": "2020-11-19T16:47:59Z",
          "updatedAt": "2020-11-19T16:47:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 13,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIyNDU4OTcy",
      "title": "Add the C code for generating (some of) Tables 1 and 2",
      "url": "https://github.com/NTAP/rfc8312bis/pull/13",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-11-17T14:37:56Z",
      "updatedAt": "2020-11-18T08:08:40Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "ff650b32509149e25c7ce7073e3da927ff1f4733",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "add-table-code",
      "headRefOid": "1d77a514726eac0ab9941223d6239f7a82a0ea01",
      "closedAt": "2020-11-18T08:08:36Z",
      "mergedAt": "2020-11-18T08:08:36Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "de7c07989519e3e09988eead849207eeeab05352"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMTc1MTg4",
          "commit": {
            "abbreviatedOid": "99743a2"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-18T07:49:56Z",
          "updatedAt": "2020-11-18T07:49:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIyOTkzOTk2",
      "title": "Ack co-authors of RFC8312. Fixes #15.",
      "url": "https://github.com/NTAP/rfc8312bis/pull/18",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-11-18T07:58:02Z",
      "updatedAt": "2020-11-18T08:08:03Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "9b8225c99d12f77e53130470fd1184afa72d0d93",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "ack-prev-authors",
      "headRefOid": "921b72d8727067a6a0640de56ba0754c1f472b67",
      "closedAt": "2020-11-18T08:07:59Z",
      "mergedAt": "2020-11-18T08:07:58Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "6d9d83f0548a0d8941355841cfcd26e2ba9b55b1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 19,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIzMDAyMzM2",
      "title": "Add changelog relative to -00",
      "url": "https://github.com/NTAP/rfc8312bis/pull/19",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-11-18T08:13:20Z",
      "updatedAt": "2020-11-19T05:13:37Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "de7c07989519e3e09988eead849207eeeab05352",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "changes-from-00",
      "headRefOid": "8aa3dd2607f511122027f5ae15fddb3446d4f01c",
      "closedAt": "2020-11-19T05:13:34Z",
      "mergedAt": "2020-11-19T05:13:34Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "b8110cabbcf450aeff1a50e7aadc142aabba3ea2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTM1NzM3",
          "commit": {
            "abbreviatedOid": "8aa3dd2"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-18T22:31:24Z",
          "updatedAt": "2020-11-18T22:31:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 22,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI0MTA0ODAx",
      "title": "Fix markdown and capitalization/punctuation inconsistencies",
      "url": "https://github.com/NTAP/rfc8312bis/pull/22",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "that were  introduced in #12",
      "createdAt": "2020-11-19T17:10:20Z",
      "updatedAt": "2020-11-19T17:12:57Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "a0d86c209eeb1fe9597beeca7f89b7d66cf41b98",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "fix-definitions-markdown",
      "headRefOid": "e4676c08c0d4023525017524f03956074a5e1f64",
      "closedAt": "2020-11-19T17:12:54Z",
      "mergedAt": "2020-11-19T17:12:54Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "14c3ad8e5141acf1d65b1e1e00f5070ac52807a2"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 24,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI1MDk1NTIy",
      "title": "AIMD approach for tcp friendly window",
      "url": "https://github.com/NTAP/rfc8312bis/pull/24",
      "state": "MERGED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #20 .\r\n\r\nWill add the change log once the pending PR #3 is merged to avoid conflict.",
      "createdAt": "2020-11-21T07:53:04Z",
      "updatedAt": "2020-11-24T12:02:50Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "dd9e54a8a6b7a222188e13e33b86567d30b786b8",
      "headRepository": "goelvidhi/rfc8312bis",
      "headRefName": "tf-aimd-reno",
      "headRefOid": "4582313b21db8aa0170a06b2ac2a59b02f5afa3a",
      "closedAt": "2020-11-24T12:02:50Z",
      "mergedAt": "2020-11-24T12:02:50Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "88cdfd0025ba575102ec1e102c36f79c78cb7b3f"
      },
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert could you please review this PR?",
          "createdAt": "2020-11-24T07:57:01Z",
          "updatedAt": "2020-11-24T07:57:01Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "FYI, I am technically on vacation this week, so I may be slow to respond.",
          "createdAt": "2020-11-24T09:03:39Z",
          "updatedAt": "2020-11-24T09:03:39Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> Also add a line to the changelog, please.\r\n\r\nDone.",
          "createdAt": "2020-11-24T09:38:19Z",
          "updatedAt": "2020-11-24T09:38:19Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1OTcxOTMw",
          "commit": {
            "abbreviatedOid": "ce7d709"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you, Vidhi!",
          "createdAt": "2020-11-21T15:01:18Z",
          "updatedAt": "2020-11-21T15:01:18Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1OTg4MjY0",
          "commit": {
            "abbreviatedOid": "ce7d709"
          },
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This looks good. Thanks!",
          "createdAt": "2020-11-21T18:57:18Z",
          "updatedAt": "2020-11-21T18:57:18Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3MjczMTk0",
          "commit": {
            "abbreviatedOid": "ce7d709"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Also add a line to the changelog, please.",
          "createdAt": "2020-11-24T09:03:02Z",
          "updatedAt": "2020-11-24T09:03:18Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "We're no using `+=` or similar anywhere in the formulas yet. So maybe use `W_est = W_est + ...` for consistency?",
              "createdAt": "2020-11-24T09:03:02Z",
              "updatedAt": "2020-11-24T09:27:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3MzA0NDgy",
          "commit": {
            "abbreviatedOid": "4582313"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-24T09:37:46Z",
          "updatedAt": "2020-11-24T09:37:46Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "sounds good. Done.",
              "createdAt": "2020-11-24T09:37:46Z",
              "updatedAt": "2020-11-24T09:37:46Z"
            }
          ]
        }
      ]
    },
    {
      "number": 25,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI3MzEzMDMw",
      "title": "Trying for Standards Track publication",
      "url": "https://github.com/NTAP/rfc8312bis/pull/25",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-11-25T09:41:20Z",
      "updatedAt": "2020-12-02T16:43:36Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "88cdfd0025ba575102ec1e102c36f79c78cb7b3f",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "go-std-track",
      "headRefOid": "d0b16107c8d13e7bca68e3d7329c5c4655d99306",
      "closedAt": "2020-11-25T09:41:42Z",
      "mergedAt": "2020-11-25T09:41:42Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "da5782958c9db7819610e25cadc6aef39a65d680"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 26,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI3Nzk1NDA4",
      "title": "set alpha_aimd to 1 when W_est is bigger than W_max",
      "url": "https://github.com/NTAP/rfc8312bis/pull/26",
      "state": "MERGED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I have update Eq. 3 to use alpha_aimd variable which is defined in the preceding paragraph as alpha_aimd=3*(1-beta_cubic)/(1+beta_cubic). Please let me know if alpha_aimd needs to be added to the Definitions sub section.\r\n\r\nCloses #2.",
      "createdAt": "2020-11-26T03:15:17Z",
      "updatedAt": "2020-12-01T07:17:58Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "da5782958c9db7819610e25cadc6aef39a65d680",
      "headRepository": "goelvidhi/rfc8312bis",
      "headRefName": "tf-cwnd-after-Wmax",
      "headRefOid": "613965255127176d0dfe09bc822e04158e2a8aef",
      "closedAt": "2020-12-01T07:17:58Z",
      "mergedAt": "2020-12-01T07:17:58Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "244f3b9f9545e8d939d0e0354d3660b912fc9420"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwMzQzNzkw",
          "commit": {
            "abbreviatedOid": "6139652"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you, Vidhi!",
          "createdAt": "2020-11-28T05:16:37Z",
          "updatedAt": "2020-11-28T05:16:37Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwMzUxNzE1",
          "commit": {
            "abbreviatedOid": "6139652"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-28T08:24:58Z",
          "updatedAt": "2020-11-28T08:25:10Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Would it make sense to make alpha_aimd a function of W_est then?",
              "createdAt": "2020-11-28T08:24:58Z",
              "updatedAt": "2020-11-28T08:25:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwNDQ1MjU3",
          "commit": {
            "abbreviatedOid": "6139652"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-29T03:59:26Z",
          "updatedAt": "2020-11-29T03:59:27Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "W_est uses alpha_aimd where alpha_aimd itself is a property/constant which is either 3 (1-beta) (1+beta) or 1 depending upon the current value of W_est - so, it is not a really a function of W_est but more like a component in the W_est formula which changes conditionally.",
              "createdAt": "2020-11-29T03:59:26Z",
              "updatedAt": "2020-11-29T03:59:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxNDY3ODA1",
          "commit": {
            "abbreviatedOid": "6139652"
          },
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2020-12-01T03:44:00Z",
          "updatedAt": "2020-12-01T03:44:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 27,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMwMTA2MTA4",
      "title": "add Vidhi as co-author",
      "url": "https://github.com/NTAP/rfc8312bis/pull/27",
      "state": "MERGED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #17.\r\n\r\nAs this is my first time to co-author an IETF document, please let me know if I missed something.",
      "createdAt": "2020-12-01T08:06:19Z",
      "updatedAt": "2020-12-02T16:24:58Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "244f3b9f9545e8d939d0e0354d3660b912fc9420",
      "headRepository": "goelvidhi/rfc8312bis",
      "headRefName": "add-vidhi",
      "headRefOid": "292745b9e128a7ddef2295a4bee454c9d465a03f",
      "closedAt": "2020-12-02T16:24:58Z",
      "mergedAt": "2020-12-02T16:24:58Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "9b8f58e1ca4fc6b2cdaca4fecfdc688292dbbffb"
      },
      "comments": [
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Add yourself before me? Since I'm just doing editing, the folks who contribute content should come first. LGTM otherwise.",
          "createdAt": "2020-12-01T13:54:22Z",
          "updatedAt": "2020-12-01T13:54:22Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> Add yourself before me? Since I'm just doing editing, the folks who contribute content should come first. LGTM otherwise.\r\n\r\nok, done.",
          "createdAt": "2020-12-01T19:28:31Z",
          "updatedAt": "2020-12-01T19:28:31Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "I am unable to understand why the markdown check failed. I only moved the text around. @larseggert, any ideas?",
          "createdAt": "2020-12-02T00:31:54Z",
          "updatedAt": "2020-12-02T00:31:54Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxOTE0MTEx",
          "commit": {
            "abbreviatedOid": "71cd4a2"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, Vidhi!",
          "createdAt": "2020-12-01T13:54:00Z",
          "updatedAt": "2020-12-01T13:54:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 29,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMxNjQ1ODc2",
      "title": "add note about fast recovery during cwnd decrease due to congestion",
      "url": "https://github.com/NTAP/rfc8312bis/pull/29",
      "state": "MERGED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed on #11, I added a note about fast recovery.\r\nPlease let me know if we need to add more details. IMO, we should avoid mentioning any specific fast recovery mechanism.\r\n\r\nCloses #11 ",
      "createdAt": "2020-12-03T09:45:10Z",
      "updatedAt": "2020-12-04T08:41:15Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "9b8f58e1ca4fc6b2cdaca4fecfdc688292dbbffb",
      "headRepository": "goelvidhi/rfc8312bis",
      "headRefName": "fast-recovery-mention",
      "headRefOid": "52a1f1f143a076f094ae0a637a1ca4490aac0fd5",
      "closedAt": "2020-12-04T08:41:15Z",
      "mergedAt": "2020-12-04T08:41:15Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "f2d72f728d1aff90f9f862b178bc1e5e6d94e36f"
      },
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert could you please review this PR? Thank you.",
          "createdAt": "2020-12-04T06:50:26Z",
          "updatedAt": "2020-12-04T06:50:55Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MDE3NjE1",
          "commit": {
            "abbreviatedOid": "69be5f5"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, Vidhi!\r\n",
          "createdAt": "2020-12-03T14:37:48Z",
          "updatedAt": "2020-12-03T14:37:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MjM5MTU2",
          "commit": {
            "abbreviatedOid": "69be5f5"
          },
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2020-12-03T18:08:11Z",
          "updatedAt": "2020-12-03T18:08:11Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NzQ0MDI3",
          "commit": {
            "abbreviatedOid": "69be5f5"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-12-04T08:26:34Z",
          "updatedAt": "2020-12-04T08:27:17Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\ncongestion is detected by receiving packets marked with ECN-Echo (ECE), CUBIC updates its W_max\r\n```",
              "createdAt": "2020-12-04T08:26:34Z",
              "updatedAt": "2020-12-04T08:36:23Z"
            },
            {
              "originalPosition": 9,
              "body": "```suggestion\r\npacket loss and congestion detection through ECN, the sender MAY\r\n```",
              "createdAt": "2020-12-04T08:27:06Z",
              "updatedAt": "2020-12-04T08:36:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NzUzMDg5",
          "commit": {
            "abbreviatedOid": "52a1f1f"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-04T08:40:59Z",
          "updatedAt": "2020-12-04T08:40:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 30,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMyMzQ1OTkw",
      "title": "highlight the difference from the original paper and RFC8312",
      "url": "https://github.com/NTAP/rfc8312bis/pull/30",
      "state": "MERGED",
      "author": "sangtaeha",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This includes the list of changes since the original paper. The section headings are similar to the issue logs at the end, so we may clean up at the end. Also, I didn't really install any tool to check this change (markdown and others). So please let me if this doesn't work. This fixes #10.",
      "createdAt": "2020-12-04T07:21:51Z",
      "updatedAt": "2020-12-16T08:41:21Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "b39d20a11aa9d4081e03acb50cbd0505da62c18c",
      "headRepository": "sangtaeha/rfc8312bis",
      "headRefName": "highlight-differences",
      "headRefOid": "2a5296d686b23d05f8049398dff519ebe638189e",
      "closedAt": "2020-12-16T08:41:21Z",
      "mergedAt": "2020-12-16T08:41:21Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "77c7776cff150c2122a01f787903143b993fa21a"
      },
      "comments": [
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "@goelvidhi @larseggert It complains about the space (it seems I didn't remove the space when I split the sentence) and the reference to Lisong's paper. Can you fix this issue? If not, I will submit a new pull request.",
          "createdAt": "2020-12-04T07:33:42Z",
          "updatedAt": "2020-12-04T07:33:42Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "I am fixing the spaces. Will push soon.",
          "createdAt": "2020-12-04T07:50:15Z",
          "updatedAt": "2020-12-04T07:50:15Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @goelvidhi!\r\n ",
          "createdAt": "2020-12-04T07:51:24Z",
          "updatedAt": "2020-12-04T07:51:24Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "I won't be able to push from your repo. Please find below the patch for spaces and tabs which you can apply using `git apply spaces.patch`\r\n[spaces.patch.zip](https://github.com/NTAP/rfc8312bis/files/5641291/spaces.patch.zip)\r\n",
          "createdAt": "2020-12-04T08:04:33Z",
          "updatedAt": "2020-12-04T08:04:33Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "@goelvidhi Great! Let me fix it with your patch.",
          "createdAt": "2020-12-04T08:08:28Z",
          "updatedAt": "2020-12-04T08:08:28Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "I am not sure why the editor's copy check is failing. @larseggert can likely help here.",
          "createdAt": "2020-12-04T08:19:35Z",
          "updatedAt": "2020-12-04T08:19:35Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "@goelvidhi Lisong's paper through DOI doesn't work. I think I may manually add that paper there like other papers.",
          "createdAt": "2020-12-04T08:21:22Z",
          "updatedAt": "2020-12-04T08:21:22Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "I'll fix the issue, hang on",
          "createdAt": "2020-12-04T11:32:48Z",
          "updatedAt": "2020-12-04T11:32:48Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert I installed the tools and found that adding a new reference caused a build error. I exactly followed the format but somehow it complained about the new reference. At this time, I simply removed this new reference. I will experiment until I know how to add a new reference.",
          "createdAt": "2020-12-04T11:33:56Z",
          "updatedAt": "2020-12-04T11:33:56Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "The problem was subtle. For \"automatic references\" to RFCs and I-Ds, one uses `{{?foo}}` to indicate an informative reference to \"foo\", and `{{!bar}}` for a normative reference to \"bar\". And the `?` or `!` needs to be used consistently, otherwise the reference is included twice, causing an error.\r\n\r\nOther references need to be included under `normative:` or `informative:`blocks at the beginning of the document. For those, one need not include `?` or `!` in the reference at all (because the status is known already), but if one includes `?` or `!` in the reference, it again needs to be done consistently.",
          "createdAt": "2020-12-04T11:37:57Z",
          "updatedAt": "2020-12-04T11:37:57Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert Great. Thanks!",
          "createdAt": "2020-12-04T11:38:37Z",
          "updatedAt": "2020-12-04T11:38:37Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Would this be ready for a merge after the conflicts are resolved?",
          "createdAt": "2020-12-16T07:00:40Z",
          "updatedAt": "2020-12-16T07:00:40Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert Yes, more likely. I rearranged them based on the feedback from you and @goelvidhi. After the merge, we can decide. The listed differences are more descriptive than the changelog, so we may either extend or shorten them.",
          "createdAt": "2020-12-16T07:20:58Z",
          "updatedAt": "2020-12-16T07:20:58Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "OK. I will merge once you resolve the conflicts to the `main` branch.",
          "createdAt": "2020-12-16T07:31:03Z",
          "updatedAt": "2020-12-16T07:31:03Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert I fixed it. Thanks!",
          "createdAt": "2020-12-16T08:13:26Z",
          "updatedAt": "2020-12-16T08:13:26Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NzQwNDk3",
          "commit": {
            "abbreviatedOid": "5e4302b"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-12-04T08:20:56Z",
          "updatedAt": "2020-12-04T08:24:37Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Please use title capitalization (also in your other headings)",
              "createdAt": "2020-12-04T08:20:56Z",
              "updatedAt": "2020-12-16T08:06:38Z"
            },
            {
              "originalPosition": 4,
              "body": "This DOI doesn't seem to be correct (or exist?)",
              "createdAt": "2020-12-04T08:21:35Z",
              "updatedAt": "2020-12-16T08:06:38Z"
            },
            {
              "originalPosition": 15,
              "body": "Reference the \"initial relase\"?",
              "createdAt": "2020-12-04T08:22:01Z",
              "updatedAt": "2020-12-16T08:06:38Z"
            },
            {
              "originalPosition": 33,
              "body": "This seems redundant with the bullet lists in the next appendix. Maybe we add a placeholder here for now, and convert the bullet list into a section when we're done with the draft?",
              "createdAt": "2020-12-04T08:23:34Z",
              "updatedAt": "2020-12-16T08:06:38Z"
            },
            {
              "originalPosition": 39,
              "body": "```suggestion\r\npaper was the window decrease constant while {{!RFC8312}} changed it to CUBIC\r\n```",
              "createdAt": "2020-12-04T08:24:06Z",
              "updatedAt": "2020-12-16T08:06:38Z"
            },
            {
              "originalPosition": 44,
              "body": "```suggestion\r\n- TCP friendly window is called W_est in {{!RFC8312}}, whereas it was W_tcp in\r\n```",
              "createdAt": "2020-12-04T08:24:23Z",
              "updatedAt": "2020-12-16T08:06:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NzQ3NzU3",
          "commit": {
            "abbreviatedOid": "5e4302b"
          },
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-04T08:32:23Z",
          "updatedAt": "2020-12-04T08:32:24Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "It looks like that is ACM's internal number. Let me manually add it. Thanks!",
              "createdAt": "2020-12-04T08:32:24Z",
              "updatedAt": "2020-12-16T08:06:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NzQ4ODY4",
          "commit": {
            "abbreviatedOid": "5e4302b"
          },
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-04T08:34:17Z",
          "updatedAt": "2020-12-04T08:34:17Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Yes, that makes sense. ",
              "createdAt": "2020-12-04T08:34:17Z",
              "updatedAt": "2020-12-16T08:06:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODExMzA4",
          "commit": {
            "abbreviatedOid": "bc75127"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-04T09:57:16Z",
          "updatedAt": "2020-12-04T09:57:16Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODEyOTk5",
          "commit": {
            "abbreviatedOid": "bc75127"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "You need to wrap your lines and fix the other issues the checker found before this can be merged",
          "createdAt": "2020-12-04T09:59:18Z",
          "updatedAt": "2020-12-04T09:59:18Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODg1NTkz",
          "commit": {
            "abbreviatedOid": "0a22765"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-04T11:41:23Z",
          "updatedAt": "2020-12-04T11:41:24Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Could you add that placeholder?",
              "createdAt": "2020-12-04T11:41:24Z",
              "updatedAt": "2020-12-16T08:06:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1MDI0MjM0",
          "commit": {
            "abbreviatedOid": "0a22765"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, Sangtae!",
          "createdAt": "2020-12-04T14:49:48Z",
          "updatedAt": "2020-12-04T14:49:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1MzY2MDc3",
          "commit": {
            "abbreviatedOid": "0a22765"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-04T23:41:58Z",
          "updatedAt": "2020-12-04T23:41:58Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MDM5OTMz",
          "commit": {
            "abbreviatedOid": "0a22765"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-07T11:01:10Z",
          "updatedAt": "2020-12-07T11:01:10Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "I think we should merge these two sections into the bullet lists below. Upon publication we can decide to convert the bullet lists to prose or remove them.",
              "createdAt": "2020-12-07T11:01:10Z",
              "updatedAt": "2020-12-16T08:06:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNDE4OTIy",
          "commit": {
            "abbreviatedOid": "458ee40"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-16T07:31:34Z",
          "updatedAt": "2020-12-16T07:31:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 31,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMzNjA0NDU0",
      "title": "Convert tables to Markdown",
      "url": "https://github.com/NTAP/rfc8312bis/pull/31",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-12-07T11:36:46Z",
      "updatedAt": "2020-12-08T06:51:29Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "f2d72f728d1aff90f9f862b178bc1e5e6d94e36f",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "markdown-tables",
      "headRefOid": "168dc09a5f4bd51725cd9c2d59434df5e44d43c3",
      "closedAt": "2020-12-08T06:51:25Z",
      "mergedAt": "2020-12-08T06:51:25Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "285c653468720250a84913bbbfef85aeab2c02ee"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MTgzOTM2",
          "commit": {
            "abbreviatedOid": "168dc09"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, Lars!",
          "createdAt": "2020-12-07T14:11:29Z",
          "updatedAt": "2020-12-07T14:11:29Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NjY4Njk5",
          "commit": {
            "abbreviatedOid": "168dc09"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-08T01:11:15Z",
          "updatedAt": "2020-12-08T01:11:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 32,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM0MzQxNDU5",
      "title": "add section for spurious loss events",
      "url": "https://github.com/NTAP/rfc8312bis/pull/32",
      "state": "MERGED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I attempted to write a section on spurious loss events and I am sure it needs more work.\r\nSending this PR to gather feedback and suggestions on the text.\r\n\r\nCloses #23 ",
      "createdAt": "2020-12-08T10:16:17Z",
      "updatedAt": "2020-12-14T07:12:07Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "bd1fcac0aba1b3960aaf3cb1cbc24b06d280a6bf",
      "headRepository": "goelvidhi/rfc8312bis",
      "headRefName": "spurious-retransmit",
      "headRefOid": "7f2f0a30be0cccec12dbe7ac6dcaaf4b061e319f",
      "closedAt": "2020-12-14T07:12:07Z",
      "mergedAt": "2020-12-14T07:12:06Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "bacd8983f5dff7c20284e7fb5299c970b980bf05"
      },
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert @lisongxu @sangtaeha, could you please give it a look when you have time :-). Thanks.",
          "createdAt": "2020-12-09T09:30:28Z",
          "updatedAt": "2020-12-09T09:30:28Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@goelvidhi Hi Vidhi, how about adding the following paragraphs to your section?\r\n\r\n_When there is a loss event, save the current values of the following variables before the window reduction_\r\n\r\n```\r\n    prior_cwnd = cwnd\r\n    prior_W_max = W_max\r\n    prior_K = K\r\n    prior_epoch_start = epoch_start\r\n```\r\n\r\n_Once a spurious loss event is detected, restore their original values as follows_\r\n\r\n```\r\n   cwnd = max(cwnd, prior_cwnd)\r\n   W_max = prior_W_max\r\n   K = prior_K\r\n   epoch_start = prior_epoch_start\r\n```",
          "createdAt": "2020-12-10T16:34:11Z",
          "updatedAt": "2020-12-10T16:38:24Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Also revising the first sentence right after Equation 1 in Section \"Window Increase Function\" as follow.\r\n\r\n_where t is the elapsed time in seconds from the beginning of the current congestion avoidance stage (i.e., t = current time - epoch_start, where epoch_start is the beginning time of the current congestion avoidance stage)._",
          "createdAt": "2020-12-10T16:38:08Z",
          "updatedAt": "2020-12-10T16:38:08Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@lisongxu should we also add W_est to the state that needs to be restored?",
          "createdAt": "2020-12-11T05:43:30Z",
          "updatedAt": "2020-12-11T05:43:30Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "> @lisongxu should we also add W_est to the state that needs to be restored?\r\n\r\nYes, you are right. Thanks, Vidhi!",
          "createdAt": "2020-12-11T14:11:42Z",
          "updatedAt": "2020-12-11T14:11:42Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4MjUyOTcz",
          "commit": {
            "abbreviatedOid": "6662b7a"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thank you, Vidhi! I would suggest two changes. \r\n\r\nFirst, add some references to the methods to detect spurious loss events.  @mwelzl listed some good references.\r\n\r\nSecond, explicitly list the variables to save when there is a loss event, and explicitly describe how to restore their values when a spurious loss event is detected. I can help you with this part. \r\n\r\nThank you again!",
          "createdAt": "2020-12-09T14:43:09Z",
          "updatedAt": "2020-12-09T14:43:09Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5ODQzNDM5",
          "commit": {
            "abbreviatedOid": "5ddf8b2"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-11T07:00:50Z",
          "updatedAt": "2020-12-11T07:02:19Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "IIRC Eifel comes with an IPR declaration that makes it problematic for many implementations. I'd cite it as OPTIONAL, with an informative reference.",
              "createdAt": "2020-12-11T07:00:50Z",
              "updatedAt": "2020-12-14T07:11:04Z"
            },
            {
              "originalPosition": 58,
              "body": "Should we recommend one of these over the other (i.e., with a SHOULD)?",
              "createdAt": "2020-12-11T07:01:24Z",
              "updatedAt": "2020-12-14T07:11:04Z"
            },
            {
              "originalPosition": 63,
              "body": "Why is this a `max` when the others are not?",
              "createdAt": "2020-12-11T07:02:03Z",
              "updatedAt": "2020-12-14T07:11:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5ODQ4ODcy",
          "commit": {
            "abbreviatedOid": "5ddf8b2"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-11T07:13:32Z",
          "updatedAt": "2020-12-11T07:13:32Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "I used MAY as an implementation could completely do something else (for example, QUIC doesn't require any of these).\r\nBut I don't have enough experience to decide what would be better. Please let me know if SHOULD would be ok in case an implementation decides to do something completely different?",
              "createdAt": "2020-12-11T07:13:32Z",
              "updatedAt": "2020-12-14T07:11:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5ODY4NzM3",
          "commit": {
            "abbreviatedOid": "5ddf8b2"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-11T07:53:24Z",
          "updatedAt": "2020-12-11T07:53:24Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "I'd at least reorder them so Eifel is last, and whatever we prefer is first. And make all the references informative (`?` instead of `!`).",
              "createdAt": "2020-12-11T07:53:24Z",
              "updatedAt": "2020-12-14T07:11:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5OTE2Mzcz",
          "commit": {
            "abbreviatedOid": "5ddf8b2"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-11T09:07:19Z",
          "updatedAt": "2020-12-11T09:07:20Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "@lisongxu had suggested this; I think it is to make sure if the congestion window had increased more than the prior_cwnd before the spurious retransmit is detected, we take the higher value.\r\nWould like to know what @lisongxu thinks about this.",
              "createdAt": "2020-12-11T09:07:19Z",
              "updatedAt": "2020-12-14T07:11:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5OTE2ODAw",
          "commit": {
            "abbreviatedOid": "5ddf8b2"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-11T09:07:53Z",
          "updatedAt": "2020-12-11T09:07:53Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "How do I cite something as OPTIONAL?\r\n",
              "createdAt": "2020-12-11T09:07:53Z",
              "updatedAt": "2020-12-14T07:11:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5OTE3MjYy",
          "commit": {
            "abbreviatedOid": "5ddf8b2"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-11T09:08:31Z",
          "updatedAt": "2020-12-11T09:08:32Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "We should explain this, since this doesn't do what the text says (which is \"restore the original values\").",
              "createdAt": "2020-12-11T09:08:32Z",
              "updatedAt": "2020-12-14T07:11:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5OTM3NTcx",
          "commit": {
            "abbreviatedOid": "ef89b34"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-11T09:35:46Z",
          "updatedAt": "2020-12-11T09:35:46Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "I rearranged the references and updated them to be informative.",
              "createdAt": "2020-12-11T09:35:46Z",
              "updatedAt": "2020-12-14T07:11:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5OTQwMjg2",
          "commit": {
            "abbreviatedOid": "ef89b34"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-11T09:39:14Z",
          "updatedAt": "2020-12-11T09:39:15Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "You cite it informatively and say that it MAY be used, as you currently are doing.\r\n\r\n",
              "createdAt": "2020-12-11T09:39:15Z",
              "updatedAt": "2020-12-14T07:11:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5OTQxMzcz",
          "commit": {
            "abbreviatedOid": "ef89b34"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-11T09:40:37Z",
          "updatedAt": "2020-12-11T09:40:38Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Do we mean that CUBIC MUST choose one of the three, and any of the three MAY be chosen? Or do we mean that CUBIC MAY choose one of the three but also something else?",
              "createdAt": "2020-12-11T09:40:37Z",
              "updatedAt": "2020-12-14T07:11:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5OTY0OTA3",
          "commit": {
            "abbreviatedOid": "ef89b34"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-11T10:11:57Z",
          "updatedAt": "2020-12-11T10:11:57Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "It's the last one - `Or do we mean that CUBIC MAY choose one of the three but also something else?`\r\n\r\nShould I phrase it differently?\r\n\r\n",
              "createdAt": "2020-12-11T10:11:57Z",
              "updatedAt": "2020-12-14T07:11:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5OTY1MjM0",
          "commit": {
            "abbreviatedOid": "ef89b34"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-11T10:12:24Z",
          "updatedAt": "2020-12-11T10:12:25Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "will wait for @lisongxu comment on this.",
              "createdAt": "2020-12-11T10:12:24Z",
              "updatedAt": "2020-12-14T07:11:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5OTgxNDc1",
          "commit": {
            "abbreviatedOid": "ef89b34"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-11T10:35:01Z",
          "updatedAt": "2020-12-11T10:35:02Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "```suggestion\r\nCUBIC MAY implement an algorithm to detect spurious retransmissions,\r\nsuch as DSACK {{?RFC3708}}, Forward RTO-Recovery {{?RFC5682}}\r\nor Eifel {{?RFC3522}}. Once a spurious loss event is detected, CUBIC should\r\n```",
              "createdAt": "2020-12-11T10:35:02Z",
              "updatedAt": "2020-12-14T07:11:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMTI4NTYy",
          "commit": {
            "abbreviatedOid": "ef89b34"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-11T14:09:41Z",
          "updatedAt": "2020-12-11T14:09:41Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "At an undo, the current cwnd may or may not be lower than the saved prior_cwnd. If the current cwnd is already higher than the saved prior_cwnd, we do not need to undo. \r\n\r\nHow about?\r\n\r\n_When there is a loss event, A CUBIC implementation SHOULD save the current\r\nvalue of the following variables before the congestion window reduction._\r\n\r\n~~~\r\n    prior_cwnd = cwnd\r\n    prior_ssthresh = ssthresh\r\n    prior_W_max = W_max\r\n    prior_K = K\r\n    prior_epoch_start = epoch_start\r\n    prior_W_est = W_est\r\n~~~\r\n\r\n_..................  Once a spurious loss event is detected, CUBIC should restore the original values of the above mentioned variables as follows if the current cwnd is lower than prior_cwnd._\r\n\r\n~~~\r\n    if (cwnd < prior_cwnd) {\r\n        cwnd = prior_cwnd\r\n        ssthresh = prior_ssthresh\r\n        W_max = prior_W_max\r\n        K = prior_K\r\n        epoch_start = prior_epoch_start\r\n        W_est = prior_W_est\r\n    }\r\n~~~\r\n\r\n",
              "createdAt": "2020-12-11T14:09:41Z",
              "updatedAt": "2020-12-14T07:11:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwNjg0MjEy",
          "commit": {
            "abbreviatedOid": "ef89b34"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-12T03:12:10Z",
          "updatedAt": "2020-12-12T03:12:10Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Ah.. I am not sure about not reverting the state when `cwnd > prior_cwnd`, esp. the variables W_max, epoch_start and K as these dictate the CUBIC curve. For example, W_max for the spurious loss event will be lower than prior_W_max and hence CUBIC will enter Convex phase earlier.\r\nSpurious loss detection should not usually take more than a couple of RTTs and I think the safest thing to do here is to revert all state to previous state, i.e.\r\n```\r\n        cwnd = prior_cwnd\r\n        ssthresh = prior_ssthresh\r\n        W_max = prior_W_max\r\n        K = prior_K\r\n        epoch_start = prior_epoch_start\r\n        W_est = prior_W_est",
              "createdAt": "2020-12-12T03:12:10Z",
              "updatedAt": "2020-12-14T07:11:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwNjg0NDk2",
          "commit": {
            "abbreviatedOid": "a84bfea"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-12T03:16:27Z",
          "updatedAt": "2020-12-12T03:16:27Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "done",
              "createdAt": "2020-12-12T03:16:27Z",
              "updatedAt": "2020-12-14T07:11:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwNjg1NTEy",
          "commit": {
            "abbreviatedOid": "ee15997"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-12T03:30:56Z",
          "updatedAt": "2020-12-12T03:30:57Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Since the goal of the undo is to improve the performance of Cubic, it is reasonable to keep the current cwnd if it is already higher than prior_cwnd. This is why I like to restore cwnd only if cwnd<prior_cwnd. By the way, this is how current Linux TCP does.\r\n\r\nBut I am not sure whether we should restore other variables. Both are fine with me. Thanks.",
              "createdAt": "2020-12-12T03:30:57Z",
              "updatedAt": "2020-12-14T07:11:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwNjk3MTI2",
          "commit": {
            "abbreviatedOid": "d46af26"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-12T06:56:04Z",
          "updatedAt": "2020-12-12T06:56:04Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "ok, I added a special note for congestion window. Please take a look.",
              "createdAt": "2020-12-12T06:56:04Z",
              "updatedAt": "2020-12-14T07:11:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwODQxMzAx",
          "commit": {
            "abbreviatedOid": "d46af26"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-12T16:06:20Z",
          "updatedAt": "2020-12-12T16:06:21Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Hi Vidhi, I thought about it last night, and now I prefer the if-then method as explained below. \r\n\r\nThere are two possible scenarios for undo. \r\n\r\nFirst (usual cases), an undo happens soon after a spurious loss event, and the current cwnd at undo is still lower than prior_cwnd. In these cases, it makes sense to restore the previous values of all the variables (better performance and safe). \r\n\r\nSecond (unusual cases), an undo happens long after a spurious loss event, and as a result, the current cwnd at undo is already higher than prior_cwnd. In these cases, it makes sense to keep the current values of all the variables, because their prior values were measured and calculated too long ago and thus may not be good or accurate measurements of the current network condition (bandwidth, delay, ...)\r\n\r\nTherefore, the undo code is\r\n~~~\r\n    if (cwnd < prior_cwnd) {\r\n        cwnd = prior_cwnd\r\n        ssthresh = prior_ssthresh\r\n        W_max = prior_W_max\r\n        K = prior_K\r\n        epoch_start = prior_epoch_start\r\n        W_est = prior_W_est\r\n    }\r\n~~~\r\n\r\nHow do you think?\r\n\r\nThanks!",
              "createdAt": "2020-12-12T16:06:20Z",
              "updatedAt": "2020-12-14T07:11:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwODU5NDA3",
          "commit": {
            "abbreviatedOid": "d46af26"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-12T20:21:56Z",
          "updatedAt": "2020-12-12T20:21:57Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Sounds good. Will update the PR.",
              "createdAt": "2020-12-12T20:21:56Z",
              "updatedAt": "2020-12-14T07:11:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxMDA1NzAy",
          "commit": {
            "abbreviatedOid": "b62432c"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-14T02:29:12Z",
          "updatedAt": "2020-12-14T02:29:12Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Updated the PR. @lisongxu does this look ok?",
              "createdAt": "2020-12-14T02:29:12Z",
              "updatedAt": "2020-12-14T07:11:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxMDIzNTM4",
          "commit": {
            "abbreviatedOid": "b62432c"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-14T03:37:34Z",
          "updatedAt": "2020-12-14T03:37:35Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Thanks, Vidhi! How about replacing \"In rare cases, when the detection happens long after a spurious loss event, \" with \"In rare cases, when the detection happens long after a spurious loss event and the current cwnd is already higher than the prior_cwnd,\"?\r\n\r\nThanks!",
              "createdAt": "2020-12-14T03:37:34Z",
              "updatedAt": "2020-12-14T07:11:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxMDM1MjU1",
          "commit": {
            "abbreviatedOid": "75f2ddc"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-14T04:25:52Z",
          "updatedAt": "2020-12-14T04:25:52Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "sounds good. Updated it. Please review, thanks.",
              "createdAt": "2020-12-14T04:25:52Z",
              "updatedAt": "2020-12-14T07:11:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxMDM1ODAy",
          "commit": {
            "abbreviatedOid": "75f2ddc"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you, Vidhi!",
          "createdAt": "2020-12-14T04:27:58Z",
          "updatedAt": "2020-12-14T04:27:58Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxMDQ4OTQ1",
          "commit": {
            "abbreviatedOid": "75f2ddc"
          },
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks great. Thanks, @goelvidhi and @lisongxu.",
          "createdAt": "2020-12-14T05:16:50Z",
          "updatedAt": "2020-12-14T05:16:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 33,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM0NDQzMzk2",
      "title": "Link to the closed issues",
      "url": "https://github.com/NTAP/rfc8312bis/pull/33",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-12-08T13:15:23Z",
      "updatedAt": "2020-12-09T14:46:32Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "285c653468720250a84913bbbfef85aeab2c02ee",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "link-to-issues",
      "headRefOid": "2b5ac12ec2321a7cc6dd2f450ca9821074402e50",
      "closedAt": "2020-12-08T17:04:32Z",
      "mergedAt": "2020-12-08T17:04:32Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "caaa2bc9bb6e50886724a7dcfcf9ebf55a61f2d4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NDI3OTg1",
          "commit": {
            "abbreviatedOid": "2b5ac12"
          },
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The list with the links looks great! Thanks, @larseggert!",
          "createdAt": "2020-12-08T16:51:50Z",
          "updatedAt": "2020-12-08T16:51:50Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4MjU2NTcz",
          "commit": {
            "abbreviatedOid": "2b5ac12"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks, Lars!",
          "createdAt": "2020-12-09T14:46:32Z",
          "updatedAt": "2020-12-09T14:46:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 34,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM0NDQ1MTYz",
      "title": "Pretty Latex math",
      "url": "https://github.com/NTAP/rfc8312bis/pull/34",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This uses the experimental `math` support in [kramdown-rfc2629](https://github.com/cabo/kramdown-rfc2629) to render Latex-style equations via [tex2svg](https://github.com/mathjax/mathjax-node-cli) and [asciitex](https://github.com/larseggert/asciiTeX).\r\n\r\nI'm still working through some issues with the toolchain, so this isn't ready for merging yet, but I wanted to give you a preview.",
      "createdAt": "2020-12-08T13:18:18Z",
      "updatedAt": "2020-12-16T07:30:04Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "bacd8983f5dff7c20284e7fb5299c970b980bf05",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "pretty-math",
      "headRefOid": "c3902ba60735a10ef8e26cc2660fac1e0fcb2949",
      "closedAt": "2020-12-16T07:30:00Z",
      "mergedAt": "2020-12-16T07:30:00Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "b39d20a11aa9d4081e03acb50cbd0505da62c18c"
      },
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "It looks nice. There is some markup text showing up in Definitions section, but I am sure you already know about it. :-)",
          "createdAt": "2020-12-09T07:11:38Z",
          "updatedAt": "2020-12-09T07:11:38Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@goelvidhi yes, that is part of the toolchain issue. The text version is also missing some of the math, which is another.",
          "createdAt": "2020-12-09T09:33:15Z",
          "updatedAt": "2020-12-09T09:33:15Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "This is ready for review!",
          "createdAt": "2020-12-15T09:40:12Z",
          "updatedAt": "2020-12-15T09:40:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyMjg0MjA1",
          "commit": {
            "abbreviatedOid": "24d64a0"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-15T09:59:31Z",
          "updatedAt": "2020-12-15T10:06:22Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "segment/second^3 is showing up in the next line. Is that expected?",
              "createdAt": "2020-12-15T09:59:31Z",
              "updatedAt": "2020-12-16T07:25:10Z"
            },
            {
              "originalPosition": 124,
              "body": "This shows up as Figure 1 instead of Eq. 1. Is it because of the pretty math?\r\n",
              "createdAt": "2020-12-15T10:01:08Z",
              "updatedAt": "2020-12-16T07:25:10Z"
            },
            {
              "originalPosition": 287,
              "body": "this is also going into next line, which is likely due to the pretty math. But as it is in the middle of a sentence, it looks a bit odd.",
              "createdAt": "2020-12-15T10:04:05Z",
              "updatedAt": "2020-12-16T07:25:10Z"
            },
            {
              "originalPosition": 311,
              "body": "same comment here.",
              "createdAt": "2020-12-15T10:04:30Z",
              "updatedAt": "2020-12-16T07:25:10Z"
            },
            {
              "originalPosition": 378,
              "body": "this looks great. ",
              "createdAt": "2020-12-15T10:05:41Z",
              "updatedAt": "2020-12-16T07:25:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyNDM2MzA3",
          "commit": {
            "abbreviatedOid": "24d64a0"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-15T13:15:11Z",
          "updatedAt": "2020-12-15T13:15:12Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Yes. The `xml2rfc` tool can't handle inline math.",
              "createdAt": "2020-12-15T13:15:12Z",
              "updatedAt": "2020-12-16T07:25:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyNDM2NjE2",
          "commit": {
            "abbreviatedOid": "24d64a0"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-15T13:15:35Z",
          "updatedAt": "2020-12-15T13:15:35Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "It's because of the `xml2rfc` tool again. It calls everything a \"figure\".",
              "createdAt": "2020-12-15T13:15:35Z",
              "updatedAt": "2020-12-16T07:25:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyNDM2Nzk3",
          "commit": {
            "abbreviatedOid": "24d64a0"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-15T13:15:47Z",
          "updatedAt": "2020-12-15T13:15:47Z",
          "comments": [
            {
              "originalPosition": 287,
              "body": "See above.",
              "createdAt": "2020-12-15T13:15:47Z",
              "updatedAt": "2020-12-16T07:25:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyNDM2ODg1",
          "commit": {
            "abbreviatedOid": "24d64a0"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-15T13:15:54Z",
          "updatedAt": "2020-12-15T13:15:54Z",
          "comments": [
            {
              "originalPosition": 311,
              "body": "See above.",
              "createdAt": "2020-12-15T13:15:54Z",
              "updatedAt": "2020-12-16T07:25:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzMzU4OTQ3",
          "commit": {
            "abbreviatedOid": "24d64a0"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-16T05:04:06Z",
          "updatedAt": "2020-12-16T05:04:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 35,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM2MDU2MDA3",
      "title": "Initialization",
      "url": "https://github.com/NTAP/rfc8312bis/pull/35",
      "state": "MERGED",
      "author": "lisongxu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Removing variable w_last_max and keeping only w_max, for two reasons.\r\n\r\n1) w_last_max is not explicitly initialized in section 4.7 (timeout).\r\n\r\n2) simplify RFC and avoid confusion. ",
      "createdAt": "2020-12-10T16:21:19Z",
      "updatedAt": "2020-12-14T07:10:00Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "caaa2bc9bb6e50886724a7dcfcf9ebf55a61f2d4",
      "headRepository": "lisongxu/rfc8312bis",
      "headRefName": "Initialization",
      "headRefOid": "cbac491e9b424f056a54c85ab09ab8b383755d42",
      "closedAt": "2020-12-14T07:10:00Z",
      "mergedAt": "2020-12-14T07:10:00Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "bd1fcac0aba1b3960aaf3cb1cbc24b06d280a6bf"
      },
      "comments": [
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "There are three nits that need to be fixed: https://github.com/NTAP/rfc8312bis/pull/35/checks?check_run_id=1531869631",
          "createdAt": "2020-12-10T17:07:07Z",
          "updatedAt": "2020-12-10T17:07:07Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @larseggert . Just fixed",
          "createdAt": "2020-12-10T18:52:48Z",
          "updatedAt": "2020-12-10T18:52:48Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks great. Thanks @lisongxu.\r\nCan we add the change log for this? ",
          "createdAt": "2020-12-11T03:08:16Z",
          "updatedAt": "2020-12-11T04:05:22Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "> Looks great. Thanks @lisongxu.\r\n> Can we add the change log for this?\r\n\r\nYes, I will add that. \r\n\r\nAlso we should initialize W_est in case of timeout (similar to undo). ",
          "createdAt": "2020-12-11T14:16:16Z",
          "updatedAt": "2020-12-11T14:16:16Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@sangtaeha Hi Sangtae,  could you please read and review the changes? Thanks",
          "createdAt": "2020-12-14T04:30:13Z",
          "updatedAt": "2020-12-14T04:30:13Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NTA1NTg0",
          "commit": {
            "abbreviatedOid": "759b9ff"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-10T18:53:53Z",
          "updatedAt": "2020-12-10T18:53:53Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwNjgyMzg2",
          "commit": {
            "abbreviatedOid": "cbac491"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-12T02:47:26Z",
          "updatedAt": "2020-12-12T02:47:26Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxMDQ2Nzk1",
          "commit": {
            "abbreviatedOid": "cbac491"
          },
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks @lisongxu ",
          "createdAt": "2020-12-14T05:09:59Z",
          "updatedAt": "2020-12-14T05:09:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 36,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQxMjM0NTYx",
      "title": "Address (some of) Lisong's review issues",
      "url": "https://github.com/NTAP/rfc8312bis/pull/36",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-12-16T15:11:34Z",
      "updatedAt": "2020-12-17T17:28:09Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "57dbee7118ca2804cc8eb377a25c02051f196756",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "lisongs-issues",
      "headRefOid": "feae3b5319793b043ad14a65d15a06fd03ba8756",
      "closedAt": "2020-12-17T17:28:06Z",
      "mergedAt": "2020-12-17T17:28:06Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "8cb2c1cb3c391f169e8e3818005e36e6fcba5e32"
      },
      "comments": [
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@lisongxu do you have a suggestion for the one issue I didn't address yet?\r\n\r\n>>Section 4.2: the cwnds used in Figure 2 and target equation are two different cwnds. In figure 2, cwnd is the cwnd at the beginning of the current congestion avoidance stage. In target (should also be referred to as Figure x?), cwnd is the current actual cwnd at time t.\r\n\r\n> I need some help coming up with a solution to this one.",
          "createdAt": "2020-12-16T15:31:08Z",
          "updatedAt": "2020-12-16T15:31:08Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "I will reply on github so that we can keep track of the discussions, Thanks\nLisong\n\n________________________________\nFrom: Lars Eggert <notifications@github.com>\nSent: Wednesday, December 16, 2020 9:31 AM\nTo: NTAP/rfc8312bis <rfc8312bis@noreply.github.com>\nCc: Lisong Xu <xu@unl.edu>; Mention <mention@noreply.github.com>\nSubject: Re: [NTAP/rfc8312bis] Address (some of) Lisong's review issues (#36)\n\n\n@lisongxu<https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_lisongxu&d=DwMCaQ&c=Cu5g146wZdoqVuKpTNsYHeFX_rg6kWhlkLF8Eft-wwo&r=8GgbmpxpPRnPS9z8_jUQhw&m=5KC63MXbfmYPOr1W6jy-0tNqLOzjPAJcFZfJC1znE48&s=3jVg2QE_Z_PXHBoRGZ9ha4-rRZmJsmIe_7zqAHb8Cpk&e=> do you have a suggestion for the one issue I didn't address yet?\n\nSection 4.2: the cwnds used in Figure 2 and target equation are two different cwnds. In figure 2, cwnd is the cwnd at the beginning of the current congestion avoidance stage. In target (should also be referred to as Figure x?), cwnd is the current actual cwnd at time t.\n\nI need some help coming up with a solution to this one.\n\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub<https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_NTAP_rfc8312bis_pull_36-23issuecomment-2D746479864&d=DwMCaQ&c=Cu5g146wZdoqVuKpTNsYHeFX_rg6kWhlkLF8Eft-wwo&r=8GgbmpxpPRnPS9z8_jUQhw&m=5KC63MXbfmYPOr1W6jy-0tNqLOzjPAJcFZfJC1znE48&s=3yQJdHKhz17Jc-B6fJOBgP-9GZ0DxIhQ-4AqxaH6cEQ&e=>, or unsubscribe<https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_notifications_unsubscribe-2Dauth_ACPRVIPQDNADZJBLBOQBTQDSVDHEZANCNFSM4U6EJ7FA&d=DwMCaQ&c=Cu5g146wZdoqVuKpTNsYHeFX_rg6kWhlkLF8Eft-wwo&r=8GgbmpxpPRnPS9z8_jUQhw&m=5KC63MXbfmYPOr1W6jy-0tNqLOzjPAJcFZfJC1znE48&s=mtT4P_TIQIogZkJbYcWKBoEx5AjFcA3VmBp8uhcJKSE&e=>.\n",
          "createdAt": "2020-12-16T15:32:52Z",
          "updatedAt": "2020-12-16T15:32:52Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "> @lisongxu do you have a suggestion for the one issue I didn't address yet?\r\n> \r\n> > > Section 4.2: the cwnds used in Figure 2 and target equation are two different cwnds. In figure 2, cwnd is the cwnd at the beginning of the current congestion avoidance stage. In target (should also be referred to as Figure x?), cwnd is the current actual cwnd at time t.\r\n> \r\n> > I need some help coming up with a solution to this one.\r\n\r\nBecause cwnd refers to the current cwnd in the whole RFC, except the cwnd in Figure 2. How about we define a new variable cwnd_{start} for just figure/equation 2 as we have discussed before?\r\n\r\nThat is, we change figure/equation 2 as follows, and replace all cwnd in the paragraph immediately below figure/equation 2 with cwnd_{start}.\r\n\r\nK = \\sqrt[3]{\\frac{W_{max} - cwnd_{start}}{C}}\r\n\r\nUpdate other sections accordingly as follow\r\n\r\nIn Section \"Variables of interest\", we add \"cwnd_{start}: The cwnd at the beginning of the current congestion avoidance stage (i.e., at time epoch_{start})\"\r\n\r\nThanks\r\n\r\n\r\n\r\n",
          "createdAt": "2020-12-16T15:41:04Z",
          "updatedAt": "2020-12-16T15:41:04Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Thanks, I will make that change tomorrow and you guys can review after.",
          "createdAt": "2020-12-16T17:38:15Z",
          "updatedAt": "2020-12-16T17:38:15Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "OK, please review the changes. I am not sure if I managed to change `cwnd` to `cwnd_start` everywhere.",
          "createdAt": "2020-12-17T13:55:52Z",
          "updatedAt": "2020-12-17T13:55:52Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzODAxOTk1",
          "commit": {
            "abbreviatedOid": "6f6b794"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, Lars",
          "createdAt": "2020-12-16T15:29:03Z",
          "updatedAt": "2020-12-16T15:29:03Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0NjcwNDIx",
          "commit": {
            "abbreviatedOid": "feae3b5"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, Lars!",
          "createdAt": "2020-12-17T14:44:51Z",
          "updatedAt": "2020-12-17T14:44:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 37,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQxNTYxOTYz",
      "title": "added Injong's author block.",
      "url": "https://github.com/NTAP/rfc8312bis/pull/37",
      "state": "MERGED",
      "author": "Injongrhee",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I am not so familiar with git so there has been some learning curve for me. Now that I figured it out, I can contribute regularly. I will review the change and provide comments if necessary. \r\n\r\nThis closes #16 ",
      "createdAt": "2020-12-17T02:41:39Z",
      "updatedAt": "2020-12-17T07:12:45Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "c6c2cbe8e1fe919ae4faeaca386b76ef1c72c668",
      "headRepository": "Injongrhee/rfc8312bis",
      "headRefName": "add-injong",
      "headRefOid": "0b575da5c17110cc4cf87cc6a9faf3c8f009fc0f",
      "closedAt": "2020-12-17T07:12:45Z",
      "mergedAt": "2020-12-17T07:12:45Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "c8a17e5038abbef4324f730e8425bc52193aceb0"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 40,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY5MzkyNzkx",
      "title": "Switch to martinthomson/i-d-template@v1m",
      "url": "https://github.com/NTAP/rfc8312bis/pull/40",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "As requested in https://github.com/martinthomson/i-d-template/pull/259",
      "createdAt": "2021-02-08T11:21:25Z",
      "updatedAt": "2021-02-10T10:14:17Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "8cb2c1cb3c391f169e8e3818005e36e6fcba5e32",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "use-new-i-d-template",
      "headRefOid": "b19952152b27a451572dc4d61e0f14a1d364a5de",
      "closedAt": "2021-02-10T10:14:12Z",
      "mergedAt": "2021-02-10T10:14:12Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "f3f7ffbe186bce0ba667992c1056a407e41cde11"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 41,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc1MjEwNTE4",
      "title": "Issues 38 and 39",
      "url": "https://github.com/NTAP/rfc8312bis/pull/41",
      "state": "MERGED",
      "author": "lisongxu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Issue 38: \"TCP-Friendly\" is a bit misleading\r\nhttps://github.com/NTAP/rfc8312bis/issues/38\r\n\r\nIssue 39: Change introductory text to reflect deployment experience \r\nhttps://github.com/NTAP/rfc8312bis/issues/39\r\n",
      "createdAt": "2021-02-17T21:02:07Z",
      "updatedAt": "2021-02-19T09:24:47Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "5d19dbc0eb52a8aa4f1701871d190d8faf0f1d53",
      "headRepository": "lisongxu/rfc8312bis",
      "headRefName": "main",
      "headRefOid": "95b02537922f0652d7aa002b49a5d2e7f94958af",
      "closedAt": "2021-02-19T09:24:47Z",
      "mergedAt": "2021-02-19T09:24:47Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "8e81c7094dd9e8c97cfbe9d5638453e8bb5dc371"
      },
      "comments": [
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "I thought about that too, :-) and finally decided to use AIMD TCP receivers; otherwise it is kind of weird to have only AIMD TCP senders.\nThanks\nLisong\n\n________________________________\nFrom: Vidhi Goel <notifications@github.com>\nSent: Thursday, February 18, 2021 9:02 PM\nTo: NTAP/rfc8312bis <rfc8312bis@noreply.github.com>\nCc: Lisong Xu <xu@unl.edu>; Author <author@noreply.github.com>\nSubject: Re: [NTAP/rfc8312bis] Issues 38 and 39 (#41)\n\nNon-NU Email\n________________________________\n\n@goelvidhi commented on this pull request.\n\n________________________________\n\nIn draft-eggert-tcpm-rfc8312bis.md<https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_NTAP_rfc8312bis_pull_41-23discussion-5Fr578868980&d=DwMCaQ&c=Cu5g146wZdoqVuKpTNsYHeFX_rg6kWhlkLF8Eft-wwo&r=8GgbmpxpPRnPS9z8_jUQhw&m=uqkd9u6PKUtKZe3yHSvXDITyrfQWpeWRo54EehTG8J4&s=1kXp_0IaNhb1Ifb9NiBWPkdpRSx1kXqYR1wDlQWUi50&e=>:\n\n>\n ## Incremental Deployment\n\n-CUBIC requires only the change of TCP senders, and it does not make\n-any changes to TCP receivers. That is, a CUBIC sender works correctly\n-with the Standard TCP receivers. In addition, CUBIC does not require\n+CUBIC requires only the change of AIMD TCP senders, and it does not make\n+any changes to AIMD TCP receivers. That is, a CUBIC sender works correctly\n\n\nShould we just leave the receivers as \"TCP receivers\"? Not sure if AIMD makes sense for receiver\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub<https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_NTAP_rfc8312bis_pull_41-23pullrequestreview-2D593795572&d=DwMCaQ&c=Cu5g146wZdoqVuKpTNsYHeFX_rg6kWhlkLF8Eft-wwo&r=8GgbmpxpPRnPS9z8_jUQhw&m=uqkd9u6PKUtKZe3yHSvXDITyrfQWpeWRo54EehTG8J4&s=LGVxL2CJRIBMrhJKsD9_WiFoimfBUibvXJprvsqgjRI&e=>, or unsubscribe<https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_notifications_unsubscribe-2Dauth_ACPRVIOIAWXLQVCN2HBVRRDS7XIENANCNFSM4XZCIDTQ&d=DwMCaQ&c=Cu5g146wZdoqVuKpTNsYHeFX_rg6kWhlkLF8Eft-wwo&r=8GgbmpxpPRnPS9z8_jUQhw&m=uqkd9u6PKUtKZe3yHSvXDITyrfQWpeWRo54EehTG8J4&s=9QE-OFEs1-kKdwGmViFjcvPdyyMYRC8ijpEZMFcqHuw&e=>.\n",
          "createdAt": "2021-02-19T03:45:58Z",
          "updatedAt": "2021-02-19T03:45:58Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyOTk1NjA4",
          "commit": {
            "abbreviatedOid": "cc72723"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-02-18T09:13:48Z",
          "updatedAt": "2021-02-18T09:35:57Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Is Android not Linux?",
              "createdAt": "2021-02-18T09:13:48Z",
              "updatedAt": "2021-02-19T05:52:25Z"
            },
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nWindows, and Apple stacks. This document\r\nupdates the specification of CUBIC to include algorithmic\r\nimprovements based on these implementations and recent\r\nacademic work. Based on the extensive deployment experience\r\nwith CUBIC, it also moves the specification to the Standards Track.\r\n```\r\n",
              "createdAt": "2021-02-18T09:18:07Z",
              "updatedAt": "2021-02-19T05:52:25Z"
            },
            {
              "originalPosition": 42,
              "body": "```suggestion\r\ncongestion control algorithm of traditional Additive Increase and\r\nMultiplicative Decrease (AIMD) TCP to remedy this problem.\r\n```\r\n",
              "createdAt": "2021-02-18T09:19:40Z",
              "updatedAt": "2021-02-19T05:52:25Z"
            },
            {
              "originalPosition": 63,
              "body": "Same a comment about Android using Linux?",
              "createdAt": "2021-02-18T09:20:28Z",
              "updatedAt": "2021-02-19T05:52:25Z"
            },
            {
              "originalPosition": 67,
              "body": "```suggestion\r\nExtensive, decade-long deployment experience in vastly different\r\nInternet scenarios has convincingly demonstrated that CUBIC is\r\nsafe for deployment on the global Internet and delivers substantial\r\nbenefits over traditional AIMD congestion control. It is therefore to\r\nbe regarded as the current standard for TCP congestion control.\r\n```",
              "createdAt": "2021-02-18T09:22:27Z",
              "updatedAt": "2021-02-19T05:52:25Z"
            },
            {
              "originalPosition": 82,
              "body": "Would it be possible to turn the following four very long paragraphs on these different four principles into sub-sections? Could someone suggest for section headings to use?",
              "createdAt": "2021-02-18T09:25:26Z",
              "updatedAt": "2021-02-19T05:52:25Z"
            },
            {
              "originalPosition": 260,
              "body": "```suggestion\r\nAIMD TCP, which uses AIMD(1, 0.5).\r\n```",
              "createdAt": "2021-02-18T09:30:13Z",
              "updatedAt": "2021-02-19T05:52:25Z"
            },
            {
              "originalPosition": 411,
              "body": "```suggestion\r\nin fast, long-distance networks. Based on these observations\r\n```",
              "createdAt": "2021-02-18T09:31:28Z",
              "updatedAt": "2021-02-19T05:52:25Z"
            },
            {
              "originalPosition": 412,
              "body": "```suggestion\r\nand extensive deployment experience, we find *C*=0.4 gives\r\na good balance between AIMD-\r\n```",
              "createdAt": "2021-02-18T09:32:28Z",
              "updatedAt": "2021-02-19T05:52:25Z"
            },
            {
              "originalPosition": 462,
              "body": "```suggestion\r\nMore information can be found in {{HKLRX06}}.\r\nAdditionally, there is decade-long deployment experience\r\nwith CUBIC on the Internet.\r\n```\r\n",
              "createdAt": "2021-02-18T09:34:23Z",
              "updatedAt": "2021-02-19T05:52:25Z"
            },
            {
              "originalPosition": 529,
              "body": "This should move to a new subsection called `## Since draft-eggert-tcpm-rfc8312bis-01` that should come before the section this text is currently in.",
              "createdAt": "2021-02-18T09:35:37Z",
              "updatedAt": "2021-02-19T05:52:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzMjY4ODkz",
          "commit": {
            "abbreviatedOid": "e72c027"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-18T14:26:34Z",
          "updatedAt": "2021-02-18T14:26:34Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "ok, I will remove it.",
              "createdAt": "2021-02-18T14:26:34Z",
              "updatedAt": "2021-02-19T05:52:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzMjcwODEw",
          "commit": {
            "abbreviatedOid": "65755e3"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-18T14:28:21Z",
          "updatedAt": "2021-02-18T14:28:22Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "removed",
              "createdAt": "2021-02-18T14:28:22Z",
              "updatedAt": "2021-02-19T05:52:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzMjcyMzA2",
          "commit": {
            "abbreviatedOid": "d0087aa"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-18T14:29:44Z",
          "updatedAt": "2021-02-18T14:29:44Z",
          "comments": [
            {
              "originalPosition": 529,
              "body": "done",
              "createdAt": "2021-02-18T14:29:44Z",
              "updatedAt": "2021-02-19T05:52:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzMjc5Mzkw",
          "commit": {
            "abbreviatedOid": "4a4b0c9"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-18T14:36:12Z",
          "updatedAt": "2021-02-18T14:36:12Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "Done. ",
              "createdAt": "2021-02-18T14:36:12Z",
              "updatedAt": "2021-02-19T05:52:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzMzI4NzI3",
          "commit": {
            "abbreviatedOid": "4a4b0c9"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-18T15:18:55Z",
          "updatedAt": "2021-02-18T15:18:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzNzk1NTcy",
          "commit": {
            "abbreviatedOid": "4a4b0c9"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-19T01:48:53Z",
          "updatedAt": "2021-02-19T03:02:10Z",
          "comments": [
            {
              "originalPosition": 530,
              "body": "Should we just leave the receivers as \"TCP receivers\"? Not sure if AIMD makes sense for receiver",
              "createdAt": "2021-02-19T01:48:53Z",
              "updatedAt": "2021-02-19T05:52:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzODU1MjY1",
          "commit": {
            "abbreviatedOid": "4a4b0c9"
          },
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "@lisongxu Thanks a lot for the changes! I just found two small changes to consider. ",
          "createdAt": "2021-02-19T04:43:12Z",
          "updatedAt": "2021-02-19T05:13:24Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "@lisongxu We may remove ',' before \"below because .. \" ",
              "createdAt": "2021-02-19T04:43:12Z",
              "updatedAt": "2021-02-19T05:52:25Z"
            },
            {
              "originalPosition": 436,
              "body": "@lisongxu Since we are using fast and long-distance networks in a few places, for consistency, we may use \"fast and long-distance networks\" instead of \"fast, long-distance networks.\"",
              "createdAt": "2021-02-19T05:04:37Z",
              "updatedAt": "2021-02-19T05:52:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzODc5MTc0",
          "commit": {
            "abbreviatedOid": "4a4b0c9"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-19T05:47:28Z",
          "updatedAt": "2021-02-19T05:47:28Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "done",
              "createdAt": "2021-02-19T05:47:28Z",
              "updatedAt": "2021-02-19T05:52:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzODgwNDc5",
          "commit": {
            "abbreviatedOid": "ef58678"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-19T05:51:01Z",
          "updatedAt": "2021-02-19T05:51:01Z",
          "comments": [
            {
              "originalPosition": 436,
              "body": "done",
              "createdAt": "2021-02-19T05:51:01Z",
              "updatedAt": "2021-02-19T05:52:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzOTExNTAz",
          "commit": {
            "abbreviatedOid": "95b0253"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-19T07:07:44Z",
          "updatedAt": "2021-02-19T07:07:44Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzOTEyNDEx",
          "commit": {
            "abbreviatedOid": "95b0253"
          },
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-19T07:09:49Z",
          "updatedAt": "2021-02-19T07:09:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 42,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc2MzU2NjIy",
      "title": "Minor editorial changes",
      "url": "https://github.com/NTAP/rfc8312bis/pull/42",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-02-19T10:29:05Z",
      "updatedAt": "2021-02-22T08:44:57Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "006af1a400234eff5dfdd364e40ae942399e56ed",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "minor-fixes",
      "headRefOid": "db30be6ae56d80afe19b5cf3071397f7911a8c4a",
      "closedAt": "2021-02-22T08:44:54Z",
      "mergedAt": "2021-02-22T08:44:54Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "802084896c2b3a10a0a84c7db3457f27e65d29ba"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0MjI1NTg2",
          "commit": {
            "abbreviatedOid": "fe6f4e8"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-19T14:13:57Z",
          "updatedAt": "2021-02-19T14:13:57Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0ODAwNjM3",
          "commit": {
            "abbreviatedOid": "fe6f4e8"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-21T02:22:52Z",
          "updatedAt": "2021-02-21T02:22:52Z",
          "comments": [
            {
              "originalPosition": 430,
              "body": "IMO, it is tricky to get the adaptive adjustment right, not sure if @lisongxu is already researching on this.",
              "createdAt": "2021-02-21T02:22:52Z",
              "updatedAt": "2021-02-22T08:40:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0ODAwNjM5",
          "commit": {
            "abbreviatedOid": "fe6f4e8"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-21T02:22:57Z",
          "updatedAt": "2021-02-21T02:22:57Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0ODY0MTcz",
          "commit": {
            "abbreviatedOid": "fe6f4e8"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-21T17:46:16Z",
          "updatedAt": "2021-02-21T17:46:16Z",
          "comments": [
            {
              "originalPosition": 430,
              "body": "No, we are not working on it. Let's remove this sentence. Thanks.",
              "createdAt": "2021-02-21T17:46:16Z",
              "updatedAt": "2021-02-22T08:40:20Z"
            }
          ]
        }
      ]
    },
    {
      "number": 48,
      "id": "MDExOlB1bGxSZXF1ZXN0NTgwNDE2OTI5",
      "title": "Fix some typos",
      "url": "https://github.com/NTAP/rfc8312bis/pull/48",
      "state": "MERGED",
      "author": "maolson-msft",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-02-25T21:20:09Z",
      "updatedAt": "2021-03-01T07:50:38Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "802084896c2b3a10a0a84c7db3457f27e65d29ba",
      "headRepository": "maolson-msft/rfc8312bis",
      "headRefName": "patch-1",
      "headRefOid": "ead0a1e138a0cf40e14855b1f95b1206d5112526",
      "closedAt": "2021-03-01T07:50:38Z",
      "mergedAt": "2021-03-01T07:50:38Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "f22445fb591faa87de730adb69edee42e67784f6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5MjA0MDYx",
          "commit": {
            "abbreviatedOid": "ead0a1e"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-26T02:23:32Z",
          "updatedAt": "2021-02-26T02:23:32Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5MjE5Njk2",
          "commit": {
            "abbreviatedOid": "ead0a1e"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-26T03:07:38Z",
          "updatedAt": "2021-02-26T03:07:38Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "could you remove the comma after Windows?",
              "createdAt": "2021-02-26T03:07:38Z",
              "updatedAt": "2021-02-26T03:07:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5MjE5Nzg3",
          "commit": {
            "abbreviatedOid": "ead0a1e"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-26T03:07:56Z",
          "updatedAt": "2021-02-26T03:07:56Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "same here",
              "createdAt": "2021-02-26T03:07:56Z",
              "updatedAt": "2021-02-26T03:07:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5OTI1MzEz",
          "commit": {
            "abbreviatedOid": "ead0a1e"
          },
          "author": "maolson-msft",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-26T20:39:21Z",
          "updatedAt": "2021-02-26T20:39:21Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "This is valid usage, i.e. an \"Oxford Comma.\" I prefer to use the Oxford Comma but I don't feel strongly about it; let me know if you still want this change. ",
              "createdAt": "2021-02-26T20:39:21Z",
              "updatedAt": "2021-02-26T20:39:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAwMDkyMDMy",
          "commit": {
            "abbreviatedOid": "ead0a1e"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-27T06:36:11Z",
          "updatedAt": "2021-02-27T06:36:11Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "What do we do elsewhere? We should be consistent.",
              "createdAt": "2021-02-27T06:36:11Z",
              "updatedAt": "2021-02-27T06:36:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAwMTAyMzY0",
          "commit": {
            "abbreviatedOid": "ead0a1e"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-27T06:43:04Z",
          "updatedAt": "2021-02-27T06:43:05Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I did some quick search, and we are using the \"Oxford Comma.\" Lets keep it as is.",
              "createdAt": "2021-02-27T06:43:04Z",
              "updatedAt": "2021-02-27T06:44:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAwNDU4OTc1",
          "commit": {
            "abbreviatedOid": "ead0a1e"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-01T07:50:33Z",
          "updatedAt": "2021-03-01T07:50:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 49,
      "id": "MDExOlB1bGxSZXF1ZXN0NTgwNTY4MTc2",
      "title": "add definition for segments_acked and Alpha_aimd",
      "url": "https://github.com/NTAP/rfc8312bis/pull/49",
      "state": "MERGED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #47 ",
      "createdAt": "2021-02-26T03:15:40Z",
      "updatedAt": "2021-03-04T00:14:43Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "802084896c2b3a10a0a84c7db3457f27e65d29ba",
      "headRepository": "goelvidhi/rfc8312bis",
      "headRefName": "more-definitions",
      "headRefOid": "f96b1949e01ab238ac0fdf08d3d5123b5102a6e4",
      "closedAt": "2021-03-03T07:37:49Z",
      "mergedAt": "2021-03-03T07:37:49Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "4b54c398434574cb2bc9d18d4e6629c4c9e099f9"
      },
      "comments": [
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "As this is minor, merging it now.",
          "createdAt": "2021-03-03T07:37:34Z",
          "updatedAt": "2021-03-03T07:37:34Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "I merged this and then realized there wasn't an entry for the changelog in the PR. @goelvidhi could you add that in your next PR?",
          "createdAt": "2021-03-03T07:46:57Z",
          "updatedAt": "2021-03-03T07:46:57Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "will do.",
          "createdAt": "2021-03-04T00:14:43Z",
          "updatedAt": "2021-03-04T00:14:43Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5MzEwMDY3",
          "commit": {
            "abbreviatedOid": "f96b194"
          },
          "author": "junhochoi",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2021-02-26T07:24:46Z",
          "updatedAt": "2021-02-26T07:24:46Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAwNjU5Mjc3",
          "commit": {
            "abbreviatedOid": "f96b194"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-01T12:01:58Z",
          "updatedAt": "2021-03-01T12:02:45Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "This seems like an unrelated change?",
              "createdAt": "2021-03-01T12:02:33Z",
              "updatedAt": "2021-03-01T12:02:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAyNTg1NTgw",
          "commit": {
            "abbreviatedOid": "f96b194"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-03T07:28:26Z",
          "updatedAt": "2021-03-03T07:28:26Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "It is. But I did it as it was a minor fix.",
              "createdAt": "2021-03-03T07:28:26Z",
              "updatedAt": "2021-03-03T07:28:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAyNTkwODM4",
          "commit": {
            "abbreviatedOid": "f96b194"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-03T07:36:53Z",
          "updatedAt": "2021-03-03T07:36:53Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "OK",
              "createdAt": "2021-03-03T07:36:53Z",
              "updatedAt": "2021-03-03T07:36:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAyNTkxMDY3",
          "commit": {
            "abbreviatedOid": "f96b194"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-03T07:37:15Z",
          "updatedAt": "2021-03-03T07:37:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 50,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg0MzkxNTQ0",
      "title": "add changelog since 02",
      "url": "https://github.com/NTAP/rfc8312bis/pull/50",
      "state": "MERGED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Changelog for https://github.com/NTAP/rfc8312bis/pull/49",
      "createdAt": "2021-03-04T00:27:58Z",
      "updatedAt": "2021-03-04T07:17:22Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "4b54c398434574cb2bc9d18d4e6629c4c9e099f9",
      "headRepository": "goelvidhi/rfc8312bis",
      "headRefName": "definition-changelog",
      "headRefOid": "6a30b7bccacb3494e3bcae8678df9afc3bbeb584",
      "closedAt": "2021-03-04T07:17:22Z",
      "mergedAt": "2021-03-04T07:17:22Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "8634242a416bca6d3de1e3e704f104b4fa1e4717"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAzNzcwMTk0",
          "commit": {
            "abbreviatedOid": "6a30b7b"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-04T07:17:05Z",
          "updatedAt": "2021-03-04T07:17:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 52,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg2Mjk3Mzcy",
      "title": "fix a mistake of W_max as described in Issue 51 ",
      "url": "https://github.com/NTAP/rfc8312bis/pull/52",
      "state": "MERGED",
      "author": "lisongxu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "fix a mistake of W_max as described in Issue 51 \r\nhttps://github.com/NTAP/rfc8312bis/issues/51",
      "createdAt": "2021-03-07T17:56:11Z",
      "updatedAt": "2021-03-08T16:21:48Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "8634242a416bca6d3de1e3e704f104b4fa1e4717",
      "headRepository": "lisongxu/rfc8312bis",
      "headRefName": "main",
      "headRefOid": "3bcc1c373f1bfa435cd9fce5b8096c1a79248715",
      "closedAt": "2021-03-08T16:21:47Z",
      "mergedAt": "2021-03-08T16:21:47Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "77c2b9217f0f6b14bcdb9f4c001d45ab0d9613d3"
      },
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "<img width=\"984\" alt=\"Screen Shot 2021-03-07 at 2 53 46 PM\" src=\"https://user-images.githubusercontent.com/10913828/110257930-f6d3fb00-7f54-11eb-9c6c-3df21c59660a.png\">\r\nI am not sure why, but in the converted html, `fast convergence is enabled` looks like a single word and the text is going out of bounds. @larseggert any way to fix that?",
          "createdAt": "2021-03-07T22:55:22Z",
          "updatedAt": "2021-03-07T22:55:22Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "The text needs to be put in `\\text`. But I am not sure if it would wrap, since it's in SVG. Can we shorten the text?",
          "createdAt": "2021-03-08T06:15:17Z",
          "updatedAt": "2021-03-08T06:15:17Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "You also need to add a bullet to the changelog.",
          "createdAt": "2021-03-08T14:50:58Z",
          "updatedAt": "2021-03-08T14:50:58Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA1OTQwNjgx",
          "commit": {
            "abbreviatedOid": "1386ef9"
          },
          "author": "Injongrhee",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-08T03:20:30Z",
          "updatedAt": "2021-03-08T03:20:30Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA2MDYzNTk2",
          "commit": {
            "abbreviatedOid": "1386ef9"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-03-08T08:38:43Z",
          "updatedAt": "2021-03-08T08:38:51Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\n& \\text{if } (cwnd < W_{max}) \\text{and fast convergence is enabled, further reduce } W_{max} \\\\\r\n```\r\nCan we shorten the text inside `\\text`?",
              "createdAt": "2021-03-08T08:38:43Z",
              "updatedAt": "2021-03-08T16:18:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA2MzcwMTg1",
          "commit": {
            "abbreviatedOid": "652a834"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-03-08T14:49:27Z",
          "updatedAt": "2021-03-08T14:49:32Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\n& \\text{if} cwnd < W_{max} \\text{ and fast convergence is enabled,} \\\\\r\n& \\text{further reduce } W_{max} \\\\\r\n```\r\nI think it might look better without the brackets? Also, you probably want a space before \"and\".",
              "createdAt": "2021-03-08T14:49:27Z",
              "updatedAt": "2021-03-08T16:18:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA2NDU1Mjkz",
          "commit": {
            "abbreviatedOid": "5f1f1bf"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-08T16:11:20Z",
          "updatedAt": "2021-03-08T16:11:20Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n& \\text{if } cwnd < W_{max} \\text{ and fast convergence is enabled},\\\\\r\n```\r\nI inadvertently changed this earlier, sorry.",
              "createdAt": "2021-03-08T16:11:20Z",
              "updatedAt": "2021-03-08T16:18:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA2NDYwMjYw",
          "commit": {
            "abbreviatedOid": "a5a25df"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-08T16:16:15Z",
          "updatedAt": "2021-03-08T16:16:16Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\n- fix a mistake in *W<sub>max</sub>* calculation in the fast convergence section.\r\n  ([#51](https://github.com/NTAP/rfc8312bis/issues/51))\r\n```",
              "createdAt": "2021-03-08T16:16:15Z",
              "updatedAt": "2021-03-08T16:18:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA2NDYyMTgz",
          "commit": {
            "abbreviatedOid": "c48dd2f"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-08T16:18:09Z",
          "updatedAt": "2021-03-08T16:18:10Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\n  ([#51](https://github.com/NTAP/rfc8312bis/issues/51))\r\n  \r\n```",
              "createdAt": "2021-03-08T16:18:09Z",
              "updatedAt": "2021-03-08T16:18:14Z"
            }
          ]
        }
      ]
    },
    {
      "number": 54,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg3OTgyODc5",
      "title": "Mult decrease bound",
      "url": "https://github.com/NTAP/rfc8312bis/pull/54",
      "state": "MERGED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Hope this should remove any ambiguity we had in how cwnd_start is set during multiplicative decrease.\r\n\r\nAlso, updated some minor things in change log.",
      "createdAt": "2021-03-09T13:32:26Z",
      "updatedAt": "2021-03-11T07:54:39Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "77c2b9217f0f6b14bcdb9f4c001d45ab0d9613d3",
      "headRepository": "goelvidhi/rfc8312bis",
      "headRefName": "mult-decrease-bound",
      "headRefOid": "e708686b769eb315d4edd07bd2c80063369a4e62",
      "closedAt": "2021-03-11T07:54:39Z",
      "mergedAt": "2021-03-11T07:54:38Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "de1e573d0d7816d32b24e6313a41ed579fd784aa"
      },
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert not sure why the last commit failed the checks. The change was ssthresh to *ssthresh* in the change log",
          "createdAt": "2021-03-09T14:09:17Z",
          "updatedAt": "2021-03-09T14:09:17Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "`draft-eggert-tcpm-rfc8312bis.md:996:81 MD013/line-length Line length [Expected: 80; Actual: 90]`",
          "createdAt": "2021-03-09T14:34:50Z",
          "updatedAt": "2021-03-09T14:34:50Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> draft-eggert-tcpm-rfc8312bis.md:996:81 MD013/line-length Line length [Expected: 80; Actual: 90]\r\n\r\nmy bad. Fixed.",
          "createdAt": "2021-03-09T14:46:31Z",
          "updatedAt": "2021-03-09T14:46:31Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "How about changing \"*cwnd<sub>start</sub>* is calculated as described in {{mult-dec}} when a congestion event is detected.\" to \"\"*cwnd<sub>start</sub>* is the new *cwnd* calculated when a congestion event is detected as described in {{mult-dec}}.\"? ",
          "createdAt": "2021-03-09T14:48:36Z",
          "updatedAt": "2021-03-09T14:48:36Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> How about changing \"cwndstart is calculated as described in {{mult-dec}} when a congestion event is detected.\" to \"\"cwndstart is the new cwnd calculated when a congestion event is detected as described in {{mult-dec}}.\"?\r\n\r\nI updated the text.\r\nAlso, I removed the below redundant line. We already describe cwnd_start in variable definition.\r\n\r\n> where *cwnd<sub>start</sub>* is the congestion window at the beginning\r\n of the current congestion avoidance stage.\r\n\r\n I also updated the Multiplicative Decrease section to call the reduced window as cwnd_start. \r\n<img width=\"487\" alt=\"Screen Shot 2021-03-10 at 7 15 38 PM\" src=\"https://user-images.githubusercontent.com/10913828/110730285-0c575800-81d5-11eb-92c3-125f443edf50.png\">\r\n\r\n\r\n Let me know if these updates are ok.",
          "createdAt": "2021-03-11T03:14:58Z",
          "updatedAt": "2021-03-11T03:16:05Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> line 472: change \"where _cwndstart_ is the new congestion window calculated when a congestion event is detected as described in {{mult-dec}}\" to \"where _cwndstart_ is the new _cwnd_ calculated when the previous congestion event was detected as described in {{mult-dec}}\" ?\r\n\r\nPrevious could mean previous to the last congestion event. Should we say ..when the last congestion event was detected ...?\r\n> \r\n> line 631: \"cwnd_{start} = ssthresh \" should be \"cwnd = ssthresh \".\r\n> \r\n> Thanks\r\n\r\nI changed it to cwnd_{start} for clarity. Could you tell why do you think \"cwnd = ssthresh \" is better?\r\n",
          "createdAt": "2021-03-11T03:46:13Z",
          "updatedAt": "2021-03-11T03:46:13Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, Vidhi. This is because cwnd is the one used everywhere. If line 631 is \"cwnd_{start} = ssthresh \", then variable cwnd is not defined.",
          "createdAt": "2021-03-11T04:24:46Z",
          "updatedAt": "2021-03-11T04:24:46Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "for cwnd_start at line 472, I still like the definition that we discussed before. that is  \"where cwnd_start is the cwnd at the very beginning of the current congestion avoidance stage\".  This covers all possible cases. \r\n   * loss event, congestion avoidance\r\n   * TCP starts, slow start, congestion avoidance\r\n   * timeout, slow start, congestion avoidance\r\n\r\nHow do you think? Thanks",
          "createdAt": "2021-03-11T04:32:10Z",
          "updatedAt": "2021-03-11T04:32:10Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "ok. I will revert the change on line 631.\r\n\r\nFor line 472, how about the below text?\r\nwhere *cwnd<sub>start</sub>* is the congestion window at the beginning\r\nof the current congestion avoidance stage. When a congestion event is\r\ndetected, *cwnd<sub>start</sub>* is set to the new (or reduced?) cwnd calculated as described in {{mult-dec}}.",
          "createdAt": "2021-03-11T04:54:34Z",
          "updatedAt": "2021-03-11T05:01:04Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "I added \"for example\" so that a reader knows this is only one of many possible cases.\r\n\r\nwhere cwndstart is the congestion window at the beginning of the current congestion avoidance stage. For example, right after a congestion event, cwndstart is equal to the new cwnd calculated as described in {{mult-dec}}.",
          "createdAt": "2021-03-11T05:03:41Z",
          "updatedAt": "2021-03-11T05:03:41Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> I added \"for example\" so that a reader knows this is only one of many possible cases.\r\n> \r\n> where cwndstart is the congestion window at the beginning of the current congestion avoidance stage. For example, right after a congestion event, cwndstart is equal to the new cwnd calculated as described in {{mult-dec}}.\r\n\r\nsounds good. Updated.",
          "createdAt": "2021-03-11T05:07:30Z",
          "updatedAt": "2021-03-11T05:07:30Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> for cwnd_start at line 472, I still like the definition that we discussed before. that is \"where cwnd_start is the cwnd at the very beginning of the current congestion avoidance stage\". This covers all possible cases.\r\n> \r\n> * loss event, congestion avoidance\r\n> * TCP starts, slow start, congestion avoidance\r\n> * timeout, slow start, congestion avoidance\r\n\r\nThe other scenarios where we go from slow start to CA without loss have some caveats which are not mentioned in the draft.\r\nFor example, K should be 0 and W_max should be set to cwnd. Do you think we should add some text?\r\n\r\n",
          "createdAt": "2021-03-11T05:15:54Z",
          "updatedAt": "2021-03-11T05:15:54Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> The other scenarios where we go from slow start to CA without loss have some caveats which are not mentioned in the draft.\r\n> For example, K should be 0 and W_max should be set to cwnd. Do you think we should add some text?\r\n\r\n\r\nThat case is discussed in Section 4.10 \"slow start\"?\r\n\r\n\"When CUBIC uses hybrid slow start [HR08], it may exit the first slow start without incurring any packet loss and thus Wmax is undefined. In this special case, CUBIC switches to congestion avoidance and increases its congestion window size using Figure 1, where t is the elapsed time since the beginning of the current congestion avoidance, K is set to 0, and Wmax is set to the congestion window size at the beginning of the current congestion avoidance stage.\"",
          "createdAt": "2021-03-11T05:23:49Z",
          "updatedAt": "2021-03-11T05:23:49Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> > The other scenarios where we go from slow start to CA without loss have some caveats which are not mentioned in the draft.\r\n> > For example, K should be 0 and W_max should be set to cwnd. Do you think we should add some text?\r\n> \r\n> That case is discussed in Section 4.10 \"slow start\"?\r\n> \r\n> \"When CUBIC uses hybrid slow start [HR08], it may exit the first slow start without incurring any packet loss and thus Wmax is undefined. In this special case, CUBIC switches to congestion avoidance and increases its congestion window size using Figure 1, where t is the elapsed time since the beginning of the current congestion avoidance, K is set to 0, and Wmax is set to the congestion window size at the beginning of the current congestion avoidance stage.\"\r\n\r\nAh.. got it. Looks good.",
          "createdAt": "2021-03-11T07:52:16Z",
          "updatedAt": "2021-03-11T07:52:16Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert this PR is ready to merge.",
          "createdAt": "2021-03-11T07:52:33Z",
          "updatedAt": "2021-03-11T07:52:33Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA3NDEzNzQ1",
          "commit": {
            "abbreviatedOid": "9a9cb90"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-03-09T13:38:50Z",
          "updatedAt": "2021-03-09T13:39:55Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nimplementation MAY set a smaller *ssthresh* than suggested below to\r\n```",
              "createdAt": "2021-03-09T13:38:50Z",
              "updatedAt": "2021-03-11T05:06:46Z"
            },
            {
              "originalPosition": 24,
              "body": "```suggestion\r\nwindow to its new reduced *ssthresh* value. The parameter {{{\u03b2}{}}}*<sub>cubic</sub>*\r\n```",
              "createdAt": "2021-03-09T13:39:06Z",
              "updatedAt": "2021-03-11T05:06:46Z"
            },
            {
              "originalPosition": 38,
              "body": "```suggestion\r\n- clarity on setting *ssthresh* and *cwnd<sub>start</sub>* during multiplicative decrease.\r\n```",
              "createdAt": "2021-03-09T13:39:24Z",
              "updatedAt": "2021-03-11T05:06:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA3NDg4Mzg0",
          "commit": {
            "abbreviatedOid": "257faba"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-09T14:45:59Z",
          "updatedAt": "2021-03-09T14:45:59Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA3NDkyNDUx",
          "commit": {
            "abbreviatedOid": "257faba"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "How about changing \"cwndstart is calculated as described in {{mult-dec}} when a congestion event is detected.\" to \"\"cwndstart is the new cwnd calculated when a congestion event is detected as described in {{mult-dec}}.\"?",
          "createdAt": "2021-03-09T14:49:22Z",
          "updatedAt": "2021-03-09T14:49:22Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA5MzY4MjA3",
          "commit": {
            "abbreviatedOid": "37a8545"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "line 472: change \"where *cwnd<sub>start</sub>* is the new congestion window calculated when a congestion event is detected as described in {{mult-dec}}\" to \"where *cwnd<sub>start</sub>* is the new *cwnd* calculated when the previous congestion event was detected as described in {{mult-dec}}\" ?\r\n\r\nline 631: \"cwnd_{start} = ssthresh \" should be \"cwnd = ssthresh \". \r\n\r\nThanks\r\n\r\n",
          "createdAt": "2021-03-11T03:32:54Z",
          "updatedAt": "2021-03-11T03:32:54Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA5NDAzODQy",
          "commit": {
            "abbreviatedOid": "e708686"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you, Vidhi!",
          "createdAt": "2021-03-11T05:24:36Z",
          "updatedAt": "2021-03-11T05:24:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 56,
      "id": "MDExOlB1bGxSZXF1ZXN0NTkxNzUzNjU3",
      "title": "Reflect WG adoption",
      "url": "https://github.com/NTAP/rfc8312bis/pull/56",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-03-12T15:04:48Z",
      "updatedAt": "2021-03-15T14:56:41Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "32b68e5968c31d2b5709b07c88e88baa87992ba8",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "switch-to-draft-ietf",
      "headRefOid": "4af5fdef47ea1bffd24b22de04d1514ea890e44d",
      "closedAt": "2021-03-15T14:56:38Z",
      "mergedAt": "2021-03-15T14:56:38Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "713ceb80f5d08ffcdd1e5dd3606df7ec91093ad7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjExOTE4MDQ1",
          "commit": {
            "abbreviatedOid": "4af5fde"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-15T08:16:24Z",
          "updatedAt": "2021-03-15T08:16:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 58,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE4ODA3Mjk2",
      "title": "issue #55",
      "url": "https://github.com/NTAP/rfc8312bis/pull/58",
      "state": "MERGED",
      "author": "lisongxu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/NTAP/rfc8312bis/issues/55",
      "createdAt": "2021-04-20T00:53:42Z",
      "updatedAt": "2021-04-21T08:47:15Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "bbfb3845f4914e1dd10414f74b865395b1b726a8",
      "headRepository": "lisongxu/rfc8312bis",
      "headRefName": "main",
      "headRefOid": "6c056ea8a6772a51d8321a0e0ec43ea9a2192e91",
      "closedAt": "2021-04-21T08:47:15Z",
      "mergedAt": "2021-04-21T08:47:15Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "935cfb52da7aa42baf6acc16421b44568bf1597a"
      },
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @lisongxu for the change.\r\nCould you add the change log?",
          "createdAt": "2021-04-20T06:31:53Z",
          "updatedAt": "2021-04-20T06:31:53Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "> Thanks @lisongxu for the change.\r\n> Could you add the change log?\r\n\r\nDone, thanks",
          "createdAt": "2021-04-20T14:02:08Z",
          "updatedAt": "2021-04-20T14:02:08Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQwMDE1NjQy",
          "commit": {
            "abbreviatedOid": "6c056ea"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-20T14:21:24Z",
          "updatedAt": "2021-04-20T14:21:24Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQwMjMyNjE4",
          "commit": {
            "abbreviatedOid": "6c056ea"
          },
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-20T17:19:46Z",
          "updatedAt": "2021-04-20T17:19:46Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQwMzM4Mzc0",
          "commit": {
            "abbreviatedOid": "6c056ea"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-20T19:16:59Z",
          "updatedAt": "2021-04-20T19:16:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 60,
      "id": "MDExOlB1bGxSZXF1ZXN0NjMwNDA4NjYx",
      "title": "Adress Martin Scharf's comments",
      "url": "https://github.com/NTAP/rfc8312bis/pull/60",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-05-05T08:47:03Z",
      "updatedAt": "2021-05-05T18:23:01Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "63cc35310a266b56461df68dc0f47b436b44339f",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "comments-martin-scharf",
      "headRefOid": "55d97fedbff64c8cb07366f7390f212a889afe65",
      "closedAt": "2021-05-05T18:22:58Z",
      "mergedAt": "2021-05-05T18:22:58Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "44f32f27593e594fcd8a0194fedde5e56942b2e2"
      },
      "comments": [
        {
          "author": "michael-scharf",
          "authorAssociation": "NONE",
          "body": "This works for me. Thanks.",
          "createdAt": "2021-05-05T09:01:39Z",
          "updatedAt": "2021-05-05T09:01:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUyMzY2OTM3",
          "commit": {
            "abbreviatedOid": "55d97fe"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you!",
          "createdAt": "2021-05-05T14:20:22Z",
          "updatedAt": "2021-05-05T14:20:22Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUyNTU2MDIw",
          "commit": {
            "abbreviatedOid": "55d97fe"
          },
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Changes look great to me. Thanks, @larseggert!",
          "createdAt": "2021-05-05T17:12:29Z",
          "updatedAt": "2021-05-05T17:12:29Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUyNTU2Mjc4",
          "commit": {
            "abbreviatedOid": "55d97fe"
          },
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Changes look great to me. Thanks, @larseggert!",
          "createdAt": "2021-05-05T17:12:46Z",
          "updatedAt": "2021-05-05T17:12:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 72,
      "id": "MDExOlB1bGxSZXF1ZXN0NjYwNzkzNTM0",
      "title": "add applicability to QUIC, SCTP",
      "url": "https://github.com/NTAP/rfc8312bis/pull/72",
      "state": "MERGED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #61 ",
      "createdAt": "2021-06-03T10:36:57Z",
      "updatedAt": "2021-06-08T06:34:52Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "44f32f27593e594fcd8a0194fedde5e56942b2e2",
      "headRepository": "goelvidhi/rfc8312bis",
      "headRefName": "add-protocols",
      "headRefOid": "5aa941eec7cb26972da5aedc974a1c3a099cad3f",
      "closedAt": "2021-06-08T06:34:52Z",
      "mergedAt": "2021-06-08T06:34:52Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "07f8f5a0f8501e72b33fc9517ea9ccf0213f1e68"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc1MTQ1NjIz",
          "commit": {
            "abbreviatedOid": "f3a90e1"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-06-03T10:54:20Z",
          "updatedAt": "2021-06-03T10:54:26Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "We need to add informative references to RFC9000 for QUIC and RFC4960 for SCTP.",
              "createdAt": "2021-06-03T10:54:20Z",
              "updatedAt": "2021-06-03T10:54:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc1MTUyMzQ1",
          "commit": {
            "abbreviatedOid": "f3a90e1"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-03T11:02:45Z",
          "updatedAt": "2021-06-03T11:02:45Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nQUIC {{?RFC9000}} and SCTP {{?RFC4960}} as a default congestion controller.\r\n```",
              "createdAt": "2021-06-03T11:02:45Z",
              "updatedAt": "2021-06-03T11:02:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3MDM0MDEx",
          "commit": {
            "abbreviatedOid": "5aa941e"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-07T06:38:16Z",
          "updatedAt": "2021-06-07T06:38:16Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc4MDM4MzUz",
          "commit": {
            "abbreviatedOid": "5aa941e"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks",
          "createdAt": "2021-06-08T02:42:31Z",
          "updatedAt": "2021-06-08T02:42:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 73,
      "id": "MDExOlB1bGxSZXF1ZXN0NjYwODA4NjA1",
      "title": "Instruct RFC Editor to change \"Figure\" to \"Equation\"",
      "url": "https://github.com/NTAP/rfc8312bis/pull/73",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": " Fixes #63.",
      "createdAt": "2021-06-03T11:00:48Z",
      "updatedAt": "2021-06-07T06:38:30Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "44f32f27593e594fcd8a0194fedde5e56942b2e2",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "eq-not-fig",
      "headRefOid": "ba9629e0261c0704f9e45cfd526534344193710e",
      "closedAt": "2021-06-05T14:27:23Z",
      "mergedAt": "2021-06-05T14:27:23Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "87bbf908a61ee54af1541f0a1e4a5ac678de3613"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2NzM4MDE2",
          "commit": {
            "abbreviatedOid": "ba9629e"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-05T01:31:20Z",
          "updatedAt": "2021-06-05T01:31:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 74,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY2NjM5Nzk3",
      "title": "add clarity on setting alpha_aimd to 1",
      "url": "https://github.com/NTAP/rfc8312bis/pull/74",
      "state": "MERGED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #68 ",
      "createdAt": "2021-06-10T08:16:18Z",
      "updatedAt": "2021-06-10T15:28:52Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "07f8f5a0f8501e72b33fc9517ea9ccf0213f1e68",
      "headRepository": "goelvidhi/rfc8312bis",
      "headRefName": "aimd-friendly",
      "headRefOid": "9bfb4f300c2b2a8eb1c3937827bf923fcf0c4fb4",
      "closedAt": "2021-06-10T15:28:52Z",
      "mergedAt": "2021-06-10T15:28:51Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "f6a00afafb1eab3b4ce9b5fb0d72845153d1a095"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgwNTE2NzI3",
          "commit": {
            "abbreviatedOid": "3b42a6a"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-10T08:50:09Z",
          "updatedAt": "2021-06-10T08:50:10Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n*W<sub>est</sub>* >= *W<sub>max</sub>*, CUBIC needs to start probing to\r\n```",
              "createdAt": "2021-06-10T08:50:09Z",
              "updatedAt": "2021-06-10T08:50:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgwNTI4MzIz",
          "commit": {
            "abbreviatedOid": "9bfb4f3"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-10T09:00:57Z",
          "updatedAt": "2021-06-10T09:00:57Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgwNzc3ODU5",
          "commit": {
            "abbreviatedOid": "9bfb4f3"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks",
          "createdAt": "2021-06-10T13:23:57Z",
          "updatedAt": "2021-06-10T13:23:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 75,
      "id": "MDExOlB1bGxSZXF1ZXN0NjcwMTkyNTIy",
      "title": "clarify alpha and add alpha_cubic",
      "url": "https://github.com/NTAP/rfc8312bis/pull/75",
      "state": "MERGED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #64 \r\n\r\nAs this PR includes changes to formulas in Section 4.3, reviewing the HTML version would be easier. You can download it from Editor's copy under Checks tab.\r\n",
      "createdAt": "2021-06-15T08:34:05Z",
      "updatedAt": "2021-06-16T06:38:43Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "f6a00afafb1eab3b4ce9b5fb0d72845153d1a095",
      "headRepository": "goelvidhi/rfc8312bis",
      "headRefName": "alpha-aimd",
      "headRefOid": "f7b3079ad4ddeb0314db8306296e5a822b493545",
      "closedAt": "2021-06-16T06:38:43Z",
      "mergedAt": "2021-06-16T06:38:43Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "2660495987ec2472118d83c42083ed16767fe0fd"
      },
      "comments": [
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@chromi you can download the build artifacts here, which include the formatted versions: https://github.com/NTAP/rfc8312bis/suites/2996841176/artifacts/67729624",
          "createdAt": "2021-06-15T10:14:06Z",
          "updatedAt": "2021-06-15T10:14:06Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for this revision! It is very clear and I really like it.",
          "createdAt": "2021-06-16T02:37:09Z",
          "updatedAt": "2021-06-16T02:37:09Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "looks very good to me.",
          "createdAt": "2021-06-16T05:41:39Z",
          "updatedAt": "2021-06-16T05:41:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNzg2MzIz",
          "commit": {
            "abbreviatedOid": "f7b3079"
          },
          "author": "chromi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "This looks like it could be a significant improvement.  I look forward to seeing the formatted version.",
          "createdAt": "2021-06-15T09:40:27Z",
          "updatedAt": "2021-06-15T09:40:27Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0NjY3OTI2",
          "commit": {
            "abbreviatedOid": "f7b3079"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you!",
          "createdAt": "2021-06-16T02:35:26Z",
          "updatedAt": "2021-06-16T02:35:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 76,
      "id": "MDExOlB1bGxSZXF1ZXN0Njc0MDA0NzYz",
      "title": "clarify cwnd growth in convex region",
      "url": "https://github.com/NTAP/rfc8312bis/pull/76",
      "state": "MERGED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #69 ",
      "createdAt": "2021-06-20T09:40:17Z",
      "updatedAt": "2021-06-22T07:20:03Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "2660495987ec2472118d83c42083ed16767fe0fd",
      "headRepository": "goelvidhi/rfc8312bis",
      "headRefName": "convex-growth",
      "headRefOid": "9e65823ad80e6856f90ba7ad5a349fd300bb476f",
      "closedAt": "2021-06-22T07:20:03Z",
      "mergedAt": "2021-06-22T07:20:03Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "594ebe73d2b0ee0fc99f8912ef56c6b763655013"
      },
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> \"Unless it is not overridden by AIMD window increase, CUBIC is very careful in this region\" should be \"Unless it is overridden by AIMD window increase, CUBIC is very careful in this region\"? Thank you\r\n\r\ndone",
          "createdAt": "2021-06-21T21:47:39Z",
          "updatedAt": "2021-06-21T21:47:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg3OTc3OTI1",
          "commit": {
            "abbreviatedOid": "fe7455d"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "\"Unless it is not overridden by AIMD window increase, CUBIC is very careful in this region\" should be \"Unless it is overridden by AIMD window increase, CUBIC is very careful in this region\"? Thank you",
          "createdAt": "2021-06-21T02:03:56Z",
          "updatedAt": "2021-06-21T02:03:56Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg4NjYxODg3",
          "commit": {
            "abbreviatedOid": "fe7455d"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-06-21T16:48:58Z",
          "updatedAt": "2021-06-21T16:50:16Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\ncareful in this region. The convex profile aims to\r\nincrease the window very slowly at the beginning when *cwnd* is\r\n```",
              "createdAt": "2021-06-21T16:48:58Z",
              "updatedAt": "2021-06-21T16:50:16Z"
            },
            {
              "originalPosition": 12,
              "body": "```suggestion\r\naround *W<sub>max</sub>* and then gradually increases its rate of increase.\r\n```",
              "createdAt": "2021-06-21T16:49:46Z",
              "updatedAt": "2021-06-21T16:50:16Z"
            },
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nUnless it is not overridden by the AIMD window increase, CUBIC is very\r\n```",
              "createdAt": "2021-06-21T16:49:57Z",
              "updatedAt": "2021-06-21T16:50:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg4ODg4NjI3",
          "commit": {
            "abbreviatedOid": "9e65823"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2021-06-21T21:48:59Z",
          "updatedAt": "2021-06-21T21:48:59Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg4OTA0MDAz",
          "commit": {
            "abbreviatedOid": "9e65823"
          },
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-21T22:16:41Z",
          "updatedAt": "2021-06-21T22:16:41Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg5MTQzNjUx",
          "commit": {
            "abbreviatedOid": "9e65823"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-22T07:19:44Z",
          "updatedAt": "2021-06-22T07:19:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 77,
      "id": "MDExOlB1bGxSZXF1ZXN0Njc1MjMyOTk2",
      "title": "add guidance for bytes acked and clarification for segments_acked",
      "url": "https://github.com/NTAP/rfc8312bis/pull/77",
      "state": "MERGED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #67 ",
      "createdAt": "2021-06-22T09:13:22Z",
      "updatedAt": "2021-07-15T09:52:39Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "594ebe73d2b0ee0fc99f8912ef56c6b763655013",
      "headRepository": "goelvidhi/rfc8312bis",
      "headRefName": "segment-or-bytes-acked",
      "headRefOid": "5007ba20def81db1349ae779c507c246c78062c3",
      "closedAt": "2021-07-15T09:52:39Z",
      "mergedAt": "2021-07-15T09:52:38Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "cacc8eae334964b2792033aed298533c432967a5"
      },
      "comments": [
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "See my comment in the review - is this always a decimal or only when <1?",
          "createdAt": "2021-06-22T16:52:52Z",
          "updatedAt": "2021-06-22T16:52:52Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> See my comment in the review - is this always a decimal or only when <1?\r\n\r\nIt is decimal always. Although most implementations don't do decimal computations and simply wait for one full congestion window to be acknowledged before incrementing the cwnd by alpha * 1 (segment)\r\n\r\n\r\n",
          "createdAt": "2021-06-23T20:57:53Z",
          "updatedAt": "2021-06-23T20:57:53Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "I can't see Junho's and Yoshi's comment about SACK'ed bytes here.. was it deleted?",
          "createdAt": "2021-06-23T21:04:18Z",
          "updatedAt": "2021-06-23T21:04:18Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "For my sanity, I will paste it from my email,\r\nJunho said,\r\n> I think it's 1.5. Also another question - does it include SACK'd size?\r\n\r\nYoshi replied,\r\n>  think including SACKed bytes is an interesting question. I am thinking that if TCP receives SACKed packets, it means it's in recovery phase.\r\nIn my understanding, CUBIC doesn't touch the behavior in recovery phase. w_est will be initialized when TCP goes into congestion avoidance phase, which means after recovery phase has finished. So, I am thinking that we don't need to think about whether we should include SACKed bytes or not.\r\nBut, I might overlook something, please let me know if there's situations where CUBIC should handle SACKed packets.\r\n\r\n\r\nI agree with Yoshi, we don't talk about recovery phase in detail but we allow an implementation to use a recovery algorithm\r\n> For both packet loss\r\n   and congestion detection through ECN, the sender MAY employ a Fast\r\n   Recovery algorithm to gradually adjust the congestion window to its\r\n   new reduced _ssthresh_ value.",
          "createdAt": "2021-06-23T21:09:01Z",
          "updatedAt": "2021-06-23T21:09:01Z"
        },
        {
          "author": "junhochoi",
          "authorAssociation": "NONE",
          "body": "I didn't remove my comment \u2753 \r\n\r\n> For my sanity, I will paste it from my email,\r\n> Junho said,\r\n> \r\n> > I think it's 1.5. Also another question - does it include SACK'd size?\r\n> \r\n> Yoshi replied,\r\n> \r\n> > think including SACKed bytes is an interesting question. I am thinking that if TCP receives SACKed packets, it means it's in recovery phase.\r\n> > In my understanding, CUBIC doesn't touch the behavior in recovery phase. w_est will be initialized when TCP goes into congestion avoidance phase, which means after recovery phase has finished. So, I am thinking that we don't need to think about whether we should include SACKed bytes or not.\r\n> > But, I might overlook something, please let me know if there's situations where CUBIC should handle SACKed packets.\r\n> \r\n> I agree with Yoshi, we don't talk about recovery phase in detail but we allow an implementation to use a recovery algorithm\r\n> \r\n> > For both packet loss\r\n> > and congestion detection through ECN, the sender MAY employ a Fast\r\n> > Recovery algorithm to gradually adjust the congestion window to its\r\n> > new reduced _ssthresh_ value.\r\n\r\nFor example, when the sender received an ACK which doesn't move snd.una but with one SACK record (dupack) which is not enough to trigger the congestion event. Similar thing can happen with RACK's reordering threshold I think.",
          "createdAt": "2021-06-23T21:31:53Z",
          "updatedAt": "2021-06-23T21:38:50Z"
        },
        {
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "I see. yes, when we see small amount of re-ordering, you might receive SACKed packets.\r\nIn this case, I think you could include SACKed packets, but when it's ACKed accumulatively later, you will need to make sure you won't double count them.",
          "createdAt": "2021-06-23T22:15:09Z",
          "updatedAt": "2021-06-23T22:15:09Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Aren't SACK'ed segments (before congestion event) covered in SACK RFC6675?\r\nI would personally refrain from adding any SACK related details to Cubic or any specific congestion control spec.",
          "createdAt": "2021-06-23T22:38:00Z",
          "updatedAt": "2021-06-23T22:38:00Z"
        },
        {
          "author": "junhochoi",
          "authorAssociation": "NONE",
          "body": "@goelvidhi @nsdyoshi thanks for insights!\r\n\r\nI asked about this because segments_acked is defined as \"acked size in segment(or bytes)\" and \"acked\" doesn't only means moving snd.una with SACK. Also QUIC RFC9002 \"acked packet\" always includes SACK'ed ones. So I thought the implementer might be confused what to use.\r\n\r\nAfter thinking a little more.. SACK is optional as far as I understand, I think it might be good to leave as is.",
          "createdAt": "2021-06-23T22:57:20Z",
          "updatedAt": "2021-06-23T22:57:20Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "The comments didn't get deleted, they are inside my PR review. Yes, this is confusing.",
          "createdAt": "2021-06-24T08:06:30Z",
          "updatedAt": "2021-06-24T08:06:30Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Should we make it clearer that this is always decimal, but stacks can be approximate in their math?",
          "createdAt": "2021-06-24T08:07:10Z",
          "updatedAt": "2021-06-24T08:07:10Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert, how does this look,\r\n\r\nNumber of MSS-sized segments acked when an ACK is received. This\r\n number is a decimal and it can be less than 1 when an ACK acknowledges a\r\n segment smaller than the MSS.",
          "createdAt": "2021-06-24T08:43:24Z",
          "updatedAt": "2021-06-24T08:43:59Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "I'd maybe say \"...is a decimal and can therefore take on non-integer values when an ACK acknowledges data that is not MSS-sized. Specifically, it can be less than 1 when an ACK acknowledges a segment smaller than the MSS...\" or something like that?",
          "createdAt": "2021-06-24T08:55:19Z",
          "updatedAt": "2021-06-24T08:55:19Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "ok, I took your suggestion and made some minor edits. Please take a look.\r\n\r\nFor some reason, the inclusive check is getting cancelled immediately after I push.",
          "createdAt": "2021-06-24T09:01:50Z",
          "updatedAt": "2021-06-24T09:01:50Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "I need to look into why, ignore for now",
          "createdAt": "2021-06-24T10:30:35Z",
          "updatedAt": "2021-06-24T10:30:35Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert, this PR is ready to go once you approve it. Not sure if we need to fix the inclusivity check before merging.",
          "createdAt": "2021-06-25T08:07:00Z",
          "updatedAt": "2021-06-25T08:07:00Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert, should we merge this PR?",
          "createdAt": "2021-07-06T21:49:15Z",
          "updatedAt": "2021-07-06T21:49:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg5MzA2Mzc4",
          "commit": {
            "abbreviatedOid": "e7cae81"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-06-22T10:00:20Z",
          "updatedAt": "2021-06-22T10:02:04Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nImplementations can use bytes to express window sizes, which would\r\n```",
              "createdAt": "2021-06-22T10:00:21Z",
              "updatedAt": "2021-06-22T10:02:04Z"
            },
            {
              "originalPosition": 18,
              "body": "What if an ACK ACKs 1.5 MSS-sized segments? Is it 1 or 1.5 then?\r\n```suggestion\r\nNumber of MSS-sized segments acked when an ACK is received. This\r\nnumber can be a decimal less than 1 when an ACK acknowledges a\r\nsegment smaller than the MSS.\r\n```",
              "createdAt": "2021-06-22T10:01:48Z",
              "updatedAt": "2021-06-22T10:02:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg5NDkyNzk5",
          "commit": {
            "abbreviatedOid": "e7cae81"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you!",
          "createdAt": "2021-06-22T13:17:20Z",
          "updatedAt": "2021-06-22T13:17:20Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjkwMzQwODEx",
          "commit": {
            "abbreviatedOid": "72ee457"
          },
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-23T08:10:11Z",
          "updatedAt": "2021-06-23T08:10:11Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjkxMDM2ODQ5",
          "commit": {
            "abbreviatedOid": "72ee457"
          },
          "author": "junhochoi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-23T18:57:00Z",
          "updatedAt": "2021-06-23T18:57:00Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I think 1.5 is allowed.\r\nAlso another question - does it include SACK'd size?",
              "createdAt": "2021-06-23T18:57:00Z",
              "updatedAt": "2021-06-23T18:57:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjkxMDkxMzM4",
          "commit": {
            "abbreviatedOid": "72ee457"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-23T20:04:35Z",
          "updatedAt": "2021-06-23T20:04:35Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "@goelvidhi?",
              "createdAt": "2021-06-23T20:04:35Z",
              "updatedAt": "2021-06-23T20:04:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjkxMTExNjc2",
          "commit": {
            "abbreviatedOid": "72ee457"
          },
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-23T20:30:16Z",
          "updatedAt": "2021-06-23T20:30:17Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I think including SACKed bytes is an interesting question. I am thinking that if TCP receives SACKed packets, it means it's in recovery phase.\r\n\r\nIn my understanding, CUBIC doesn't touch the behavior in recovery phase. w_est will be initialized when TCP goes into congestion avoidance phase, which means after recovery phase has finished. So, I am thinking that we don't need to think about whether we should include SACKed bytes or not. \r\nBut, I might overlook something, please let me know if there's situations where CUBIC should handle SACKed packets.",
              "createdAt": "2021-06-23T20:30:17Z",
              "updatedAt": "2021-06-23T20:30:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0MDM2MjQ3",
          "commit": {
            "abbreviatedOid": "1f7843e"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "\"Non-integer\" is less accurate",
          "createdAt": "2021-07-12T12:09:51Z",
          "updatedAt": "2021-07-12T12:10:28Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nnumber will be a decimal value when an ACK acknowledges an amount of data\r\n```",
              "createdAt": "2021-07-12T12:09:51Z",
              "updatedAt": "2021-07-12T12:10:29Z"
            }
          ]
        }
      ]
    },
    {
      "number": 78,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkwNjIyMDEz",
      "title": "Try a better way to use in-solidarity",
      "url": "https://github.com/NTAP/rfc8312bis/pull/78",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-15T11:11:25Z",
      "updatedAt": "2021-07-15T11:12:00Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "cacc8eae334964b2792033aed298533c432967a5",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "fix-isb",
      "headRefOid": "601b1b7bd30142f2eb73124b273fc8388e004f08",
      "closedAt": "2021-07-15T11:11:57Z",
      "mergedAt": "2021-07-15T11:11:57Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "d27e17b3712dd33496d3ecc6d486068d1b9441de"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 79,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkwNjIzMjUz",
      "title": "Test new isb config",
      "url": "https://github.com/NTAP/rfc8312bis/pull/79",
      "state": "CLOSED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-15T11:13:20Z",
      "updatedAt": "2021-07-15T11:14:04Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "d27e17b3712dd33496d3ecc6d486068d1b9441de",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "test-new-isb",
      "headRefOid": "a41b2fa9088405ffaf4079516dc81c33ccfccf96",
      "closedAt": "2021-07-15T11:13:56Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Seems to work",
          "createdAt": "2021-07-15T11:13:56Z",
          "updatedAt": "2021-07-15T11:13:56Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 80,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkwODYxMTE0",
      "title": "Issues 65 and  66: packet loss rate p, ABC and Delayed ACK",
      "url": "https://github.com/NTAP/rfc8312bis/pull/80",
      "state": "MERGED",
      "author": "lisongxu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/NTAP/rfc8312bis/issues/66\r\n",
      "createdAt": "2021-07-15T16:10:07Z",
      "updatedAt": "2021-07-21T05:39:06Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "d27e17b3712dd33496d3ecc6d486068d1b9441de",
      "headRepository": "lisongxu/rfc8312bis",
      "headRefName": "main",
      "headRefOid": "6303ce25751824dcb638ac238193c58cd6597889",
      "closedAt": "2021-07-21T05:39:06Z",
      "mergedAt": "2021-07-21T05:39:06Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "3e4e8be78499249b5763cc0752c31b047fdb52a2"
      },
      "comments": [
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@lisongxu please review the comments and update the PR? Would be good to get this done by the end of the week, so we can post a new draft on Monday.",
          "createdAt": "2021-07-20T07:36:33Z",
          "updatedAt": "2021-07-20T07:36:33Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Done. Thanks\nLisong\n\n________________________________\nFrom: Lars Eggert ***@***.***>\nSent: Tuesday, July 20, 2021 2:36 AM\nTo: NTAP/rfc8312bis ***@***.***>\nCc: Lisong Xu ***@***.***>; Mention ***@***.***>\nSubject: Re: [NTAP/rfc8312bis] Issues 65 and 66: packet loss rate p, ABC and Delayed ACK (#80)\n\nNon-NU Email\n________________________________\n\n@lisongxu<https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_lisongxu&d=DwMCaQ&c=Cu5g146wZdoqVuKpTNsYHeFX_rg6kWhlkLF8Eft-wwo&r=8GgbmpxpPRnPS9z8_jUQhw&m=6n3fsTYH-NfOFA6QrVqpjOUhFFcS8W1_X7iq8qjMAWU&s=Qi3MiXpwxPlV8omPPlGY0dlz5qYq78XfbepPQsHpBgA&e=> please review the comments and update the PR? Would be good to get this done by the end of the week, so we can post a new draft on Monday.\n\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub<https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_NTAP_rfc8312bis_pull_80-23issuecomment-2D883167871&d=DwMCaQ&c=Cu5g146wZdoqVuKpTNsYHeFX_rg6kWhlkLF8Eft-wwo&r=8GgbmpxpPRnPS9z8_jUQhw&m=6n3fsTYH-NfOFA6QrVqpjOUhFFcS8W1_X7iq8qjMAWU&s=qOA-fTXQJucf4kGuhFiYqu_BhG2cDyYmFw4xZ2CWBLw&e=>, or unsubscribe<https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_notifications_unsubscribe-2Dauth_ACPRVIIFVVIM3WD74WZBZZ3TYURQZANCNFSM5AN3VVAA&d=DwMCaQ&c=Cu5g146wZdoqVuKpTNsYHeFX_rg6kWhlkLF8Eft-wwo&r=8GgbmpxpPRnPS9z8_jUQhw&m=6n3fsTYH-NfOFA6QrVqpjOUhFFcS8W1_X7iq8qjMAWU&s=BIdg0D9d0-y5vsLPYgyg_qHfSTU-_4VB-x7_v64TFws&e=>.\n",
          "createdAt": "2021-07-21T02:51:36Z",
          "updatedAt": "2021-07-21T02:51:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA3NzEyNTQz",
          "commit": {
            "abbreviatedOid": "20abb0e"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-07-15T18:50:19Z",
          "updatedAt": "2021-07-15T18:53:41Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\n*W<sub>est</sub>* is updated using {{eq4}}. Note that this equation\r\n```",
              "createdAt": "2021-07-15T18:50:19Z",
              "updatedAt": "2021-07-15T18:53:41Z"
            },
            {
              "originalPosition": 15,
              "body": "```suggestion\r\nis for a connection where Appropriate Byte Counting (ABC) {{!RFC3465}}\r\n```",
              "createdAt": "2021-07-15T18:50:53Z",
              "updatedAt": "2021-07-15T18:53:42Z"
            },
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nis disabled. For a connection with ABC enabled, this equation SHOULD be\r\n```",
              "createdAt": "2021-07-15T18:51:10Z",
              "updatedAt": "2021-07-15T18:53:42Z"
            },
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nadjusted by using the number of acknowledged bytes instead of acknowledged\r\n```",
              "createdAt": "2021-07-15T18:51:32Z",
              "updatedAt": "2021-07-15T18:53:42Z"
            },
            {
              "originalPosition": 18,
              "body": "```suggestion\r\nsegments. Also note that this equation works for connections with\r\n```",
              "createdAt": "2021-07-15T18:51:54Z",
              "updatedAt": "2021-07-15T18:53:42Z"
            },
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nenabled or disabled Delayed ACKs {{!RFC5681}}, as\r\n```",
              "createdAt": "2021-07-15T18:52:56Z",
              "updatedAt": "2021-07-15T18:53:42Z"
            },
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nthe segments actually acknowledged by an ACK.  \r\n```",
              "createdAt": "2021-07-15T18:53:30Z",
              "updatedAt": "2021-07-15T18:53:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA4MTE1Nzg2",
          "commit": {
            "abbreviatedOid": "7f06c05"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-16T08:10:03Z",
          "updatedAt": "2021-07-16T08:10:03Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA5MDA3MTc5",
          "commit": {
            "abbreviatedOid": "7f06c05"
          },
          "author": "nsdyoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-18T09:33:43Z",
          "updatedAt": "2021-07-18T09:33:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 81,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk0MDc2ODIx",
      "title": "add RACK and QUIC loss detection",
      "url": "https://github.com/NTAP/rfc8312bis/pull/81",
      "state": "MERGED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "goelvidhi"
      ],
      "labels": [],
      "body": "closes #62 ",
      "createdAt": "2021-07-21T06:04:35Z",
      "updatedAt": "2021-07-22T07:17:46Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "3e4e8be78499249b5763cc0752c31b047fdb52a2",
      "headRepository": "goelvidhi/rfc8312bis",
      "headRefName": "loss-events",
      "headRefOid": "bad3e5310e287034cbd44ccf6f7f8ea1d99e73ff",
      "closedAt": "2021-07-22T05:22:28Z",
      "mergedAt": "2021-07-22T05:22:27Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "dbf321f223e7e58c73219623c45a8ca1421ace7c"
      },
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@lisongxu @nsdyoshi could you review? We would like to publish a new draft on Monday",
          "createdAt": "2021-07-21T19:08:00Z",
          "updatedAt": "2021-07-21T19:08:00Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Done. Thank you, Vidhi!\nLisong\n\n________________________________\nFrom: Vidhi Goel ***@***.***>\nSent: Wednesday, July 21, 2021 2:08 PM\nTo: NTAP/rfc8312bis ***@***.***>\nCc: Lisong Xu ***@***.***>; Mention ***@***.***>\nSubject: Re: [NTAP/rfc8312bis] add RACK and QUIC loss detection (#81)\n\nNon-NU Email\n________________________________\n\n@lisongxu<https://urldefense.com/v3/__https://github.com/lisongxu__;!!PvXuogZ4sRB2p-tU!Wj__opQwwXLRJ0ykrCdy4yKKYGox2BW7XmFiK3Prc4MAwr65kPX1r-et-M4$> @nsdyoshi<https://urldefense.com/v3/__https://github.com/nsdyoshi__;!!PvXuogZ4sRB2p-tU!Wj__opQwwXLRJ0ykrCdy4yKKYGox2BW7XmFiK3Prc4MAwr65kPX1m9AWL5I$> could you review? We would like to publish a new draft on Monday\n\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub<https://urldefense.com/v3/__https://github.com/NTAP/rfc8312bis/pull/81*issuecomment-884426378__;Iw!!PvXuogZ4sRB2p-tU!Wj__opQwwXLRJ0ykrCdy4yKKYGox2BW7XmFiK3Prc4MAwr65kPX1-aTvFX0$>, or unsubscribe<https://urldefense.com/v3/__https://github.com/notifications/unsubscribe-auth/ACPRVIN47D4FCL6K6Q7JGYTTY4LJZANCNFSM5AXIBVNQ__;!!PvXuogZ4sRB2p-tU!Wj__opQwwXLRJ0ykrCdy4yKKYGox2BW7XmFiK3Prc4MAwr65kPX1PD6eDQI$>.\n",
          "createdAt": "2021-07-22T02:37:29Z",
          "updatedAt": "2021-07-22T02:37:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzExMzg0ODY5",
          "commit": {
            "abbreviatedOid": "f9fb02b"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-07-21T08:22:12Z",
          "updatedAt": "2021-07-21T08:23:50Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "```suggestion\r\nECE) ACKs {{!RFC3168}}, TCP RACK {{!RFC8985}} or QUIC loss detection {{!RFC9002}},\r\n```",
              "createdAt": "2021-07-21T08:22:12Z",
              "updatedAt": "2021-07-21T08:23:50Z"
            },
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nCUBIC remembers the congestion window size at which it received the congestion\r\n```",
              "createdAt": "2021-07-21T08:22:34Z",
              "updatedAt": "2021-07-21T08:23:50Z"
            },
            {
              "originalPosition": 46,
              "body": "```suggestion\r\nDuring congestion avoidance, after a congestion event is detected\r\n```",
              "createdAt": "2021-07-21T08:23:16Z",
              "updatedAt": "2021-07-21T08:23:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzEyMDQ4ODk1",
          "commit": {
            "abbreviatedOid": "f9fb02b"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-21T19:06:52Z",
          "updatedAt": "2021-07-21T19:06:52Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I had this in the first commit and I had to remove as it failed to compile. Does 9002 have a valid reference?\r\n",
              "createdAt": "2021-07-21T19:06:52Z",
              "updatedAt": "2021-07-21T19:06:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzEyMzI0MTYz",
          "commit": {
            "abbreviatedOid": "bad3e53"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2021-07-22T02:36:41Z",
          "updatedAt": "2021-07-22T02:36:41Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzEyNDI4MDQw",
          "commit": {
            "abbreviatedOid": "bad3e53"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-22T07:17:45Z",
          "updatedAt": "2021-07-22T07:17:46Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "It should? Let me try locally.",
              "createdAt": "2021-07-22T07:17:45Z",
              "updatedAt": "2021-07-22T07:17:46Z"
            }
          ]
        }
      ]
    },
    {
      "number": 82,
      "id": "MDExOlB1bGxSZXF1ZXN0NzIxMDg3NjAy",
      "title": "Remove reference to 8312 from abstract. Describe changes in intro.",
      "url": "https://github.com/NTAP/rfc8312bis/pull/82",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-08-27T07:12:31Z",
      "updatedAt": "2021-08-27T07:16:56Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "c126c0903f8e111c13e50da1368f1761e34f1198",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "fix-abstract",
      "headRefOid": "2bf9b26dd5ff110fcfd9f025d2126e0da5e74990",
      "closedAt": "2021-08-27T07:16:40Z",
      "mergedAt": "2021-08-27T07:16:40Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "0911de2510b074771c53a14c31244650a24b0155"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQwMjA5ODE2",
          "commit": {
            "abbreviatedOid": "a9f1343"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-27T07:14:04Z",
          "updatedAt": "2021-08-27T07:14:04Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nalgorithmic improvements based on the Linux, Windows, and Apple implementations and recent\r\n```",
              "createdAt": "2021-08-27T07:14:04Z",
              "updatedAt": "2021-08-27T07:14:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQwMjA5OTMz",
          "commit": {
            "abbreviatedOid": "a9f1343"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-27T07:14:13Z",
          "updatedAt": "2021-08-27T07:14:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 103,
      "id": "MDExOlB1bGxSZXF1ZXN0NzIzMzM0MzE1",
      "title": "upon receiving an ACK -> upon receiving a new ACK",
      "url": "https://github.com/NTAP/rfc8312bis/pull/103",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This fixes #101.\r\n\r\nHowever, I only changed the one spot where the text actually said \"Upon receiving an ACK\". There are **many** more places where the text says \"an ACK\" - Markku would need to identify a bit better which ones he thinks need to be changed. So I am leaving this as a draft PR until we know we changed them all.",
      "createdAt": "2021-08-31T12:39:52Z",
      "updatedAt": "2021-09-15T17:01:50Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "b06cef3554e9d95cd0b78d46459ecb4a43bef608",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "ack-new-ack",
      "headRefOid": "ff2d3bd344cd85a39f1b2ab76ba685114cd7c1d6",
      "closedAt": "2021-09-15T14:45:51Z",
      "mergedAt": "2021-09-15T14:45:51Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "c70806f9af06ad949f0ad1b9f2149f870dd88168"
      },
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "I searched for \"receiving an ACK\" and found 4 places, all of which I think can be changed to \"receiving a new ACK\"",
          "createdAt": "2021-09-01T06:47:26Z",
          "updatedAt": "2021-09-01T06:47:26Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@goelvidhi I added those three (not four) additional cases to the PR.",
          "createdAt": "2021-09-01T12:12:31Z",
          "updatedAt": "2021-09-01T12:12:31Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@markkukojo does this PR address your issue?",
          "createdAt": "2021-09-02T12:39:16Z",
          "updatedAt": "2021-09-02T12:39:16Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "I commented this accidentally in #101 that was already closed. So, repeating here not to leave it unnoticed.\r\n\r\nI didn't pass through all the occurrences because this was a generic comment for the document to be precise. So, throughout the document any occurrence of \"an/every/each/whatever ACK\" that is intended to refer only to an ACK that cumulatively acknowledges new data would be good to indicate exactly (to not leave any doubt that the actions must not be taken on arriving dupAcks or window updates).",
          "createdAt": "2021-09-15T17:01:50Z",
          "updatedAt": "2021-09-15T17:01:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ0NjIyNTk3",
          "commit": {
            "abbreviatedOid": "ff2d3bd"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-02T05:40:12Z",
          "updatedAt": "2021-09-02T05:40:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 104,
      "id": "MDExOlB1bGxSZXF1ZXN0NzIzMzM4ODQ0",
      "title": "current standard -> currently most widely deployed standard",
      "url": "https://github.com/NTAP/rfc8312bis/pull/104",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-08-31T12:45:50Z",
      "updatedAt": "2021-09-15T14:46:19Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "b06cef3554e9d95cd0b78d46459ecb4a43bef608",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "current-standard",
      "headRefOid": "d360d2495cba49961a8ff42a1ceff8276b9213c0",
      "closedAt": "2021-09-15T14:46:16Z",
      "mergedAt": "2021-09-15T14:46:16Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "0f190cbb35da12edaaa181f2d7d03052b24b4a79"
      },
      "comments": [
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@markkukojo does this address your issue?",
          "createdAt": "2021-09-02T12:39:36Z",
          "updatedAt": "2021-09-02T12:39:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQzNTQzMzQz",
          "commit": {
            "abbreviatedOid": "d360d24"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-01T06:52:22Z",
          "updatedAt": "2021-09-07T06:15:20Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "s/ as the currently most/as currently the most ?\r\n\r\n",
              "createdAt": "2021-09-01T06:52:22Z",
              "updatedAt": "2021-09-07T06:15:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ3NTg2ODU1",
          "commit": {
            "abbreviatedOid": "d360d24"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-07T06:27:14Z",
          "updatedAt": "2021-09-07T06:27:14Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Not sure. Both sound OK to me, with a mild preference for my version, but am not a native speaker.",
              "createdAt": "2021-09-07T06:27:14Z",
              "updatedAt": "2021-09-07T06:27:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ3NTg4MjE2",
          "commit": {
            "abbreviatedOid": "d360d24"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-07T06:29:19Z",
          "updatedAt": "2021-09-07T06:29:19Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Me neither and I don't have preference either. Fine with what we have. :-)",
              "createdAt": "2021-09-07T06:29:19Z",
              "updatedAt": "2021-09-07T06:29:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ3NTg4NTQ0",
          "commit": {
            "abbreviatedOid": "d360d24"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-07T06:29:45Z",
          "updatedAt": "2021-09-07T06:29:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 105,
      "id": "MDExOlB1bGxSZXF1ZXN0NzIzMzY1NTgw",
      "title": "Update 5681.",
      "url": "https://github.com/NTAP/rfc8312bis/pull/105",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-08-31T13:16:31Z",
      "updatedAt": "2021-09-15T14:46:41Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "b06cef3554e9d95cd0b78d46459ecb4a43bef608",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "update-5681",
      "headRefOid": "c16bb18d019a597aa3fbf99276e39c2faebff184",
      "closedAt": "2021-09-15T14:46:37Z",
      "mergedAt": "2021-09-15T14:46:37Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "fb9be62d3402913cb64e8931fa24f13a54c30188"
      },
      "comments": [
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@markkukojo does this address your issue?",
          "createdAt": "2021-09-02T12:39:46Z",
          "updatedAt": "2021-09-02T12:39:46Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQzNTQ2Mjg5",
          "commit": {
            "abbreviatedOid": "3ead32f"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-01T06:56:18Z",
          "updatedAt": "2021-09-07T06:14:43Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "s/RFC 5861/RFC 5681",
              "createdAt": "2021-09-01T06:56:18Z",
              "updatedAt": "2021-09-07T06:14:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ3NTg1NTk2",
          "commit": {
            "abbreviatedOid": "3ead32f"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-07T06:25:11Z",
          "updatedAt": "2021-09-07T06:25:12Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nobsoleting RFC 8312.  This also requires updating RFC 5681, to allow\r\n```",
              "createdAt": "2021-09-07T06:25:11Z",
              "updatedAt": "2021-09-07T06:25:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ3NTg3NzY2",
          "commit": {
            "abbreviatedOid": "c16bb18"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-07T06:28:38Z",
          "updatedAt": "2021-09-07T06:28:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 107,
      "id": "MDExOlB1bGxSZXF1ZXN0NzI4MDM2NTIx",
      "title": "Fix #106",
      "url": "https://github.com/NTAP/rfc8312bis/pull/107",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-09-06T15:08:16Z",
      "updatedAt": "2021-09-07T06:24:31Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "b06cef3554e9d95cd0b78d46459ecb4a43bef608",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "fix-math",
      "headRefOid": "c1143b04466e9600df4131560bac777e3494093a",
      "closedAt": "2021-09-07T06:24:27Z",
      "mergedAt": "2021-09-07T06:24:27Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "0ec2059b176effa3781aba2bcd36c111faed448a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ3MzEwODEx",
          "commit": {
            "abbreviatedOid": "c1143b0"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks.",
          "createdAt": "2021-09-06T15:16:42Z",
          "updatedAt": "2021-09-06T15:16:42Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ3NTc4NzIx",
          "commit": {
            "abbreviatedOid": "c1143b0"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-07T06:14:10Z",
          "updatedAt": "2021-09-07T06:14:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 109,
      "id": "PR_kwDOEpK-U84ryjGa",
      "title": "AIMD -> Reno (in most places)",
      "url": "https://github.com/NTAP/rfc8312bis/pull/109",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-09-15T15:19:03Z",
      "updatedAt": "2021-09-28T07:24:52Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "bcd9022a1b1ce46d1b985db1b61f2f4bd0994b2e",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "aimd-to-reno",
      "headRefOid": "3a6a843eb365bf3efd0f6487899f9ba4315546b0",
      "closedAt": "2021-09-28T07:24:48Z",
      "mergedAt": "2021-09-28T07:24:48Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "f3db2837f6d4ab927848833fd93dff6b1be32325"
      },
      "comments": [
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "sorry that I forgot to switch from my another github account. hinterop is me. ",
          "createdAt": "2021-09-15T17:15:06Z",
          "updatedAt": "2021-09-15T17:15:06Z"
        },
        {
          "author": "bbriscoe",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My original comment and Neal's agreement with it asked for \r\nAIMD TCP -> Reno\r\nnot\r\nAIMD TCP -> Reno TCP\r\n\r\nNot only is AIMD too general, but TCP is too specific (it excludes Reno QUIC [RFC9002] for instance).\r\n\r\nThis terminology will need to be introduced differently. \r\nCurrent:\r\n```\r\n   This problem is equally\r\n   applicable to all Reno-style TCP standards and their variants,\r\n   including TCP-Reno [RFC5681], TCP-NewReno [RFC6582][RFC6675], SCTP\r\n   [RFC4960], and TFRC [RFC5348], which use the same linear increase\r\n   function for window growth.  We refer to all Reno-style TCP standards\r\n   and their variants collectively as \"AIMD TCP\" below \r\n```\r\nSuggested:\r\n```\r\n   This problem is equally\r\n   applicable to all Reno-style standards and their variants,\r\n   including TCP-Reno [RFC5681], TCP-NewReno [RFC6582][RFC6675], SCTP\r\n   [RFC4960], TFRC [RFC5348] and QUIC congestion control [RFC9002], which use the same linear increase\r\n   function for window growth.  We refer to all Reno-style standards\r\n   and their variants collectively as \"Reno\" below \r\n```\r\n(Personally, I wouldn't include New Reno, which is really different loss-recovery, not really different congestion control, but up to you...)\r\n\r\nHowever, avoid a straight find+replace, because in some cases it really should say 'Reno TCP', for instance where [RFC5681] is cited, or where it is referring to experiments that were conducted specifically with Reno TCP, as in \u00a75.1.",
          "createdAt": "2021-09-23T11:22:12Z",
          "updatedAt": "2021-09-23T11:22:12Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@bbriscoe, I think I implemented your suggestions - review the PR again, please?",
          "createdAt": "2021-09-23T14:59:15Z",
          "updatedAt": "2021-09-23T14:59:15Z"
        },
        {
          "author": "bbriscoe",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've got a number of proposed changes where find+replace isn't a good substitute for \"engage brain\". I think it's easiest if I fork from your latest changes and create another PR. Or would you really prefer a review of your PR?",
          "createdAt": "2021-09-23T18:42:40Z",
          "updatedAt": "2021-09-23T18:42:40Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@bbriscoe I saw you proposed a PR to this branch, thanks! That's a great way to incorporate these changes,",
          "createdAt": "2021-09-24T06:30:09Z",
          "updatedAt": "2021-09-24T06:30:09Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEpK-U84tBc9A",
          "commit": {
            "abbreviatedOid": "2a99c73"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-15T16:36:27Z",
          "updatedAt": "2021-09-15T16:36:27Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84tBpri",
          "commit": {
            "abbreviatedOid": "2a99c73"
          },
          "author": "hinterop",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "How about we remove \"because they use..... \" in \"We refer to all Reno-style TCP standards and their variants collectively as \"Reno TCP\" below because they use the Additive Increase and Multiplicative Decrease algorithm (AIMD).\"?",
          "createdAt": "2021-09-15T17:12:55Z",
          "updatedAt": "2021-09-15T17:12:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84taPph",
          "commit": {
            "abbreviatedOid": "2a99c73"
          },
          "author": "bbriscoe",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Suggest delete \" because they use the Additive Increase and Multiplicative Decrease algorithm (AIMD)\" (with the change to Reno TCP in the first half of the sentene, the second half is no longer a rationale for the first half).\r\nSorry ignore this - just noticed it duplicates the previous comment.",
          "createdAt": "2021-09-23T10:43:47Z",
          "updatedAt": "2021-09-23T10:44:44Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84tkVbD",
          "commit": {
            "abbreviatedOid": "dfd1873"
          },
          "author": "hinterop",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-27T16:27:55Z",
          "updatedAt": "2021-09-27T16:27:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 110,
      "id": "PR_kwDOEpK-U84r1Twx",
      "title": "Use \"new ACK\" in more places, and define it.",
      "url": "https://github.com/NTAP/rfc8312bis/pull/110",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #101.",
      "createdAt": "2021-09-16T11:40:25Z",
      "updatedAt": "2021-09-21T07:26:05Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "cfdf2a4130acb34e3ed39de082a9b1a7061523d8",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "more-new-ack",
      "headRefOid": "3526777a19190c40b86dfb27e768ae633be6dd20",
      "closedAt": "2021-09-21T07:25:58Z",
      "mergedAt": "2021-09-21T07:25:57Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "b28a2bada0c71ce665a96add557fac0c070bc1f6"
      },
      "comments": [
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "These look AOK for me, thanks. In a few places one maybe could use \"the ACK\" instead of \"a new ACK\", but I'm not a native speaker so I believe the proposed text should be clear enough as it is now.",
          "createdAt": "2021-09-17T09:19:37Z",
          "updatedAt": "2021-09-17T09:19:37Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEpK-U84tQ0cR",
          "commit": {
            "abbreviatedOid": "3526777"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-21T07:19:37Z",
          "updatedAt": "2021-09-21T07:19:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 111,
      "id": "PR_kwDOEpK-U84r1W8B",
      "title": "Rephrase text around algorithmic alternatives.",
      "url": "https://github.com/NTAP/rfc8312bis/pull/111",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #90.",
      "createdAt": "2021-09-16T11:59:26Z",
      "updatedAt": "2021-10-18T10:17:31Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "e9231bf28b4f00618a47586890e8b305e574ad05",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "downrefs",
      "headRefOid": "2363cdea378a411e3f060cc3e3c2e84b2056b238",
      "closedAt": "2021-10-18T10:17:26Z",
      "mergedAt": "2021-10-18T10:17:26Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "3932f43e13cf100c050448d658bc492d3b476adc"
      },
      "comments": [
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think we have to mandate the use of a specific slow start algorithm even though Linux CUBIC uses Hystart. In fact, HyStart++ uses one of two indicators (delay spike) of Hystart (ack train length and delay spike). Can we just say any advanced slow start algorithms can be used for CUBIC?  ",
          "createdAt": "2021-09-30T00:46:35Z",
          "updatedAt": "2021-09-30T00:46:35Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "There is only one on the standards track, and that is HyStart++, so I made that the SHOULD. Others area allowed experimentally.",
          "createdAt": "2021-09-30T09:11:05Z",
          "updatedAt": "2021-09-30T09:11:05Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Note: unless someone objects, I will merge this PR soon. If you do object, please make a concrete proposal for what would need to change.",
          "createdAt": "2021-10-11T07:27:53Z",
          "updatedAt": "2021-10-11T07:27:53Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEpK-U84tRGRM",
          "commit": {
            "abbreviatedOid": "615ddf1"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-21T08:34:38Z",
          "updatedAt": "2021-09-21T08:35:54Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Should AIMD TCP (RFC5681) only be used as a last resort? That will encourage a new implementer to always use Hystart++ unless there is some unavoidable circumstance.",
              "createdAt": "2021-09-21T08:34:38Z",
              "updatedAt": "2021-09-21T08:35:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84tRIyx",
          "commit": {
            "abbreviatedOid": "615ddf1"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-21T08:44:52Z",
          "updatedAt": "2021-09-21T08:44:52Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "That is what I tried to express with the SHOULD and MAY. I'll try to make this clearer.",
              "createdAt": "2021-09-21T08:44:52Z",
              "updatedAt": "2021-09-21T08:44:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84tRI87",
          "commit": {
            "abbreviatedOid": "615ddf1"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-21T08:45:28Z",
          "updatedAt": "2021-09-21T08:45:29Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "```suggestion\r\nslow start algorithm {{!RFC5681}} when HyStart++ is not suitable. Experimental alternatives include\r\n```",
              "createdAt": "2021-09-21T08:45:28Z",
              "updatedAt": "2021-09-21T08:45:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84tRJAL",
          "commit": {
            "abbreviatedOid": "615ddf1"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-21T08:45:40Z",
          "updatedAt": "2021-09-21T08:45:40Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "@goelvidhi how is this?",
              "createdAt": "2021-09-21T08:45:40Z",
              "updatedAt": "2021-09-21T08:45:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84tRRE_",
          "commit": {
            "abbreviatedOid": "615ddf1"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-21T09:17:23Z",
          "updatedAt": "2021-09-21T09:17:23Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "LGTM",
              "createdAt": "2021-09-21T09:17:23Z",
              "updatedAt": "2021-09-21T09:17:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84tSfwj",
          "commit": {
            "abbreviatedOid": "615ddf1"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-21T14:23:19Z",
          "updatedAt": "2021-09-21T14:23:19Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "@sangtaeha How do you think?",
              "createdAt": "2021-09-21T14:23:19Z",
              "updatedAt": "2021-09-21T14:23:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84tVJDF",
          "commit": {
            "abbreviatedOid": "18f2839"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-22T06:55:45Z",
          "updatedAt": "2021-09-22T06:55:45Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "```suggestion\r\nslow start algorithm {{!RFC5681}} when HyStart++ is not suitable.\r\nExperimental alternatives include\r\n```",
              "createdAt": "2021-09-22T06:55:45Z",
              "updatedAt": "2021-09-22T06:55:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84teC86",
          "commit": {
            "abbreviatedOid": "357081c"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-09-24T09:01:50Z",
          "updatedAt": "2021-09-24T09:02:54Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nhybrid slow start {{HR08}}, a predecessor to HyStart++ that some CUBIC\r\n```",
              "createdAt": "2021-09-24T09:01:50Z",
              "updatedAt": "2021-09-24T09:02:54Z"
            },
            {
              "originalPosition": 62,
              "body": "we should add issue #86 as well.",
              "createdAt": "2021-09-24T09:02:43Z",
              "updatedAt": "2021-09-24T09:02:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84teKsr",
          "commit": {
            "abbreviatedOid": "c920c41"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-24T09:36:58Z",
          "updatedAt": "2021-09-24T09:36:58Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "```suggestion\r\n  ([#85](https://github.com/NTAP/rfc8312bis/issues/85),\r\n   [#86](https://github.com/NTAP/rfc8312bis/issues/86),\r\n```",
              "createdAt": "2021-09-24T09:36:58Z",
              "updatedAt": "2021-09-24T09:36:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84tgZGn",
          "commit": {
            "abbreviatedOid": "2af34d1"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-24T20:51:10Z",
          "updatedAt": "2021-09-24T20:51:19Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "Nit: spacing doesn't look consistent in line # 1040 and 1041",
              "createdAt": "2021-09-24T20:51:10Z",
              "updatedAt": "2021-09-24T20:51:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84tjGic",
          "commit": {
            "abbreviatedOid": "2af34d1"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-27T11:55:34Z",
          "updatedAt": "2021-09-27T11:55:34Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "```suggestion\r\n  [#86](https://github.com/NTAP/rfc8312bis/issues/86),\r\n```",
              "createdAt": "2021-09-27T11:55:34Z",
              "updatedAt": "2021-09-27T11:55:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84to92Z",
          "commit": {
            "abbreviatedOid": "74f003e"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-28T16:55:37Z",
          "updatedAt": "2021-09-28T16:55:37Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84tu_BB",
          "commit": {
            "abbreviatedOid": "2363cde"
          },
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "W.r.t. slow start:\r\nThis text is now better than the original.\r\nHowever, is there any real reason to make CUBIC dependant of HyStart++?\r\nIsn't HyStart++ similarly useful extension to the RFC 5681 slow start?\r\nMoreover, it is now SHOULD, why is it not MUST? This begs for explaining when it might be justified to not implement HyStart++ with CUBIC. \r\nIMO, If we want to recommend HyStart++, it is better done in HyStart++ spec.\r\n \r\nAnd a nit: Reno TCP slow start algorithm does not make any sense to me. Reno is one alternative loss recovery algorithm to be applied after a Fast Retransmit. The one that first was  implemented for BSD 4.3 Reno. The predecessor was Tahoe, which applied slow start after a Fast Retransmit.  Later alternatives include NewReno and SACK-based loss recovery.",
          "createdAt": "2021-09-30T00:16:23Z",
          "updatedAt": "2021-09-30T00:16:23Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84uRbhG",
          "commit": {
            "abbreviatedOid": "2363cde"
          },
          "author": "huitema",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Seems ready.",
          "createdAt": "2021-10-11T14:42:17Z",
          "updatedAt": "2021-10-11T14:42:17Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84ujmPV",
          "commit": {
            "abbreviatedOid": "2363cde"
          },
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, thanks!\r\n",
          "createdAt": "2021-10-15T17:31:39Z",
          "updatedAt": "2021-10-15T17:31:39Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84ukkez",
          "commit": {
            "abbreviatedOid": "2363cde"
          },
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me. Thanks!",
          "createdAt": "2021-10-16T07:39:04Z",
          "updatedAt": "2021-10-16T07:39:04Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84ulKub",
          "commit": {
            "abbreviatedOid": "2363cde"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-17T22:07:27Z",
          "updatedAt": "2021-10-17T22:07:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 112,
      "id": "PR_kwDOEpK-U84r1hkh",
      "title": "Add ietf.json",
      "url": "https://github.com/NTAP/rfc8312bis/pull/112",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-09-16T12:58:00Z",
      "updatedAt": "2021-09-16T13:01:00Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "cfdf2a4130acb34e3ed39de082a9b1a7061523d8",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "reports",
      "headRefOid": "ff935046b7b38089df664cd0aa16bc128b309e17",
      "closedAt": "2021-09-16T12:58:07Z",
      "mergedAt": "2021-09-16T12:58:07Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "2e953b191f31ab36f6f22c010c76ea8d97cd2206"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 113,
      "id": "PR_kwDOEpK-U84r-MQU",
      "title": "Issue 98, Section 5.9",
      "url": "https://github.com/NTAP/rfc8312bis/pull/113",
      "state": "CLOSED",
      "author": "lisongxu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "[Issue 98](https://github.com/NTAP/rfc8312bis/issues/98)",
      "createdAt": "2021-09-20T16:09:32Z",
      "updatedAt": "2021-09-25T05:38:48Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "2e953b191f31ab36f6f22c010c76ea8d97cd2206",
      "headRepository": "lisongxu/rfc8312bis",
      "headRefName": "main",
      "headRefOid": "908c1a9690edc1c5082b492a8470d00cc1c6f5be",
      "closedAt": "2021-09-25T05:38:48Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@lisongxu, @bbriscoe suggested a resolution in #116 - does that work for you or is more needed?",
          "createdAt": "2021-09-24T06:42:13Z",
          "updatedAt": "2021-09-24T06:42:13Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> @lisongxu, @bbriscoe suggested a resolution in #116 - does that work for you or is more needed?\r\n\r\nBob's text looks better to me as it addresses two specific points - increase in capacity and decrease in capacity.",
          "createdAt": "2021-09-24T08:55:38Z",
          "updatedAt": "2021-09-24T08:55:38Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, #116 is better, and I have approved it. Thanks.",
          "createdAt": "2021-09-24T20:23:53Z",
          "updatedAt": "2021-09-24T20:23:53Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEpK-U84tRE_c",
          "commit": {
            "abbreviatedOid": "3f1badd"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-21T08:29:19Z",
          "updatedAt": "2021-09-21T08:36:28Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I don't think it still covers the difference in CUBIC increase vs AIMD, I suggested on the issue to simply remove `congestion` from this statement and only keep routing or mobility event.",
              "createdAt": "2021-09-21T08:29:19Z",
              "updatedAt": "2021-09-21T08:36:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84tShQH",
          "commit": {
            "abbreviatedOid": "908c1a9"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-21T14:27:47Z",
          "updatedAt": "2021-09-21T14:27:47Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "done. Thanks",
              "createdAt": "2021-09-21T14:27:47Z",
              "updatedAt": "2021-09-21T14:27:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84tVBWB",
          "commit": {
            "abbreviatedOid": "908c1a9"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-22T06:08:14Z",
          "updatedAt": "2021-09-22T06:08:23Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "My point was there is no change in Cubic and New Reno when there is a routing or mobility event. The MD factor only comes into picture when we have congestion or packet loss event. I am not sure what was the reason to write this section. @lisongxu could you provide some context about the purpose of this section?",
              "createdAt": "2021-09-22T06:08:15Z",
              "updatedAt": "2021-09-22T06:08:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84tZK1-",
          "commit": {
            "abbreviatedOid": "908c1a9"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-23T04:00:28Z",
          "updatedAt": "2021-09-23T04:00:28Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Hi Vidhi,  Sections 5.3-5.10 follow the guidelines of [RFC 5033 \" Specifying New Congestion Control Algorithms \"](https://datatracker.ietf.org/doc/html/rfc5033) (Section 3 - 7). Thanks",
              "createdAt": "2021-09-23T04:00:28Z",
              "updatedAt": "2021-09-23T04:00:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84tZVvK",
          "commit": {
            "abbreviatedOid": "908c1a9"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-23T06:08:29Z",
          "updatedAt": "2021-09-23T06:09:16Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nexcept using a different\r\n```",
              "createdAt": "2021-09-23T06:08:29Z",
              "updatedAt": "2021-09-23T06:09:16Z"
            },
            {
              "originalPosition": 9,
              "body": "Should we say that in the document? And cite 5033?",
              "createdAt": "2021-09-23T06:08:44Z",
              "updatedAt": "2021-09-23T06:09:16Z"
            },
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nmultiplicative decrease factor, as described in {{mult-dec}}.\r\n```",
              "createdAt": "2021-09-23T06:09:03Z",
              "updatedAt": "2021-09-23T06:09:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84tZba8",
          "commit": {
            "abbreviatedOid": "908c1a9"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-23T06:48:52Z",
          "updatedAt": "2021-09-23T06:48:52Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Thanks Lisong. When we talk about routing change or mobility event, does it indirectly imply that there could be a packet loss due to these events and we have to describe CUBIC's behavior in comparison to New Reno - if yes, then the current text is fine. These requirements are too vague IMO.\r\n\r\n@larseggert do we need to cite 5033 if we are following the guidelines or is it mandatory to follow 5033 guidelines for a new congestion control?",
              "createdAt": "2021-09-23T06:48:52Z",
              "updatedAt": "2021-09-23T06:48:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84tZp38",
          "commit": {
            "abbreviatedOid": "908c1a9"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-23T08:01:22Z",
          "updatedAt": "2021-09-23T08:01:22Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "We don't have to cite it, but it sounded like there was some confusion as to why the text was written the way it was, and saying we did so because 5033 might clear up that confusion.",
              "createdAt": "2021-09-23T08:01:22Z",
              "updatedAt": "2021-09-23T08:01:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84tbSZA",
          "commit": {
            "abbreviatedOid": "908c1a9"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-23T14:47:56Z",
          "updatedAt": "2021-09-23T14:47:57Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Yes, I guess it is better to cite RFC 5033 so that the readers know why we have these subsections.\r\n\r\nIn the special cases of \"sudden congestion, a routing change, or a mobility event, Routing changes, link disconnections, intermittent link connectivity\", there could be packet loss, minRTT changes, or bandwidth changes. ",
              "createdAt": "2021-09-23T14:47:56Z",
              "updatedAt": "2021-09-23T14:47:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 115,
      "id": "PR_kwDOEpK-U84sMeRD",
      "title": "Moved \"MUST NOT\" from app-limited section to main cubic AI section",
      "url": "https://github.com/NTAP/rfc8312bis/pull/115",
      "state": "MERGED",
      "author": "bbriscoe",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Intended to resolve NTAP/rfc8312bis/#97",
      "createdAt": "2021-09-23T14:48:30Z",
      "updatedAt": "2021-10-03T10:35:33Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "b28a2bada0c71ce665a96add557fac0c070bc1f6",
      "headRepository": "bbriscoe/rfc8312bis",
      "headRefName": "app-limited",
      "headRefOid": "dd10f479c572f25311a917ca9fc2934d4e4c8397",
      "closedAt": "2021-10-02T07:44:00Z",
      "mergedAt": "2021-10-02T07:44:00Z",
      "mergedBy": "goelvidhi",
      "mergeCommit": {
        "oid": "8e15a9af73c7c2a932e4de9081ab4cec504eaf31"
      },
      "comments": [
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "This isn't CUBIC-specific though, is it? What do other CC algorithms say about app-limited periods?",
          "createdAt": "2021-09-27T13:52:09Z",
          "updatedAt": "2021-09-27T13:52:09Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "It is hard to accurately define how long is long, as intuitively, it depends on the change of cwnd. The goal here is to reduce or limit the sudden big changes of cwnd. It is acceptable to have some minor changes of cwnd after an app-limited period, but not acceptable to have a big change of cwnd. Similarly, it is hard to define how big is a big change of cwnd. \r\n\r\nMaybe we can remove \"long\"?\r\n\r\nThanks",
          "createdAt": "2021-09-27T16:26:11Z",
          "updatedAt": "2021-09-27T16:26:11Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with @lisongxu  that just dropping \"long\" should be fine, so that we have something like:\r\n\r\n+ {{win-inc}} requires that *t* in {{eq1}} does not include\r\n+ application-limited periods, such as idle periods, otherwise\r\n+ W<sub>cubic</sub>(*t*) might be very high after restarting from these\r\n+ periods.\r\n",
          "createdAt": "2021-09-27T16:38:50Z",
          "updatedAt": "2021-09-27T16:38:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEpK-U84tdm5P",
          "commit": {
            "abbreviatedOid": "f72045e"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-24T06:40:48Z",
          "updatedAt": "2021-09-24T06:40:48Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84tdnYw",
          "commit": {
            "abbreviatedOid": "f72045e"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-24T06:44:12Z",
          "updatedAt": "2021-09-24T06:44:13Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "```suggestion\r\n{{win-inc}} requires that *t* in {{eq1}} does not include long\r\n```",
              "createdAt": "2021-09-24T06:44:12Z",
              "updatedAt": "2021-09-24T06:44:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84tgZUz",
          "commit": {
            "abbreviatedOid": "ba095f0"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-24T20:52:36Z",
          "updatedAt": "2021-09-24T20:52:43Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Thank you @bbriscoe for working on this. The text change looks good to me.\r\nFor every issue, we add Issue history in Appendix B, could you add that?",
              "createdAt": "2021-09-24T20:52:37Z",
              "updatedAt": "2021-09-24T20:52:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84tjOjS",
          "commit": {
            "abbreviatedOid": "ba095f0"
          },
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "This is better located now, thanks.\r\n\r\nHowever, the requirement is quite vaguely stated. What is \"a long period\", i.e., what is the rule what an implementer can use to decide whether or not to include an idle/application-limited period in t? Moreover, an idle period is quite trivial for a TCP sender to detect, but what is the rule for a TCP sender to detect/decide that it does not fully use cwnd? An arbitrary implementer must be able to implement this correctly.",
          "createdAt": "2021-09-27T12:30:09Z",
          "updatedAt": "2021-09-27T12:30:09Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84tkTtK",
          "commit": {
            "abbreviatedOid": "ba095f0"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks",
          "createdAt": "2021-09-27T16:21:31Z",
          "updatedAt": "2021-09-27T16:21:31Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84tmafB",
          "commit": {
            "abbreviatedOid": "ba095f0"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "This removes \"long\" as suggested in this thread.",
          "createdAt": "2021-09-28T07:04:58Z",
          "updatedAt": "2021-09-28T07:05:38Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nThe elapsed time *t* in {{eq1}} MUST NOT include periods during\r\n```",
              "createdAt": "2021-09-28T07:04:58Z",
              "updatedAt": "2021-09-28T07:05:38Z"
            },
            {
              "originalPosition": 24,
              "body": "```suggestion\r\n{{win-inc}} requires that *t* in {{eq1}} does not include\r\n```",
              "createdAt": "2021-09-28T07:05:16Z",
              "updatedAt": "2021-09-28T07:05:38Z"
            }
          ]
        }
      ]
    },
    {
      "number": 116,
      "id": "PR_kwDOEpK-U84sNEm_",
      "title": "New text for sudden events section",
      "url": "https://github.com/NTAP/rfc8312bis/pull/116",
      "state": "MERGED",
      "author": "bbriscoe",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Intended to resolve NTAP/rfc8312bis/#98",
      "createdAt": "2021-09-23T18:15:25Z",
      "updatedAt": "2021-09-24T20:23:08Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "b28a2bada0c71ce665a96add557fac0c070bc1f6",
      "headRepository": "bbriscoe/rfc8312bis",
      "headRefName": "sudden",
      "headRefOid": "c7c38db39aca1115320a7780bf01517ef5e926ef",
      "closedAt": "2021-09-24T09:38:41Z",
      "mergedAt": "2021-09-24T09:38:41Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "fdaeccb798bdc3ceba34455ba2f9e45bde25226e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEpK-U84tdmez",
          "commit": {
            "abbreviatedOid": "024c8e2"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "OK modulo some nits.",
          "createdAt": "2021-09-24T06:37:55Z",
          "updatedAt": "2021-09-24T06:38:59Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\ncapacity, a routing change, or a mobility event, CUBIC is designed to\r\n```",
              "createdAt": "2021-09-24T06:37:55Z",
              "updatedAt": "2021-09-24T06:38:59Z"
            },
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nOn the other hand, if there is a sudden decrease in capacity, CUBIC\r\n```",
              "createdAt": "2021-09-24T06:38:11Z",
              "updatedAt": "2021-09-24T06:38:59Z"
            },
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nreduces more slowly than Reno. This remains true whether or not CUBIC\r\n```",
              "createdAt": "2021-09-24T06:38:27Z",
              "updatedAt": "2021-09-24T06:38:59Z"
            },
            {
              "originalPosition": 12,
              "body": "```suggestion\r\nis in Reno-friendly mode and whether or not fast convergence is\r\n```",
              "createdAt": "2021-09-24T06:38:39Z",
              "updatedAt": "2021-09-24T06:38:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84teBRJ",
          "commit": {
            "abbreviatedOid": "c7c38db"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-24T08:54:31Z",
          "updatedAt": "2021-09-24T08:54:31Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84tgUsn",
          "commit": {
            "abbreviatedOid": "c7c38db"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks",
          "createdAt": "2021-09-24T20:23:08Z",
          "updatedAt": "2021-09-24T20:23:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 117,
      "id": "PR_kwDOEpK-U84sNNNq",
      "title": "Review of (AIMD TCP -> Reno) changes",
      "url": "https://github.com/NTAP/rfc8312bis/pull/117",
      "state": "MERGED",
      "author": "bbriscoe",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Intended to resolve NTAP/rfc8312bis/#108",
      "createdAt": "2021-09-23T19:11:44Z",
      "updatedAt": "2021-09-24T06:37:26Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "aimd-to-reno",
      "baseRefOid": "7952a09a8cac9611253127b89583d22aed8215c4",
      "headRepository": "bbriscoe/rfc8312bis",
      "headRefName": "aimd-to-reno",
      "headRefOid": "5073ecbb9cc6fb8e90588cce57529d9253fc7ad4",
      "closedAt": "2021-09-24T06:37:26Z",
      "mergedAt": "2021-09-24T06:37:26Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "dfd18731f5aefff30a6a82dcdf98baece7105a84"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEpK-U84tdlEk",
          "commit": {
            "abbreviatedOid": "44cabdf"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Made some rewording suggestions to bring the PR more in line with the rest of the draft. Looks good otherwise, thanks!",
          "createdAt": "2021-09-24T06:27:45Z",
          "updatedAt": "2021-09-24T06:29:17Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nclassical Reno TCP has with  low utilization over fast and long-distance\r\n```",
              "createdAt": "2021-09-24T06:27:45Z",
              "updatedAt": "2021-09-24T06:29:17Z"
            },
            {
              "originalPosition": 22,
              "body": "```suggestion\r\nlimits the aggressiveness of Reno TCP implementations in its Section 3.\r\n```",
              "createdAt": "2021-09-24T06:27:59Z",
              "updatedAt": "2021-09-24T06:29:17Z"
            },
            {
              "originalPosition": 48,
              "body": "```suggestion\r\nwindow sizes of Reno TCP, HSTCP, and CUBIC TCP. The average window sizes\r\n```",
              "createdAt": "2021-09-24T06:28:22Z",
              "updatedAt": "2021-09-24T06:29:17Z"
            },
            {
              "originalPosition": 62,
              "body": "```suggestion\r\nrequires a packet loss rate of 2.0e-10, while CUBIC TCP requires a packet\r\n```",
              "createdAt": "2021-09-24T06:28:36Z",
              "updatedAt": "2021-09-24T06:29:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84tdmNJ",
          "commit": {
            "abbreviatedOid": "44cabdf"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-24T06:35:55Z",
          "updatedAt": "2021-09-24T06:35:56Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "```suggestion\r\nCUBIC requires only changes to the congestion control at the sender, and it does\r\nnot require any changes at receivers. That is, a CUBIC sender works correctly\r\nwith Reno receivers. In addition, CUBIC does not require any\r\n```",
              "createdAt": "2021-09-24T06:35:55Z",
              "updatedAt": "2021-09-24T06:35:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84tdmYc",
          "commit": {
            "abbreviatedOid": "5073ecb"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-24T06:37:14Z",
          "updatedAt": "2021-09-24T06:37:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 119,
      "id": "PR_kwDOEpK-U84sQ8iU",
      "title": "remove confusing text about cwnd_start",
      "url": "https://github.com/NTAP/rfc8312bis/pull/119",
      "state": "MERGED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "closes #100 ",
      "createdAt": "2021-09-25T07:23:07Z",
      "updatedAt": "2021-09-27T13:52:30Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "fdaeccb798bdc3ceba34455ba2f9e45bde25226e",
      "headRepository": "goelvidhi/rfc8312bis",
      "headRefName": "cwnd-start",
      "headRefOid": "85aa0b7bf4e0dada5759845a41b769cf012ee134",
      "closedAt": "2021-09-27T13:52:30Z",
      "mergedAt": "2021-09-27T13:52:30Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "bcd9022a1b1ce46d1b985db1b61f2f4bd0994b2e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEpK-U84tjGX-",
          "commit": {
            "abbreviatedOid": "85aa0b7"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-27T11:54:49Z",
          "updatedAt": "2021-09-27T11:54:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84tjKJg",
          "commit": {
            "abbreviatedOid": "85aa0b7"
          },
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-27T12:11:27Z",
          "updatedAt": "2021-09-27T12:11:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 120,
      "id": "PR_kwDOEpK-U84sYKgL",
      "title": "Add list of people to ACK. Fixes #118.",
      "url": "https://github.com/NTAP/rfc8312bis/pull/120",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Anyone else to ACK?",
      "createdAt": "2021-09-28T07:44:32Z",
      "updatedAt": "2021-09-29T08:03:54Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "f3db2837f6d4ab927848833fd93dff6b1be32325",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "ack-people",
      "headRefOid": "34c1a15c8298cdc33758797b49fbd85ab0e9a25f",
      "closedAt": "2021-09-29T08:03:50Z",
      "mergedAt": "2021-09-29T08:03:50Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "e9231bf28b4f00618a47586890e8b305e574ad05"
      },
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Just checked the closed issues history, below folks had raised issues / provided suggestions:\r\n- Wesley Rosenblum \r\n- Martin Thomson\r\n- Mirja Kuehlewind\r\n- Mohit P. Tahiliani\r\n- Yuchung Cheng\r\n- Richard Scheffenegger\r\n- Michael Welzl\r\n- Junho Choi\r\n- Michael Scharf",
          "createdAt": "2021-09-28T17:19:25Z",
          "updatedAt": "2021-09-28T17:19:25Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Thank you! I used the `gh` command line client to extract contributors, and forgot it only retrieves 30 issues by default. So people were missed.",
          "createdAt": "2021-09-29T07:54:42Z",
          "updatedAt": "2021-09-29T07:54:42Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEpK-U84to-nN",
          "commit": {
            "abbreviatedOid": "38fc2a3"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-28T16:58:40Z",
          "updatedAt": "2021-09-28T16:58:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 121,
      "id": "PR_kwDOEpK-U84slr4E",
      "title": "update history for already merged 115",
      "url": "https://github.com/NTAP/rfc8312bis/pull/121",
      "state": "MERGED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-02T07:50:54Z",
      "updatedAt": "2021-10-04T06:22:14Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "8e15a9af73c7c2a932e4de9081ab4cec504eaf31",
      "headRepository": "goelvidhi/rfc8312bis",
      "headRefName": "update-history-115",
      "headRefOid": "76fe395459197710347bbf32bf23786adb023489",
      "closedAt": "2021-10-04T06:22:14Z",
      "mergedAt": "2021-10-04T06:22:14Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "5021e76409d2e2e2a239a767074d5c44c686dbe4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEpK-U84t48RS",
          "commit": {
            "abbreviatedOid": "76fe395"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-04T06:22:09Z",
          "updatedAt": "2021-10-04T06:22:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 122,
      "id": "PR_kwDOEpK-U84sltcG",
      "title": "clarify text for multiplicative decrease along with adding informative reference",
      "url": "https://github.com/NTAP/rfc8312bis/pull/122",
      "state": "MERGED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #102",
      "createdAt": "2021-10-02T08:34:41Z",
      "updatedAt": "2021-10-13T06:28:23Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "5021e76409d2e2e2a239a767074d5c44c686dbe4",
      "headRepository": "goelvidhi/rfc8312bis",
      "headRefName": "cwnd-reduction-prr",
      "headRefOid": "db0352060a1642a4ba819e452dff109e2376a186",
      "closedAt": "2021-10-13T06:28:23Z",
      "mergedAt": "2021-10-13T06:28:23Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "b37f22460569982b546fa9a6331b52593a58e3a4"
      },
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "I will add issue details to the appendix after #121 is merged.",
          "createdAt": "2021-10-02T08:35:43Z",
          "updatedAt": "2021-10-02T08:35:43Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> \"the sender MAY reduce the congestion window immediately upon entering the loss recovery or use other mechanisms, such as Proportional Rate Reduction {{?PRR=RFC6937}}\"\r\n> \r\n> We also add a RFC for \" immediately upon entering the loss recovery\"? Thanks\r\n\r\nThats what CUBIC is doing right. CUBIC says,\r\n`When a congestion event is detected by mechanisms described in Section 3.1, CUBIC updates Wmax and reduces cwnd and ssthresh immediately as described below`\r\n\r\nSo, either do it immediately what CUBIC says or use something else like PRR.",
          "createdAt": "2021-10-04T23:28:51Z",
          "updatedAt": "2021-10-04T23:28:51Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@lisongxu maybe I misunderstood what you said. Are you saying we should add an RFC when we say `reduce immediately`? What would you suggest? Also, please see my other comment.",
          "createdAt": "2021-10-05T05:12:50Z",
          "updatedAt": "2021-10-05T05:12:50Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@vidhigoel-apple Yes, I was thinking to add a related RFC when we say \"reduce cwnd immediately\". I am not sure whether this is an accurate description, as Reno and others set cwnd to ssthresh at the end of fast recovery instead of immediately.",
          "createdAt": "2021-10-05T18:14:30Z",
          "updatedAt": "2021-10-05T18:14:30Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "body": "Adding a related RFC to document the \"reduce cwnd immediately\" alternative sounds good. I think [RFC6675] would be appropriate, since both specifies reducing cwnd immediately upon entering recovery:\r\n\r\nRFC5681 at\r\n  https://datatracker.ietf.org/doc/html/rfc5681#section-3.2\r\nsays:\r\n   2.  When the third duplicate ACK is received, a TCP MUST set ssthresh\r\n       to no more than the value given in equation (4).\r\n...\r\n   3.  The lost segment starting at SND.UNA MUST be retransmitted and\r\n       cwnd set to ssthresh plus 3*SMSS. \r\n\r\nIn RFC6675 at\r\n  https://datatracker.ietf.org/doc/html/rfc6675#section-5\r\nit says:\r\n\r\n   (1) If DupAcks >= DupThresh, go to step (4).\r\n...\r\n (4) Invoke fast retransmit and enter loss recovery as follows:\r\n...\r\n       (4.2) ssthresh = cwnd = (FlightSize / 2)\r\n\r\n             The congestion window (cwnd) and slow start threshold\r\n             (ssthresh) are reduced to half of FlightSize per [RFC5681].\r\n             Additionally, note that [RFC5681] requires that any\r\n             segments sent as part of the Limited Transmit mechanism not\r\n             be counted in FlightSize for the purpose of the above\r\n             equation.\r\n\r\n       (4.3) Retransmit the first data segment presumed dropped ...\r\n ",
          "createdAt": "2021-10-05T20:32:57Z",
          "updatedAt": "2021-10-05T20:32:57Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "I would not confuse the reader by saying that \"use ... PRR ... to update the congestion window to its new reduced *ssthresh* value at the end of loss recovery.\"\r\n\r\nPRR does not do it in this way as it is written in RFC 6937 even though that is what effectively is the outcome. I believe RFC 6937 is intentionally written like this (i.e., it does not touch cwnd nor ssthresh in the exit) so that PRR algo works nicely with both RFC 6675 and RFC 6582 which differ in how and when they set ssthresh and cwnd.  RFC 6675 does not set cwnd nor ssthresh in the end but only in the beginning and leaves both untouched during the recovery. RFC 6582 in turn explicitly sets cwnd in the end of the recovery. \r\n\r\nTo make it simple, the only thing this draft needs to say is that it applies a different MD factor than the equation (4) of RFC 5681 (and correspondingly step 4.2 of RFC 6675) when entering Fast Rexmit / Fast Recovery.",
          "createdAt": "2021-10-06T00:25:56Z",
          "updatedAt": "2021-10-06T00:25:56Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you all for the discussion! This is very helpful.\r\n\r\nBased on the discussions, it seems that it is better to clearly indicate that Cubic reduces ssthresh at the beginning of fast recovery, and also updates W_max (fast convergence) at the beginning of the fast recovery.  Cubic may reduce cwnd at the beginning or the end of fast recovery depending on the specific recovery algorithm. \r\n",
          "createdAt": "2021-10-06T02:13:06Z",
          "updatedAt": "2021-10-06T02:13:06Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@lisongxu @nealcardwell @markkukojo I have addressed the comments to include everyone's points. Please see the new changes.\r\n\r\n@markkukojo I would like to keep the recommendation for PRR as it provides guidance for alternate approaches that may be better than what is described in CUBIC.",
          "createdAt": "2021-10-06T08:40:26Z",
          "updatedAt": "2021-10-06T08:41:01Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@larseggert this PR is good to go.",
          "createdAt": "2021-10-12T20:50:25Z",
          "updatedAt": "2021-10-12T20:50:25Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEpK-U84t4oPd",
          "commit": {
            "abbreviatedOid": "c9c03f9"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "\"the sender MAY reduce the congestion window immediately upon entering the loss recovery or use other mechanisms, such as Proportional Rate Reduction {{?PRR=RFC6937}}\"\r\n\r\nWe also add a RFC for \" immediately upon entering the loss recovery\"? Thanks\r\n",
          "createdAt": "2021-10-04T03:03:24Z",
          "updatedAt": "2021-10-04T03:03:24Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84uD176",
          "commit": {
            "abbreviatedOid": "0f04f86"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you, Vidhi!",
          "createdAt": "2021-10-06T14:09:25Z",
          "updatedAt": "2021-10-06T14:09:25Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84uMEjt",
          "commit": {
            "abbreviatedOid": "0f04f86"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-10-08T11:50:37Z",
          "updatedAt": "2021-10-08T11:52:37Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nor use other mechanisms, such as Proportional Rate Reduction {{?RFC6937}},\r\n```\r\nSince we don't use symbolic references anywhere else.",
              "createdAt": "2021-10-08T11:50:37Z",
              "updatedAt": "2021-10-08T11:52:37Z"
            },
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nThe parameter {{{\u03b2}{}}}*<sub>cubic</sub>* SHOULD be set to 0.7, which\r\n```",
              "createdAt": "2021-10-08T11:51:00Z",
              "updatedAt": "2021-10-08T11:52:37Z"
            },
            {
              "originalPosition": 20,
              "body": "Should this not say that the sender \"MUST do one of the following\"? MAY leaves it open to do something completely different?",
              "createdAt": "2021-10-08T11:52:33Z",
              "updatedAt": "2021-10-08T11:53:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84uNEkU",
          "commit": {
            "abbreviatedOid": "0f04f86"
          },
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-08T15:55:43Z",
          "updatedAt": "2021-10-08T15:55:43Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Yes, good point. Seems much better to say \"MUST do one of the following\". e.g., like:\r\n\r\n  In case of packet loss, the sender MUST either reduce the congestion window\r\n  immediately upon entering the loss recovery similar to {{!RFC6675}}\r\n  or use other mechanisms, such as Proportional Rate Reduction {{?PRR=RFC6937}},\r\n  to reduce the congestion window more gradually.\r\n",
              "createdAt": "2021-10-08T15:55:43Z",
              "updatedAt": "2021-10-08T15:55:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84uPCv-",
          "commit": {
            "abbreviatedOid": "0f04f86"
          },
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-10T17:50:59Z",
          "updatedAt": "2021-10-10T17:50:59Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "I fully agree with \"the sender MUST reduce the congestion window immediately upon entering the loss recovery\".\r\n\r\nHowever, the proposed text has two issues in its diction:\r\n1) using MUST with PRR requires RFC 6937 to become a normative reference and thereby as an experimental RFC it would be a down reference.\r\n2) It is no problem to say \"MUST reduce cwnd immediately\" with RFC 6937 as well. Please see how RFC 6937 is written: it expects sshthresh (and cwnd) to be reduced when PRR is entered, and then it uses only ssthresh in the algorithm. cwnd is untouched in the algo, instead a local variable \"sndcnt\" is used to control the sending rate during the loss recovery. So, it is important to write the requirements in this draft such that they meet the text in the other RFCs that it cites, not how some stacks happen to apply the algorithms in RFCs.\r\n\r\nCould something along the following lines be used:\r\n\r\nIn case of packet loss, the sender MUST reduce the congestion window and ssthresh \r\nimmediately upon entering the loss recovery [similar to {{!RFC5681}}  (and {{!RFC6675}})].\r\nNote that other mechanisms, such as Proportional Rate Reduction {{?RFC6937}},\r\ncan be used to reduce the sending rate during fast recovery more gradually.",
              "createdAt": "2021-10-10T17:50:59Z",
              "updatedAt": "2021-10-10T17:50:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84uPpdi",
          "commit": {
            "abbreviatedOid": "0f04f86"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T06:43:40Z",
          "updatedAt": "2021-10-11T06:43:40Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "DOWNREFs are a technicality that shouldn't stop us from recommending what we think should be recommended. The IESG approves DOWNREFs all the time, we (well, the chairs in their document writeup) just need to explain the need.",
              "createdAt": "2021-10-11T06:43:40Z",
              "updatedAt": "2021-10-11T06:43:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84uQd_h",
          "commit": {
            "abbreviatedOid": "9995110"
          },
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T10:29:39Z",
          "updatedAt": "2021-10-11T10:29:39Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Sure, IESG may approve DOWNREFs. But the question is why should we do it when there is no real need? CUBIC does not dependent on PRR, or am I missing something?\r\n\r\nSo, the item 2 above that I raised is more of the key here. \r\nAs I tried to point out we should write the text in this draft such that an implementer is able to do his/her implementation based on what has been written in RFCs and without causing any unnecessary confusion. That is, we should care about the quality of RFCs, right? \r\nIf this draft writes \"reduce the congestion window more gradually\" and cites RFC 6937, it creates unnecessary confusion because RFC 6937 does not reduce cwnd gradually!\r\nIt controls the sending rate via other variables and the correct operation of PRR requires that ssthresh is reduced immediately when entering fast rexmit & fast recovery.\r\nReducing cwnd also immediately is 100% compatible with the algo in RFC 6937. \r\n\r\nI wonder if there are any comments on the proposed text I provided? The recommendation to use PRR can possibly be made stronger if seen necessary. However, CUBIC is no different from the other CCs with respect to PRR, so IMO any (strong) recommendations to use PRR would be best made in rfc6937bis which is under way and is in the best position to include a recommendation common to all fast recovery variants we have in RFC series.",
              "createdAt": "2021-10-11T10:29:39Z",
              "updatedAt": "2021-10-11T10:29:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84uQii1",
          "commit": {
            "abbreviatedOid": "9995110"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T10:51:10Z",
          "updatedAt": "2021-10-11T10:51:10Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "I'm OK with your text - the others probably haven't had a chance to see it, because timezones.",
              "createdAt": "2021-10-11T10:51:10Z",
              "updatedAt": "2021-10-11T10:51:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84uUCcy",
          "commit": {
            "abbreviatedOid": "00be36f"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T07:52:54Z",
          "updatedAt": "2021-10-12T07:52:55Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Thank you Markku and everyone for the suggestions. I have updated text with Markku's suggestion with slight modification (rearranged the brackets and s/fast recovery/loss recovery when suggesting PRR.\r\n\r\nHTML view,\r\n<img width=\"624\" alt=\"136905136-90e6c461-82b2-40ff-b243-572df4740bd7\" src=\"https://user-images.githubusercontent.com/10913828/136914815-5f0417ef-f400-4726-b49f-02590e3c6e57.png\">\r\n\r\n@nealcardwell @markkukojo @lisongxu @larseggert please review again.\r\n\r\n",
              "createdAt": "2021-10-12T07:52:54Z",
              "updatedAt": "2021-10-12T07:52:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84uVfKv",
          "commit": {
            "abbreviatedOid": "00be36f"
          },
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T13:28:25Z",
          "updatedAt": "2021-10-12T13:28:25Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "This text in https://github.com/NTAP/rfc8312bis/pull/122#discussion_r726853901 looks good to me. Thanks!\r\n",
              "createdAt": "2021-10-12T13:28:25Z",
              "updatedAt": "2021-10-12T13:28:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84uVokU",
          "commit": {
            "abbreviatedOid": "00be36f"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-10-12T13:58:07Z",
          "updatedAt": "2021-10-12T13:59:06Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nIn case of packet loss, the sender MUST reduce *cwnd*\r\n```",
              "createdAt": "2021-10-12T13:58:07Z",
              "updatedAt": "2021-10-12T13:59:06Z"
            },
            {
              "originalPosition": 12,
              "body": "```suggestion\r\nand *ssthresh* immediately upon entering loss recovery, similar to\r\n```",
              "createdAt": "2021-10-12T13:58:26Z",
              "updatedAt": "2021-10-12T13:59:06Z"
            },
            {
              "originalPosition": 13,
              "body": "```suggestion\r\n{{!RFC5681}} (and {{!RFC6675}}). Note that other mechanisms,\r\n```",
              "createdAt": "2021-10-12T13:58:43Z",
              "updatedAt": "2021-10-12T13:59:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84uW4jQ",
          "commit": {
            "abbreviatedOid": "00be36f"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T19:02:13Z",
          "updatedAt": "2021-10-12T19:02:13Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Thank you, Vidhi! It looks good. ",
              "createdAt": "2021-10-12T19:02:13Z",
              "updatedAt": "2021-10-12T19:02:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84uXPZq",
          "commit": {
            "abbreviatedOid": "db03520"
          },
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T20:40:01Z",
          "updatedAt": "2021-10-12T20:40:01Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Looks good, thanks. \r\nJust an editorial note: the sentence citing RFC7661 (or the message it intends to convey) might be better relocated together with the upcoming text that I assume we need to add to discuss and explain the rate-limited application issues.",
              "createdAt": "2021-10-12T20:40:01Z",
              "updatedAt": "2021-10-12T20:40:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84uXQ_B",
          "commit": {
            "abbreviatedOid": "db03520"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T20:48:09Z",
          "updatedAt": "2021-10-12T20:48:09Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Noted. Will make sure that this is considered in the PR for that. Will put your comment link on the issue.",
              "createdAt": "2021-10-12T20:48:09Z",
              "updatedAt": "2021-10-12T20:48:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 123,
      "id": "PR_kwDOEpK-U84tJXSy",
      "title": "PR of @lisongxu's suggestion for #94",
      "url": "https://github.com/NTAP/rfc8312bis/pull/123",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #94.",
      "createdAt": "2021-10-13T13:52:25Z",
      "updatedAt": "2021-10-22T13:01:49Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "3bc0002c01b77798bf15bd0fd7bb18242168469e",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "fix-94",
      "headRefOid": "5ff5a5e0095dcecf81b6b0c9e55b064afee89223",
      "closedAt": "2021-10-22T13:01:45Z",
      "mergedAt": "2021-10-22T13:01:45Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "88d85e8584446e0c84fe36ddc1ca710cf2d88b78"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEpK-U84uhZnE",
          "commit": {
            "abbreviatedOid": "4c2f67e"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-10-15T06:44:33Z",
          "updatedAt": "2021-10-15T06:57:11Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "```suggestion\r\n- Clarify text around queuing and slow adaptation of CUBIC in wireless environments\r\n```",
              "createdAt": "2021-10-15T06:44:33Z",
              "updatedAt": "2021-10-15T06:58:11Z"
            },
            {
              "originalPosition": 20,
              "body": "I think we should add this line somewhere around here, but don't know the right place.\r\n`In large BDP networks after a congestion event, CUBIC, due its cubic window increase function recovers quickly to the highest link utilization point.  This mean that link utilization is less sensitive to an AQM target that is lower than the amplitude of the whole sawtooth.`",
              "createdAt": "2021-10-15T06:57:04Z",
              "updatedAt": "2021-10-15T06:57:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84uhcLA",
          "commit": {
            "abbreviatedOid": "fc80c61"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-15T07:02:16Z",
          "updatedAt": "2021-10-15T07:02:17Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "I added it, please check",
              "createdAt": "2021-10-15T07:02:16Z",
              "updatedAt": "2021-10-15T07:02:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84uhnvQ",
          "commit": {
            "abbreviatedOid": "fc80c61"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-15T08:00:38Z",
          "updatedAt": "2021-10-15T08:00:39Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "```suggestion\r\npoint. This means that link utilization is less sensitive to an active\r\n```",
              "createdAt": "2021-10-15T08:00:38Z",
              "updatedAt": "2021-10-15T08:00:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84uhnxa",
          "commit": {
            "abbreviatedOid": "fc80c61"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-15T08:00:49Z",
          "updatedAt": "2021-10-15T08:00:49Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Looks good.",
              "createdAt": "2021-10-15T08:00:49Z",
              "updatedAt": "2021-10-15T08:00:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84uhn2Q",
          "commit": {
            "abbreviatedOid": "fc80c61"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-15T08:01:09Z",
          "updatedAt": "2021-10-15T08:01:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 124,
      "id": "PR_kwDOEpK-U84tPUdL",
      "title": "cwnd should be at least 1 and after that use timer",
      "url": "https://github.com/NTAP/rfc8312bis/pull/124",
      "state": "MERGED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "closes #83.\r\n\r\nWill add the changelog soon.",
      "createdAt": "2021-10-15T07:56:44Z",
      "updatedAt": "2021-10-27T21:38:35Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "b37f22460569982b546fa9a6331b52593a58e3a4",
      "headRepository": "goelvidhi/rfc8312bis",
      "headRefName": "lower-bound-cwnd",
      "headRefOid": "c92a56d2b6fdbda59e9d5010b191a9cfb03fdfb7",
      "closedAt": "2021-10-22T12:59:34Z",
      "mergedAt": "2021-10-22T12:59:34Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "3bc0002c01b77798bf15bd0fd7bb18242168469e"
      },
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "<img width=\"630\" alt=\"Screen Shot 2021-10-15 at 1 02 43 AM\" src=\"https://user-images.githubusercontent.com/10913828/137453368-68134a92-3850-4441-b0e9-0bd38a0ef349.png\">\r\n\r\nI have updated the equation so that cwnd is at least 1MSS. Also added text about how to handle a new congestion event if there are more congestion events after cwnd = 1MSS",
          "createdAt": "2021-10-15T08:04:15Z",
          "updatedAt": "2021-10-15T08:04:15Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "This still needs a change log.",
          "createdAt": "2021-10-16T05:43:09Z",
          "updatedAt": "2021-10-16T05:43:09Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Added changelog",
          "createdAt": "2021-10-16T05:56:47Z",
          "updatedAt": "2021-10-16T05:56:47Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "> <img alt=\"Screen Shot 2021-10-15 at 1 02 43 AM\" width=\"630\" src=\"https://user-images.githubusercontent.com/10913828/137453368-68134a92-3850-4441-b0e9-0bd38a0ef349.png\">\r\n> \r\n> I have updated the equation so that cwnd is at least 1MSS. Also added text about how to handle a new congestion event if there are more congestion events after cwnd = 1MSS\r\n\r\n@goelvidhi How do you think about the following change?\r\n\r\nAfter that, if there is a new congestion event,\r\n->\r\nIf congestion persists,\r\n\r\nAlso we have to cite RFC5033, not RFC3168.\r\n\r\n",
          "createdAt": "2021-10-16T06:21:07Z",
          "updatedAt": "2021-10-16T06:21:07Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> @goelvidhi How do you think about the following change?\r\n> \r\n> After that, if there is a new congestion event, -> If congestion persists,\r\n\r\nUpdate the text.\r\n\r\n> \r\n> Also we have to cite RFC5033, not RFC3168.\r\n\r\nThe backoff using timer is described in RFC 3168 in Section 6.2, something like,\r\n`Therefore, the sending TCP MUST reset the\r\n   retransmit timer on receiving the ECN-Echo packet when the congestion\r\n   window is one.`\r\n\r\nThat's why I referenced 3168. I didn't understand why we should reference 5033?\r\n",
          "createdAt": "2021-10-16T06:38:46Z",
          "updatedAt": "2021-10-16T06:39:57Z"
        },
        {
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "body": "> > @goelvidhi How do you think about the following change?\r\n> > After that, if there is a new congestion event, -> If congestion persists,\r\n> \r\n> Update the text.\r\n> \r\n> > Also we have to cite RFC5033, not RFC3168.\r\n> \r\n> The backoff using timer is described in RFC 3168 in Section 6.2, something like, `Therefore, the sending TCP MUST reset the retransmit timer on receiving the ECN-Echo packet when the congestion window is one.`\r\n> \r\n> That's why I referenced 3168. I didn't understand why we should reference 5033?\r\n\r\nI thought that is more specific to ECN. From RFC5033, I see a more general description. I think either way seems fine.\r\n\r\n 'For \"full backoff\", at some point the algorithm would reduce the\r\n       sending rate to one packet per round-trip time and then\r\n       exponentially backoff the time between single packet\r\n       transmissions if congestion persists.'",
          "createdAt": "2021-10-16T06:47:20Z",
          "updatedAt": "2021-10-16T06:47:20Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "> I thought that is more specific to ECN. From RFC5033, I see a more general description. I think either way seems fine.\r\n> \r\n> 'For \"full backoff\", at some point the algorithm would reduce the sending rate to one packet per round-trip time and then exponentially backoff the time between single packet transmissions if congestion persists.'\r\n\r\nOk, I added the \"full backoff\" requirement in the congestion collapse section. Please take a look.\r\n\r\n",
          "createdAt": "2021-10-18T07:41:30Z",
          "updatedAt": "2021-10-18T07:41:30Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": "This text is fine for ECN but there is slight misunderstanding here. Only when ECE arrives the cwnd has lower bound of 1 MSS. If it is loss event, then the original equation with lower bound of 2 MSS for both cwnd and ssthresh was correct. So, we need two separate branches here: one for loss-induced congestion event and another for ECE. And a correct RFC to cite for ECN operation is RFC 3168 as Vidhi originally had. RFC 5033 provides a generic requirement that both loss-based CC and ECN follow anyway (see below). \r\n\r\nThe rationale and explanation why it is different is as follows. RFC 5681 (and RFC 2581 earlier) is for loss-based CC and it requires that ssthresh is lower bounded to 2 MSS and cwnd is assigned the same value as ssthresh during fast recovery (i.e., cwnd is also lower bounded to 2 MSS for fast recovery). This is fine because if the sender is able to enter fast recovery it means that ack clock is running  and the sender is getting Acks ((DupAcks) so it is not necessary to reduce the send rate below 2 MSS. But when cwnd (==FlightSize) is 2 MSS and a segment is dropped (or both segments are dropped) a TCP sender \r\na) cannot get three dupacks and is forced to wait for an RTO that takes cwnd=1 MSS (and ssthresh has minimum of 2 MSS), or\r\nb) alternatively if limited transmit is in use and only one segment is dropped, the TCP sender effectively sends only one segment on the arrival of the 1st dupack and waits one RTT to get the 2nd dupack and waits yet another RTT to get the 3rd dupack that triggers fast rexmit&fast recovery. Now it is ok again to set lower bound of 2 MSS for cwnd when entering fast recovery because the sender effectively already reduced the sending rate to 1 MSS/RTT for at least one RTT (effectively for two RTTs) and was not forced to enter RTO recovery because ack clock was running.\r\n\r\nWhen ECN is in use things are different because when ECN is operating ideally a TCP sender will never see RTO, so it would never reach cwnd = 1 MSS if cwnd is lower bounded to 2 MSS (except in case we start with IW = 1 MSS and immediately receive ECE). Therefore, on ECE the cwnd must not be lower bounded to 2 MSS.",
          "createdAt": "2021-10-18T21:29:12Z",
          "updatedAt": "2021-10-18T21:29:12Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@markkukojo, according to limited transmit RFC 3042, \r\n\r\nWhen a TCP sender has previously unsent data queued for transmission\r\n   it SHOULD use the Limited Transmit algorithm, which calls for a TCP\r\n   sender to transmit new data upon the arrival of the first two\r\n   consecutive duplicate ACKs when the following conditions are\r\n   satisfied:\r\n\r\n* The receiver's advertised window allows the transmission of the\r\n       segment.\r\n\r\n * The amount of outstanding data would remain less than or equal\r\n       to the congestion window plus 2 segments.  In other words, the\r\n       sender can only send two segments beyond the congestion window\r\n       (cwnd).\r\n\r\nCan a sender use 1 dup ACK instead of 2 dup ACKs to transmit new data? If the outstanding data can be > cwnd + 2, and one data packet is still in transit, wouldn't that mean that sender can send 1 (corresponding to the dup ACK) + 2 segments when the dup ACK arrives?\r\n\r\nI am convinced with your argument of using cwnd = Max(2, X) as we can't do fast recovery with a cwnd of 1. But I am just trying to understand the impact of limited transmit on cwnd = 2.",
          "createdAt": "2021-10-19T05:30:59Z",
          "updatedAt": "2021-10-19T05:30:59Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Updated cwnd reduction with two different branches,\r\n<img width=\"666\" alt=\"Screen Shot 2021-10-20 at 2 47 40 AM\" src=\"https://user-images.githubusercontent.com/10913828/138070703-6f500bed-9228-4870-8b19-0db27e8993df.png\">\r\n\r\n\r\n@markkukojo @lisongxu @sangtaeha @larseggert please take a look.\r\n",
          "createdAt": "2021-10-20T09:48:40Z",
          "updatedAt": "2021-10-20T09:48:40Z"
        },
        {
          "author": "markkukojo",
          "authorAssociation": "COLLABORATOR",
          "body": " \r\n> Can a sender use 1 dup ACK instead of 2 dup ACKs to transmit new data? If the outstanding data can be > cwnd + 2, and one data packet is still in transit, wouldn't that mean that sender can send 1 (corresponding to the dup ACK) + 2 segments when the dup ACK arrives?\r\n\r\nNot quite sure what you mean by \"If the outstanding data can be > cwnd + 2, ...\".\r\n\r\nAnyway, without SACK a TCP sender can send only one new segment per arriving DupAck, max two in total. This follows from the packet conservation principle as discussed in RFC 3042 a couple of paras later (one DupAck indicates one packet has left the network). RFC 3042 could be a bit clearer on this though. See also RFC 5681, Sec 3.2, step 1.\r\n\r\nWhen SACK is in use, a TCP sender may send 2 segments on arrival of one DupAck, if the SACK info indicates that two segments have left the network (see RFC 6675, Sec 5, step 3).  However, if cwnd=2,  SACK info in a DupAck cannot indicate more than one segment that has left the network.\r\n\r\nThe text in last para of sec 4.6 seems correct now. However, I would say it much stronger, that is:\r\n\r\ns/Note that CUBIC will continue to reduce/Note that CUBIC MUST continue to reduce/\r\n\r\ns/a sender with a _cwnd_ of 1 MSS needs to reduce/a sender with a _cwnd_ of 1 MSS MUST reduce/\r\n\r\nThese sentences should be requirements and RFC 3168 says that cwnd MUST be halved (=reduced) on ECE and later says that the lower bound for cwnd is 1 MSS. It also says that the TCP sender MUST reset retransmit timer.",
          "createdAt": "2021-10-27T21:38:34Z",
          "updatedAt": "2021-10-27T21:38:34Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEpK-U84uiJSG",
          "commit": {
            "abbreviatedOid": "1c0367d"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-15T10:39:30Z",
          "updatedAt": "2021-10-15T10:39:31Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "```suggestion\r\nNote that CUBIC will continue to reduce *cwnd* in response to congestion\r\nevents until it reaches a value of 1 MSS. After that, if there is a\r\nnew congestion event, a sender with the *cwnd* of 1 MSS needs to reduce\r\nits sending rate even further. It can achieve that by using a retransmission\r\ntimer with exponential backoff, as described in {{!RFC3168}}.\r\n```",
              "createdAt": "2021-10-15T10:39:30Z",
              "updatedAt": "2021-10-15T10:39:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84ukhD_",
          "commit": {
            "abbreviatedOid": "690a028"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-16T03:27:55Z",
          "updatedAt": "2021-10-16T03:27:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84umi9j",
          "commit": {
            "abbreviatedOid": "96145d0"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-10-18T10:12:45Z",
          "updatedAt": "2021-10-18T10:15:19Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\na sender with a *cwnd* of 1 MSS needs to reduce\r\n```",
              "createdAt": "2021-10-18T10:12:45Z",
              "updatedAt": "2021-10-18T10:15:19Z"
            },
            {
              "originalPosition": 34,
              "body": "```suggestion\r\n{{!RFC5033}}. After reducing the sending rate to one packet per\r\nRTT, CUBIC then exponentially increases the transmission\r\ntimer for each packet retransmission while congestion persists.\r\n```",
              "createdAt": "2021-10-18T10:15:06Z",
              "updatedAt": "2021-10-18T10:15:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84uqXVq",
          "commit": {
            "abbreviatedOid": "2ffa5a9"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-19T06:56:05Z",
          "updatedAt": "2021-10-19T06:56:05Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84uvDK6",
          "commit": {
            "abbreviatedOid": "3c7401a"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-20T07:19:30Z",
          "updatedAt": "2021-10-20T07:19:30Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Replace this with\r\n```\r\n\\begin{array}{lll}\r\n\r\nssthresh = &\r\ncwnd * \u03b2_{cubic} &\r\n\\text{// new slow-start threshold} \\\\\r\n\r\ncwnd = &\r\n\\left\\{\r\n\\begin{array}{l}\r\n\\mathrm{max}(ssthresh, 2) \\\\\r\n\\mathrm{max}(ssthresh, 1) \\\\\r\n\\end{array}\r\n\\right. &\r\n\\begin{array}{l}\r\n\\text{// on packet loss, reduce by at least 2 MSS} \\\\\r\n\\text{// on ECE, reduce by at least 1 MSS} \\\\\r\n\\end{array}\r\n\\\\\r\n\r\nssthresh = &\r\n\\mathrm{max}(ssthresh, 2) &\r\n\\text{// } ssthresh \\text{ is at least 2 MSS} \\\\\r\n\r\n\\end{array}\r\n```\r\nto fix the math issue",
              "createdAt": "2021-10-20T07:19:30Z",
              "updatedAt": "2021-10-20T07:19:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84uvDT8",
          "commit": {
            "abbreviatedOid": "3c7401a"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "See inline for math fix",
          "createdAt": "2021-10-20T07:20:10Z",
          "updatedAt": "2021-10-20T07:20:10Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84uv-Ny",
          "commit": {
            "abbreviatedOid": "c92a56d"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-20T11:04:41Z",
          "updatedAt": "2021-10-20T11:04:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84uzFWE",
          "commit": {
            "abbreviatedOid": "c92a56d"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-21T02:06:30Z",
          "updatedAt": "2021-10-21T02:06:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 125,
      "id": "PR_kwDOEpK-U84tY0_G",
      "title": "From @bbriscoe",
      "url": "https://github.com/NTAP/rfc8312bis/pull/125",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #85.",
      "createdAt": "2021-10-19T14:18:18Z",
      "updatedAt": "2021-10-25T11:50:04Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "3932f43e13cf100c050448d658bc492d3b476adc",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "more-fixes-for-85",
      "headRefOid": "b07e56471f1fdd26cbf2eddc66959073cf1ac67b",
      "closedAt": "2021-10-25T11:50:01Z",
      "mergedAt": "2021-10-25T11:50:01Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "28614f1d1eb319e1a6f681e4fabea7043e054758"
      },
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "I am fine with this change. @markkukojo does this satisfy your concerns?",
          "createdAt": "2021-10-19T17:41:58Z",
          "updatedAt": "2021-10-19T17:41:58Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Since we haven't heard from @markkukojo and the submission deadline is today, I am rolling this in now.",
          "createdAt": "2021-10-25T11:49:32Z",
          "updatedAt": "2021-10-25T11:49:32Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEpK-U84utLYD",
          "commit": {
            "abbreviatedOid": "b07e564"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-19T17:40:17Z",
          "updatedAt": "2021-10-19T17:40:17Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "How about,\r\nWhichever slow-start algorithm is used, work might be needed to ensure that the *cwnd* growth in slow-start and the first multiplicative decrease factor on exiting slow-start work well together.",
              "createdAt": "2021-10-19T17:40:17Z",
              "updatedAt": "2021-10-19T17:40:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84utO4h",
          "commit": {
            "abbreviatedOid": "b07e564"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-19T17:55:08Z",
          "updatedAt": "2021-10-19T17:55:09Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "@bbriscoe?",
              "createdAt": "2021-10-19T17:55:08Z",
              "updatedAt": "2021-10-19T17:55:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84u6lYg",
          "commit": {
            "abbreviatedOid": "b07e564"
          },
          "author": "bbriscoe",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T17:31:24Z",
          "updatedAt": "2021-10-22T17:31:25Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Fine.\r\n\r\nBTW, I said \"flow-start\", rather than \"slow-start\", 'cos I think \"slow-start\" should describe solely the algo called slow-start, and not also be used as a collective name for algorithms intended to improve on it. Admittedly, \"flow-start\" doesn't cover a restart tho.\r\n",
              "createdAt": "2021-10-22T17:31:24Z",
              "updatedAt": "2021-10-22T17:31:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 126,
      "id": "PR_kwDOEpK-U84tckY8",
      "title": "#114 Use FlightSize instead of cwnd",
      "url": "https://github.com/NTAP/rfc8312bis/pull/126",
      "state": "MERGED",
      "author": "lisongxu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#114 ",
      "createdAt": "2021-10-20T15:21:02Z",
      "updatedAt": "2021-10-25T11:49:43Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "88d85e8584446e0c84fe36ddc1ca710cf2d88b78",
      "headRepository": "lisongxu/rfc8312bis",
      "headRefName": "main",
      "headRefOid": "554e6f560cc82f4a950fcb0a64ef6fdedcfe35d3",
      "closedAt": "2021-10-25T11:49:43Z",
      "mergedAt": "2021-10-25T11:49:42Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "2433c13b1c8dc3e45736ff243ff9ca30aa94a131"
      },
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "Is it possible to move Figure 5 to the right side?\r\n\r\n<img width=\"584\" alt=\"Screen Shot 2021-10-20 at 8 00 51 PM\" src=\"https://user-images.githubusercontent.com/10913828/138204090-f26cbbe7-8ec0-45d4-8c7f-d1a083263db0.png\">\r\n",
          "createdAt": "2021-10-21T03:01:58Z",
          "updatedAt": "2021-10-21T03:01:58Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEpK-U84uyE0J",
          "commit": {
            "abbreviatedOid": "ba300b7"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-10-20T18:53:38Z",
          "updatedAt": "2021-10-20T18:53:53Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Would suggest to add a reference to the equation here.",
              "createdAt": "2021-10-20T18:53:38Z",
              "updatedAt": "2021-10-20T18:53:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84uzE5V",
          "commit": {
            "abbreviatedOid": "a464597"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-21T02:01:25Z",
          "updatedAt": "2021-10-21T02:01:25Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Done",
              "createdAt": "2021-10-21T02:01:25Z",
              "updatedAt": "2021-10-21T02:01:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84uzJZ9",
          "commit": {
            "abbreviatedOid": "a464597"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-10-21T02:49:05Z",
          "updatedAt": "2021-10-21T03:03:01Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "this will conflict with https://github.com/NTAP/rfc8312bis/pull/124 as the math is changed along with comments text. We just need to be a bit careful in merging these two PRs.",
              "createdAt": "2021-10-21T02:49:05Z",
              "updatedAt": "2021-10-21T03:03:01Z"
            },
            {
              "originalPosition": 1,
              "body": "We should probably remove line # 662 about RFC 7661 from this paragraph as this has been taken care of in line # 683.",
              "createdAt": "2021-10-21T02:52:22Z",
              "updatedAt": "2021-10-21T03:03:01Z"
            },
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nIn {{eqssthresh}}, *flight_size* is the amount of outstanding data in the network, as defined\r\n```",
              "createdAt": "2021-10-21T02:53:45Z",
              "updatedAt": "2021-10-21T03:03:01Z"
            },
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nssthresh = flight\\_size * \u03b2_{cubic} &\r\n```",
              "createdAt": "2021-10-21T03:02:34Z",
              "updatedAt": "2021-10-21T03:03:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84uzdf8",
          "commit": {
            "abbreviatedOid": "d4318b3"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-21T06:05:51Z",
          "updatedAt": "2021-10-21T06:05:51Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "You mean the entire sentence, i.e.\r\n> An implementation MAY\r\nset a smaller *ssthresh* than suggested below to\r\naccommodate rate-limited applications as described in {{?RFC7661}}.",
              "createdAt": "2021-10-21T06:05:51Z",
              "updatedAt": "2021-10-21T06:05:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84uzdt1",
          "commit": {
            "abbreviatedOid": "271157c"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-21T06:07:23Z",
          "updatedAt": "2021-10-21T06:07:24Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nIn {{eqssthresh}}, *flight_size* is the amount of outstanding data in\r\nthe network, as defined in {{!RFC5681}}.\r\nNote that a rate-limited application with idle periods\r\nor periods when unable to send at the full rate permitted by *cwnd*\r\n```",
              "createdAt": "2021-10-21T06:07:23Z",
              "updatedAt": "2021-10-21T06:07:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84u1PSF",
          "commit": {
            "abbreviatedOid": "fa208d8"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-21T13:36:42Z",
          "updatedAt": "2021-10-21T13:36:42Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "Thanks, Lars and Vidhi\r\nLisong",
              "createdAt": "2021-10-21T13:36:42Z",
              "updatedAt": "2021-10-21T13:36:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84u4O_2",
          "commit": {
            "abbreviatedOid": "fa208d8"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T07:05:08Z",
          "updatedAt": "2021-10-22T07:05:08Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "I'm still unclear if I identified the correct sentence to remove?",
              "createdAt": "2021-10-22T07:05:08Z",
              "updatedAt": "2021-10-22T07:05:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84u7MWi",
          "commit": {
            "abbreviatedOid": "fa208d8"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T21:04:04Z",
          "updatedAt": "2021-10-22T21:04:04Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "\r\n> You mean the entire sentence, i.e.\r\n> \r\n> > An implementation MAY\r\n> > set a smaller _ssthresh_ than suggested below to\r\n> > accommodate rate-limited applications as described in {{?RFC7661}}.\r\n\r\nYes.\r\n",
              "createdAt": "2021-10-22T21:04:04Z",
              "updatedAt": "2021-10-22T21:04:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84u7MrI",
          "commit": {
            "abbreviatedOid": "fa208d8"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T21:06:08Z",
          "updatedAt": "2021-10-22T21:06:08Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "These equations still need to be updated right as you merged #124 to main?",
              "createdAt": "2021-10-22T21:06:08Z",
              "updatedAt": "2021-10-22T21:06:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 127,
      "id": "PR_kwDOEpK-U84tn3d4",
      "title": "clarify first sentence in the abstract",
      "url": "https://github.com/NTAP/rfc8312bis/pull/127",
      "state": "MERGED",
      "author": "nealcardwell",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the first sentence of the abstract, this commit:\r\n\r\n(1) removes the redundant (to the point of being confusing) phrase \r\n \"on the  sender side\" (standard Internet congestion control has always\r\n been sender-side)\r\n\r\n(2) clarifies that the \"window\" that is increased is the congestion window\r\n  (e.g., not the receive window)\r\n\r\n(3) Changes \"the linear\" increase function to \"a linear\" increase function,\r\n  since there is no single linear increase function",
      "createdAt": "2021-10-25T12:39:05Z",
      "updatedAt": "2021-10-26T06:47:35Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "28614f1d1eb319e1a6f681e4fabea7043e054758",
      "headRepository": "nealcardwell/rfc8312bis",
      "headRefName": "patch-1",
      "headRefOid": "5c60f196af6a5fa5f6266980f37cc1a31c6d2901",
      "closedAt": "2021-10-26T06:47:35Z",
      "mergedAt": "2021-10-26T06:47:35Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "8d33e39eeff3eb83ae1a4190ed13ad92b11d5b51"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEpK-U84u-fwc",
          "commit": {
            "abbreviatedOid": "5c60f19"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-25T13:39:56Z",
          "updatedAt": "2021-10-25T13:39:56Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84vBWdX",
          "commit": {
            "abbreviatedOid": "5c60f19"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-26T05:52:48Z",
          "updatedAt": "2021-10-26T05:52:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 128,
      "id": "PR_kwDOEpK-U84txunF",
      "title": "apply Markku's suggestion in PR #124",
      "url": "https://github.com/NTAP/rfc8312bis/pull/128",
      "state": "MERGED",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This fixes https://github.com/NTAP/rfc8312bis/pull/124#issuecomment-953331295",
      "createdAt": "2021-10-28T06:15:53Z",
      "updatedAt": "2021-10-28T09:23:09Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "8d33e39eeff3eb83ae1a4190ed13ad92b11d5b51",
      "headRepository": "goelvidhi/rfc8312bis",
      "headRefName": "add-must-requirement",
      "headRefOid": "fbfa6bed848036342b1c188423d33065c17bbdab",
      "closedAt": "2021-10-28T09:23:09Z",
      "mergedAt": "2021-10-28T09:23:09Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "6a84ca895bc631ce31f071f378a02145de690766"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 129,
      "id": "PR_kwDOEpK-U84tzAcK",
      "title": "replace vague \"If congestion persists\" phrase for CE handling",
      "url": "https://github.com/NTAP/rfc8312bis/pull/129",
      "state": "MERGED",
      "author": "nealcardwell",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The text said: \"If congestion persists, a sender with a *cwnd* of 1 MSS MUST reduce\r\nits sending rate even further.\" But \"congestion persists\" is vague.\r\n\r\nIf this \"congestion\" is in the form of fast recovery events, a CUBIC\r\nresponse cutting the cwnd to 1 and using a timer to space out packets \r\nwould cause the connection to lose out badly to any competing Reno connections\r\nthat are not responding to fast recovery in this manner.\r\n\r\nThe text was presumably meant to just describe the response to CE marks,\r\nper RFC3168, so let's be explicit about that, to avoid Reno starving CUBIC.",
      "createdAt": "2021-10-28T13:23:37Z",
      "updatedAt": "2021-10-29T07:12:36Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "6a84ca895bc631ce31f071f378a02145de690766",
      "headRepository": "nealcardwell/rfc8312bis",
      "headRefName": "patch-2",
      "headRefOid": "bb59b4d1981a0f4f15542ea871e94ec8bd587986",
      "closedAt": "2021-10-29T07:12:36Z",
      "mergedAt": "2021-10-29T07:12:36Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "7cd66133528a1ce0dba4028bb8a5ea5c62d36723"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEpK-U84vN0Ah",
          "commit": {
            "abbreviatedOid": "bb59b4d"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-28T17:09:33Z",
          "updatedAt": "2021-10-28T17:09:33Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84vP2gB",
          "commit": {
            "abbreviatedOid": "bb59b4d"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-29T06:59:39Z",
          "updatedAt": "2021-10-29T06:59:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 130,
      "id": "PR_kwDOEpK-U84t77JM",
      "title": "issue 96",
      "url": "https://github.com/NTAP/rfc8312bis/pull/130",
      "state": "MERGED",
      "author": "lisongxu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/NTAP/rfc8312bis/issues/96",
      "createdAt": "2021-11-01T16:25:37Z",
      "updatedAt": "2021-11-03T11:43:13Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "5b8830aa98c6e1c73895aa2cf0c18bd39829fc8a",
      "headRepository": "lisongxu/rfc8312bis",
      "headRefName": "main",
      "headRefOid": "689a52ea6c8f4e51e949e69819d259bce31d7aed",
      "closedAt": "2021-11-03T11:43:13Z",
      "mergedAt": "2021-11-03T11:43:13Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "d15df6e0780f3b6d53fe3ebee8d349aefb9ad34c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEpK-U84vXA_7",
          "commit": {
            "abbreviatedOid": "20b8b3f"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-01T19:17:51Z",
          "updatedAt": "2021-11-01T19:17:51Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84vYJpM",
          "commit": {
            "abbreviatedOid": "20b8b3f"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-02T04:05:37Z",
          "updatedAt": "2021-11-02T04:05:42Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Can we add a changelog?",
              "createdAt": "2021-11-02T04:05:37Z",
              "updatedAt": "2021-11-02T04:05:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84vbVNK",
          "commit": {
            "abbreviatedOid": "689a52e"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-02T17:04:13Z",
          "updatedAt": "2021-11-02T17:04:14Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "added",
              "createdAt": "2021-11-02T17:04:13Z",
              "updatedAt": "2021-11-02T17:04:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84vdMf6",
          "commit": {
            "abbreviatedOid": "689a52e"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-03T07:38:58Z",
          "updatedAt": "2021-11-03T07:38:58Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84veH5B",
          "commit": {
            "abbreviatedOid": "689a52e"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-03T11:43:06Z",
          "updatedAt": "2021-11-03T11:43:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 131,
      "id": "PR_kwDOEpK-U84t_d5F",
      "title": "Update draft-ietf-tcpm-rfc8312bis.md",
      "url": "https://github.com/NTAP/rfc8312bis/pull/131",
      "state": "MERGED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR is intended to amend the text to align with my understanding of the RFC-series. This normatively  would require ssthresh to be set from flight_size; however, this is explicitly relaxed in RFC7661, so I suggest wording should be careful around this topic. I retained the original text observation that in fact some cubic implementations are known to set ssthresh from cwnd.\r\n\r\nNote:  I expected the REF to \"RFC7661\" to be informative (EXP).",
      "createdAt": "2021-11-02T16:01:09Z",
      "updatedAt": "2021-11-11T08:08:07Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "06cfa962dffe126705d2ef294528546d9eec008b",
      "headRepository": "gorryfair/rfc8312bis",
      "headRefName": "patch-3",
      "headRefOid": "4922abc5fb984a26c91df6941e8a1f48e571691d",
      "closedAt": "2021-11-11T08:08:07Z",
      "mergedAt": "2021-11-11T08:08:07Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "6539c0e8927fc06e66ebdfdd4aac7226322cb0db"
      },
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See #132.",
          "createdAt": "2021-11-02T16:03:44Z",
          "updatedAt": "2021-11-02T16:03:44Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "Does this mean that we don't need to update 5681 anymore, because 7661 OK'ed CUBIC's behavior? Should 7661 have updated 5681?",
          "createdAt": "2021-11-03T11:41:02Z",
          "updatedAt": "2021-11-03T11:41:02Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The issue I think is: RFC 7661 describes a framework for application-limited flows to determine an appropriate cwnd. It's a relaxation with caveats also about how a flow needs to behave when an \"unvalidated\" use of cwnd was not safe (i.e. the \"normal\" case of using cwnd proved to be unsafe). RFC 7661  *could* have been a PS and *could* have updated 5681 - at the moment neither is the case. As far as I know, some Cubic implementations do part of what RFC 7661 says, and others might do all. The final sentence of the suggested PR acknowledges this, without trying to interpret this, seeking to avoid blocking publication of this specific PS.\r\n\r\nI'll re-echo your question to others: Should 7661 have updated 5681? Should it become PS?",
          "createdAt": "2021-11-03T11:54:15Z",
          "updatedAt": "2021-11-03T11:54:15Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "> I'll re-echo your question to others: Should 7661 have updated 5681? Should it become PS?\r\n\r\nAt the moment, this document is intending to update 5681 to allow CUBIC's behavior. Since that is on the \"extreme\" side of what 7661 allowed, maybe 7661 should?",
          "createdAt": "2021-11-03T17:59:07Z",
          "updatedAt": "2021-11-03T17:59:07Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "This still needs a changelog entry, but is otherwise good to go.",
          "createdAt": "2021-11-06T08:50:22Z",
          "updatedAt": "2021-11-06T08:50:22Z"
        },
        {
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "body": "@gorryfair please add a changelog line.",
          "createdAt": "2021-11-09T06:16:19Z",
          "updatedAt": "2021-11-09T06:16:19Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@larseggert @goelvidhi Happy for someone to add a changeling entry.",
          "createdAt": "2021-11-09T08:52:32Z",
          "updatedAt": "2021-11-09T08:52:32Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEpK-U84vcptP",
          "commit": {
            "abbreviatedOid": "336dd9d"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-11-03T01:20:55Z",
          "updatedAt": "2021-11-03T01:28:19Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nmuch lower value than necessary. To avoid suboptimal performance with\r\n```",
              "createdAt": "2021-11-03T01:20:56Z",
              "updatedAt": "2021-11-03T01:28:19Z"
            },
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nto mitigate this issue as it would allow using a value between *cwnd* \r\n```",
              "createdAt": "2021-11-03T01:24:03Z",
              "updatedAt": "2021-11-03T01:28:19Z"
            },
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nSome implementations of CUBIC use *cwnd* instead of *flight_size* when calculating a new *ssthresh* using {{eqssthresh}}.\r\n```",
              "createdAt": "2021-11-03T01:28:11Z",
              "updatedAt": "2021-11-03T01:28:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84veHmB",
          "commit": {
            "abbreviatedOid": "aee3fbc"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Please fix Markdown nits and add changelog entry.",
          "createdAt": "2021-11-03T11:41:39Z",
          "updatedAt": "2021-11-03T11:41:39Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84vmNtp",
          "commit": {
            "abbreviatedOid": "114003b"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-05T07:12:02Z",
          "updatedAt": "2021-11-05T07:12:02Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84vyH0d",
          "commit": {
            "abbreviatedOid": "4922abc"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-09T18:32:52Z",
          "updatedAt": "2021-11-09T18:32:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 133,
      "id": "PR_kwDOEpK-U84uMm-1",
      "title": "Add and update test results to Section 5",
      "url": "https://github.com/NTAP/rfc8312bis/pull/133",
      "state": "MERGED",
      "author": "lisongxu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#91",
      "createdAt": "2021-11-07T21:59:10Z",
      "updatedAt": "2021-11-09T06:15:13Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "d15df6e0780f3b6d53fe3ebee8d349aefb9ad34c",
      "headRepository": "lisongxu/rfc8312bis",
      "headRefName": "main",
      "headRefOid": "f7de7cb4c5fc238eb1b5eaa162989a6b47570976",
      "closedAt": "2021-11-09T06:15:13Z",
      "mergedAt": "2021-11-09T06:15:13Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "06cfa962dffe126705d2ef294528546d9eec008b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEpK-U84vrk0t",
          "commit": {
            "abbreviatedOid": "84492b6"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-11-08T10:42:35Z",
          "updatedAt": "2021-11-08T10:42:49Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "```suggestion\r\n{{HLRX07}}{{H16}}{{CEHRX09}}{{HR11}}{{BSCLU13}}{{LBEWK16}}.\r\n```",
              "createdAt": "2021-11-08T10:42:36Z",
              "updatedAt": "2021-11-08T10:42:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEpK-U84vtTrW",
          "commit": {
            "abbreviatedOid": "f5a510d"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-08T17:22:14Z",
          "updatedAt": "2021-11-08T17:22:14Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84vupw1",
          "commit": {
            "abbreviatedOid": "f5a510d"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-09T01:18:32Z",
          "updatedAt": "2021-11-09T01:18:32Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84vuxTu",
          "commit": {
            "abbreviatedOid": "f5a510d"
          },
          "author": "sangtaeha",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "@lisongxu This looks good to me. Thanks! ",
          "createdAt": "2021-11-09T02:31:31Z",
          "updatedAt": "2021-11-09T02:31:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 134,
      "id": "PR_kwDOEpK-U84uR16j",
      "title": "Cite two refs by DOI instead of including the metadata here.",
      "url": "https://github.com/NTAP/rfc8312bis/pull/134",
      "state": "MERGED",
      "author": "larseggert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Also, @sangtaeha, `SXEZ19` is not cited anywhere in the body of the document?",
      "createdAt": "2021-11-09T11:08:10Z",
      "updatedAt": "2021-11-11T08:07:21Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "06cfa962dffe126705d2ef294528546d9eec008b",
      "headRepository": "NTAP/rfc8312bis",
      "headRefName": "doify-refs",
      "headRefOid": "d637e25ccd8e0a0a0d359b6c694e1c3f9972eab0",
      "closedAt": "2021-11-11T08:07:18Z",
      "mergedAt": "2021-11-11T08:07:18Z",
      "mergedBy": "larseggert",
      "mergeCommit": {
        "oid": "fe18f49f9e50494410e374bbdda38c1957ff8d24"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEpK-U84vxGA6",
          "commit": {
            "abbreviatedOid": "e7f0817"
          },
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Reference SXEZ19 should be added to Section 4.2 just above the target upper and lower bounds.\r\n\r\n\"The lower and upper bounds below ensure that CUBIC's congestion window increase rate is non-decreasing and is less than the increase rate of slow start {{SXEZ19}}.\"\r\n\r\nThanks",
          "createdAt": "2021-11-09T15:03:43Z",
          "updatedAt": "2021-11-09T15:03:43Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEpK-U84vyId1",
          "commit": {
            "abbreviatedOid": "e7f0817"
          },
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-09T18:33:45Z",
          "updatedAt": "2021-11-09T18:33:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 136,
      "id": "PR_kwDOEpK-U84w2UnC",
      "title": "add new subsections for spurious timeout and spurious loss by ack",
      "url": "https://github.com/NTAP/rfc8312bis/pull/136",
      "state": "OPEN",
      "author": "goelvidhi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #90 \r\n\r\nThis is an attempt to resolve the conflicting discussion regarding response to spurious events. Hopefully, we can reach some conclusion in this PR. :-)",
      "createdAt": "2022-01-12T10:26:55Z",
      "updatedAt": "2022-01-15T01:37:03Z",
      "baseRepository": "NTAP/rfc8312bis",
      "baseRefName": "main",
      "baseRefOid": "6539c0e8927fc06e66ebdfdd4aac7226322cb0db",
      "headRepository": "goelvidhi/rfc8312bis",
      "headRefName": "spurious-section",
      "headRefOid": "12d45a84e8928d7329c7e8b274d82ede2fcba0fa",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "COLLABORATOR",
          "body": "@nealcardwell @lisongxu @Injongrhee @markkukojo could you please review this PR? It would be good to conclude this before the next IETF. Thank you. :-)",
          "createdAt": "2022-01-14T08:06:51Z",
          "updatedAt": "2022-01-14T08:06:51Z"
        },
        {
          "author": "lisongxu",
          "authorAssociation": "COLLABORATOR",
          "body": "@goelvidhi Thanks, Vidhi!  A reader may be confused with \" When a spurious timeout is detected, the sender MAY restore the congestion control state and adapt the retransmission timer to avoid further spurious timeouts\" at line 759, as we have not described how to save the congestion control state yet (line 782). We move this sentence to line 800? Thanks",
          "createdAt": "2022-01-15T01:37:03Z",
          "updatedAt": "2022-01-15T01:37:03Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEpK-U84ywBfi",
          "commit": {
            "abbreviatedOid": "12d45a8"
          },
          "author": "larseggert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-13T09:24:47Z",
          "updatedAt": "2022-01-13T09:24:47Z",
          "comments": []
        }
      ]
    }
  ]
}